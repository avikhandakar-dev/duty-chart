var wi=Object.defineProperty;var Ni=(Z,x,we)=>x in Z?wi(Z,x,{enumerable:!0,configurable:!0,writable:!0,value:we}):Z[x]=we;var vn=(Z,x,we)=>Ni(Z,typeof x!="symbol"?x+"":x,we);(function(){"use strict";const Z=n=>n>="0"&&n<="9",x=n=>n>="a"&&n<="z"||n>="A"&&n<="Z"||n==="_"||n==="$";class we{constructor(e){vn(this,"pos",0);this.input=e}next(){const e=this.input,s=e.length;for(;this.pos<s&&/\s/.test(e[this.pos]??"");)this.pos++;if(this.pos>=s)return{type:"eof",start:this.pos,end:this.pos};const i=e[this.pos],r=this.pos;if(i==='"'||i==="'"){const u=i;this.pos++;let t="",h=!1;for(;this.pos<s;){const m=e[this.pos];if(this.pos++,h){switch(m){case"n":t+=`
`;break;case"t":t+="	";break;case"r":t+="\r";break;case"\\":case"'":case'"':t+=m;break;default:t+=m;break}h=!1;continue}if(m==="\\"){h=!0;continue}if(m===u)break;t+=m}return{type:"string",value:t,start:r,end:this.pos}}if(Z(i)||i==="."&&Z(e[this.pos+1]??"")){let u=i===".";for(this.pos++;this.pos<s;){const t=e[this.pos];if(Z(t))this.pos++;else if(t==="."&&!u)u=!0,this.pos++;else break}if(e[this.pos]==="e"||e[this.pos]==="E"){let h=this.pos+1;(e[h]==="+"||e[h]==="-")&&h++;const m=h;for(;h<s&&Z(e[h]);)h++;h>m&&(this.pos=h)}return{type:"number",value:e.slice(r,this.pos),start:r,end:this.pos}}if(x(i)){for(this.pos++;this.pos<s;){const h=e[this.pos];if(x(h)||Z(h))this.pos++;else break}const u=e.slice(r,this.pos),t=u.toLowerCase();return t==="and"?{type:"and",start:r,end:this.pos}:t==="or"?{type:"or",start:r,end:this.pos}:t==="not"?{type:"not",start:r,end:this.pos}:t==="true"||t==="false"?{type:"boolean",value:t,start:r,end:this.pos}:{type:"identifier",value:u,start:r,end:this.pos}}switch(this.pos++,i){case".":return{type:"dot",start:r,end:this.pos};case">":return e[this.pos]==="="?(this.pos++,{type:"gte",start:r,end:this.pos}):{type:"gt",start:r,end:this.pos};case"<":return e[this.pos]==="="?(this.pos++,{type:"lte",start:r,end:this.pos}):{type:"lt",start:r,end:this.pos};case"=":if(e[this.pos]==="=")return this.pos++,{type:"eq",start:r,end:this.pos};throw new Error(`Unexpected '=' at position ${r}`);case"!":if(e[this.pos]==="=")return this.pos++,{type:"neq",start:r,end:this.pos};throw new Error(`Unexpected '!' at position ${r}`);case"+":return{type:"plus",start:r,end:this.pos};case"-":return{type:"minus",start:r,end:this.pos};case"*":return{type:"star",start:r,end:this.pos};case"/":return{type:"slash",start:r,end:this.pos};case"%":return{type:"percent",start:r,end:this.pos};case"(":return{type:"lparen",start:r,end:this.pos};case")":return{type:"rparen",start:r,end:this.pos};case",":return{type:"comma",start:r,end:this.pos};case"?":return{type:"qmark",start:r,end:this.pos};case":":return{type:"colon",start:r,end:this.pos};case"[":return{type:"lbracket",start:r,end:this.pos};case"]":return{type:"rbracket",start:r,end:this.pos};default:throw new Error(`Unexpected character "${i}" at position ${r}`)}}}class se extends Error{constructor(e,s){super(e),this.position=s,this.name="ParseError"}}class qt{constructor(e){vn(this,"current");this.tokenizer=e,this.current=e.next()}eat(e){if(this.current.type!==e)throw new se(`Expected ${e} but found ${this.current.type}`,this.current.start);const s=this.current;return this.current=this.tokenizer.next(),s}match(e){return this.current.type===e?(this.current=this.tokenizer.next(),!0):!1}parseExpression(){return this.parseTernary()}parseTernary(){const e=this.parseOr();if(this.current.type==="qmark"){this.current=this.tokenizer.next();const s=this.parseExpression();this.eat("colon");const i=this.parseExpression();return{kind:"CallExpression",callee:"iff",args:[e,s,i]}}return e}parseOr(){let e=this.parseAnd();for(;this.current.type==="or";){this.current=this.tokenizer.next();const s=this.parseAnd();e={kind:"BinaryExpression",operator:"or",left:e,right:s}}return e}parseAnd(){let e=this.parseComparison();for(;this.current.type==="and";){this.current=this.tokenizer.next();const s=this.parseComparison();e={kind:"BinaryExpression",operator:"and",left:e,right:s}}return e}parseComparison(){let e=this.parseAddSub();for(;this.current.type==="gt"||this.current.type==="lt"||this.current.type==="gte"||this.current.type==="lte"||this.current.type==="eq"||this.current.type==="neq";){const s=this.current;this.current=this.tokenizer.next();const i=this.parseAddSub();let r="==";s.type==="gt"?r=">":s.type==="lt"?r="<":s.type==="gte"?r=">=":s.type==="lte"?r="<=":s.type==="neq"&&(r="!="),e={kind:"BinaryExpression",operator:r,left:e,right:i}}return e}parseAddSub(){let e=this.parseTerm();for(;this.current.type==="plus"||this.current.type==="minus";){const s=this.current;this.current=this.tokenizer.next();const i=this.parseTerm();e={kind:"BinaryExpression",operator:s.type==="plus"?"+":"-",left:e,right:i}}return e}parseTerm(){let e=this.parseFactor();for(;this.current.type==="star"||this.current.type==="slash"||this.current.type==="percent";){const s=this.current;this.current=this.tokenizer.next();const i=this.parseFactor();e={kind:"BinaryExpression",operator:s.type==="star"?"*":s.type==="slash"?"/":"%",left:e,right:i}}return e}parseFactor(){if(this.current.type==="not")return this.current=this.tokenizer.next(),{kind:"UnaryExpression",operator:"not",expr:this.parseFactor()};if(this.current.type==="plus"||this.current.type==="minus"){const e=this.current.type==="minus";this.current=this.tokenizer.next();const s=this.parseFactor();return e?{kind:"BinaryExpression",operator:"*",left:{kind:"NumberLiteral",value:-1},right:s}:s}return this.parsePostfix(this.parsePrimary())}parsePostfix(e){var i;let s=e;for(;;){if(this.current.type==="dot"){if(this.current=this.tokenizer.next(),this.current.type!=="identifier")throw new se("Expected identifier after '.'",this.current.start);const r=((i=this.current.value)==null?void 0:i.toString())??"";this.current=this.tokenizer.next(),s={kind:"MemberExpression",object:s,property:{kind:"Identifier",name:r}};continue}if(this.current.type==="lbracket"){this.current=this.tokenizer.next();const r=this.parseExpression();this.eat("rbracket"),s={kind:"IndexExpression",object:s,index:r};continue}break}return s}parsePrimary(){const e=this.current;switch(e.type){case"number":{this.current=this.tokenizer.next();const s=Number(e.value);if(!Number.isFinite(s))throw new se("Invalid number literal",e.start);return{kind:"NumberLiteral",value:s}}case"string":return this.current=this.tokenizer.next(),{kind:"StringLiteral",value:String(e.value??"")};case"boolean":return this.current=this.tokenizer.next(),{kind:"NumberLiteral",value:String(e.value||"").toLowerCase()==="true"?1:0};case"identifier":{this.current=this.tokenizer.next();const s=(e.value||"").toString();if(this.current.type==="lparen"){this.eat("lparen");const i=[];if(this.current.type!=="rparen")for(;i.push(this.parseExpression()),!!this.match("comma"););return this.eat("rparen"),{kind:"CallExpression",callee:s,args:i}}return{kind:"Identifier",name:s}}case"lparen":{this.eat("lparen");const s=this.parseExpression();return this.eat("rparen"),s}default:throw new se(`Unexpected token ${e.type}`,e.start)}}}function Ce(n){const e=new qt(new we(n)),s=e.parseExpression();if(e.current.type!=="eof")throw new se("Unexpected input after end of expression",e.current.start);return s}function he(n,e){const s=[];let i=0;for(let r=0;r<n.length;r++){const u=n[r];i+=u??0,r>=e&&(i-=n[r-e]??0),s.push(r>=e-1?i/e:void 0)}return s}function Vt(n,e){const s=[],i=e*(e+1)/2;for(let r=0;r<n.length;r++){if(r<e-1){s.push(void 0);continue}let u=0;for(let t=0;t<e;t++)u+=(n[r-t]??0)*(e-t);s.push(u/i)}return s}function Tt(n,e){const s=[];let i,r=0;for(let u=0;u<n.length;u++){const t=n[u];if(t==null){s.push(void 0);continue}if(i===void 0){if(r+=t,u<e-1){s.push(void 0);continue}i=r/e,s.push(i);continue}i=(i*(e-1)+t)/e,s.push(i)}return s}function J(n,e){const s=[],i=2/(e+1);let r;for(let u=0;u<n.length;u++){const t=n[u];if(t==null){s.push(void 0);continue}r=r===void 0?t:t*i+r*(1-i),s.push(r)}return s}function Bt(n,e){const s=[];let i,r=0,u=0,t=!1;const h=[],m=[];for(let g=0;g<n.length;g++){const a=n[g];if(a==null){s.push(void 0);continue}if(i===void 0){i=a,s.push(void 0);continue}const o=a-i;i=a;const f=o>0?o:0,l=o<0?-o:0;if(t)r=(r*(e-1)+f)/e,u=(u*(e-1)+l)/e;else{if(h.push(f),m.push(l),h.length<e){s.push(void 0);continue}r=h.reduce((c,d)=>c+d,0)/e,u=m.reduce((c,d)=>c+d,0)/e,t=!0}if(u===0)s.push(100);else{const c=r/u;s.push(100-100/(1+c))}}return s}function Re(n,e,s,i){const r=s.length,u=new Array(r).fill(0);let t;for(let g=0;g<r;g++){const a=n[g]??s[g]??NaN,o=e[g]??s[g]??NaN,f=s[g]??NaN;let l=Math.max(0,a-o);t!==void 0&&(l=Math.max(l,Math.abs(a-t),Math.abs(o-t))),u[g]=l,t=f}const h=new Array(r);let m=0;for(let g=0;g<r;g++)m+=u[g],g===i-1?h[g]=m/i:g>=i?h[g]=(h[g-1]*(i-1)+u[g])/i:h[g]=void 0;return h}function kn(n,e){const s=new Array(n.length);let i=0,r;for(let u=0;u<n.length;u++){const t=n[u],h=e[u]??0;if(r===void 0||t===void 0){s[u]=void 0,r=t;continue}t>r?i+=h:t<r&&(i-=h),s[u]=i,r=t}return s}function Fn(n,e,s,i){const r=s.length,u=new Array(r);for(let m=0;m<r;m++)u[m]=((n[m]??s[m]??0)+(e[m]??s[m]??0)+(s[m]??0))/3;const t=he(u.map(m=>m),i).map(m=>m),h=new Array(r);for(let m=0;m<r;m++){if(m<i-1){h[m]=void 0;continue}let g=0;for(let o=m-i+1;o<=m;o++)g+=Math.abs(u[o]-t[m]);g=g/i;const a=.015*g;h[m]=a===0?void 0:(u[m]-t[m])/a}return h}function yn(n,e,s,i,r){const u=s.length,t=new Array(u),h=new Array(u);for(let g=0;g<u;g++)h[g]=((n[g]??s[g]??0)+(e[g]??s[g]??0)+(s[g]??0))/3;const m=new Array(u);for(let g=0;g<u;g++)m[g]=h[g]*(i[g]??0);for(let g=0;g<u;g++){if(g<r){t[g]=void 0;continue}let a=0,o=0;for(let l=g-r+1;l<=g;l++)h[l]>=h[l-1]?a+=m[l]:o+=m[l];const f=o===0?1/0:a/o;t[g]=100-100/(1+f)}return t}function Kt(n,e){const s=n.map((t,h)=>((t??0)+(e[h]??0))/2),i=he(s,5),r=he(s,34),u=new Array(s.length);for(let t=0;t<s.length;t++){const h=i[t],m=r[t];u[t]=h===void 0||m===void 0?void 0:h-m}return u}function zt(n,e){const s=J(n,e).map(t=>t??NaN),i=J(s,e).map(t=>t??NaN),r=J(i,e).map(t=>t??NaN),u=new Array(n.length);for(let t=1;t<n.length;t++){const h=r[t-1],m=r[t];u[t]=h===void 0||m===void 0||h===0?void 0:(m/h-1)*100}return u[0]=void 0,u}function _n(n,e){const s=new Array(n.length);let i=0,r=0;for(let u=0;u<n.length;u++){const t=n[u],h=e[u]??0;if(t===void 0){s[u]=void 0;continue}i+=t*h,r+=h,s[u]=r===0?void 0:i/r}return s}function Gt(n,e,s){const i=new Array(n.length);let r=0,u=0;for(let t=0;t<n.length;t++){const h=n[t],m=e[t]??0;if(h!==void 0&&(r+=h*m,u+=m),t>=s){const g=n[t-s],a=e[t-s]??0;g!==void 0&&(r-=g*a,u-=a)}i[t]=t>=s-1&&u!==0?r/u:void 0}return i}function en(n,e,s){const i=n.map(m=>m??NaN),r=he(i,e),u=[];for(let m=0;m<i.length;m++){if(m<e-1){u.push(void 0);continue}let g=0;for(let f=m-e+1;f<=m;f++)g+=i[f];const a=g/e;let o=0;for(let f=m-e+1;f<=m;f++){const l=i[f]-a;o+=l*l}u.push(Math.sqrt(o/e))}const t=new Array(i.length),h=new Array(i.length);for(let m=0;m<i.length;m++){const g=r[m],a=u[m];t[m]=g===void 0||a===void 0?void 0:g+s*a,h[m]=g===void 0||a===void 0?void 0:g-s*a}return{mid:r,upper:t,lower:h}}function Ht(n,e,s,i,r){const u=s.length,t=Re(n,e,s,i).map(l=>l??NaN),h=new Array(u),m=new Array(u);for(let l=0;l<u;l++){const c=((n[l]??s[l]??0)+(e[l]??s[l]??0))/2,d=t[l];h[l]=c+r*d,m[l]=c-r*d}const g=new Array(u);let a=NaN,o=NaN,f=!0;for(let l=0;l<u;l++){a=Number.isFinite(a)?Math.min(h[l],a):h[l],o=Number.isFinite(o)?Math.max(m[l],o):m[l];const c=s[l]??NaN;if(!Number.isFinite(c)){g[l]=void 0;continue}f?(c<o&&(f=!1,a=h[l]),g[l]=o):(c>a&&(f=!0,o=m[l]),g[l]=a)}return g}function Wt(n,e,s,i,r){const u=J(s,i).map(a=>a??NaN),t=Re(n,e,s,i).map(a=>a??NaN),h=s.length,m=new Array(h),g=new Array(h);for(let a=0;a<h;a++){const o=u[a],f=t[a];m[a]=Number.isFinite(o)&&Number.isFinite(f)?o+r*f:void 0,g[a]=Number.isFinite(o)&&Number.isFinite(f)?o-r*f:void 0}return{mid:u,upper:m,lower:g}}function Yt(n,e,s){const i=n.length,r=new Array(i),u=new Array(i),t=new Array(i);for(let h=0;h<i;h++){if(h<s-1){r[h]=void 0,u[h]=void 0,t[h]=void 0;continue}let m=-1/0,g=1/0;for(let a=h-s+1;a<=h;a++){const o=n[a]??e[a]??NaN,f=e[a]??n[a]??NaN;Number.isFinite(o)&&o>m&&(m=o),Number.isFinite(f)&&f<g&&(g=f)}r[h]=m,u[h]=g,t[h]=Number.isFinite(m)&&Number.isFinite(g)?(m+g)/2:void 0}return{upper:r,lower:u,mid:t}}function Mn(n,e){const s=n.length,i=new Array(s);for(let r=0;r<s;r++){if(r<e-1){i[r]=void 0;continue}let u=0;for(let a=r-e+1;a<=r;a++)u+=n[a]??0;const t=u/e;let h=0;for(let a=r-e+1;a<=r;a++){const o=(n[a]??0)-t;h+=o*o}const m=Math.sqrt(h/e),g=n[r]??NaN;i[r]=Number.isFinite(m)&&m!==0?(g-t)/m:void 0}return i}function Sn(n,e){const s=n.length,i=new Array(s);let r=n[0];for(let u=0;u<s;u++){const t=n[u],h=e[u]??0;if(t==null){i[u]=void 0;continue}const m=t>=(r??t)?1:-1;i[u]=m*h,r=t}return i}function Xt(n){const e=n.length,s=new Array(e);let i=0;for(let r=0;r<e;r++){const u=n[r];if(u==null){s[r]=void 0;continue}i+=u,s[r]=i}return s}function Zt(n,e){const s=n.length,i=new Array(s),r=new Array(s),u=new Array(s);for(let t=0;t<s;t++){if(t<e-1){i[t]=void 0,r[t]=void 0,u[t]=void 0;continue}let h=0,m=0,g=0,a=0,o=0;for(let S=t-e+1;S<=t;S++){const w=S-(t-e+1),b=n[S]??NaN;Number.isFinite(b)&&(h+=w,m+=b,g+=w*w,a+=w*b,o++)}const f=o*g-h*h;if(f===0||o===0){i[t]=void 0,r[t]=void 0,u[t]=void 0;continue}const l=(o*a-h*m)/f,c=(m-l*h)/o,d=e-1,N=l*d+c;i[t]=N;const v=Mn(n.slice(t-e+1,t+1).map(S=>S??NaN),e).pop(),p=Number(v)*(n[t]??0?1:0);r[t]=Number.isFinite(N)?N+Math.abs(p||0):void 0,u[t]=Number.isFinite(N)?N-Math.abs(p||0):void 0}return{mid:i,upper:r,lower:u}}function An(n,e,s){const i=n.length,r=new Array(i);let u=0;for(let t=0;t<i;t++){const h=n[t],m=e[t]??0;if(h==null){r[t]=void 0;continue}const g=m/Math.max(1,e[t-1]??m);u=(u*(s-1)+h*g)/s,r[t]=u}return r}function Q(n){if(!n)return 0;let e=2166136261;for(let i=0;i<n.length;i++)e^=n.charCodeAt(i),e=Math.imul(e,16777619);const s=e>>>0;return s===0?1:s}function $n(n){return Number.isFinite(n)?n.toFixed(2):""}function Jt(n,e){if(!Number.isFinite(n))return"";if(!e)return $n(n);const s=String(e),i=s.includes("%"),r=s.split(".");let u=0;r.length>1&&(u=r[1].replace(/[^0-9#]/g,"").length);const t=i?n*100:n,h=u>0?t.toFixed(u):String(Math.round(t));return i?`${h}%`:h}class k extends Error{constructor(e){super(e),this.name="ExpressionEngineError"}}function H(n,e){const s=n.length,i=new Float32Array(s);let r=0;for(let u=0;u<s;u++){const t=n[u];if(Number.isFinite(t)&&(r+=t),u>=e){const h=n[u-e];Number.isFinite(h)&&(r-=h)}i[u]=u>=e-1?r:NaN}return i}function En(n,e,s){const i=n.length,r=new Float32Array(i),u=e-1,t=s==="rising";for(let h=0;h<i;h++){if(h<u){r[h]=NaN;continue}let m=!0,g=!0;const a=h-u;for(let o=a;o<=h;o++){const f=n[o];if(!Number.isFinite(f)){g=!1;break}if(o===a)continue;const l=n[o-1];if(!Number.isFinite(l)){g=!1;break}(t?!(f>l):!(f<l))&&(m=!1)}r[h]=g?m?1:0:NaN}return r}function In(n,e,s){let i=-1/0;for(let r=e;r<=s;r++){const u=n[r];Number.isFinite(u)&&u>i&&(i=u)}return i}function Ln(n,e,s){let i=1/0;for(let r=e;r<=s;r++){const u=n[r];Number.isFinite(u)&&u<i&&(i=u)}return i}function Qt(n,e){const s=n.length,i=new Float32Array(s),r=Math.max(1,Math.floor(e));for(let u=0;u<s;u++){const t=u-r,h=n[u],m=t>=0?n[t]:NaN;i[u]=Number.isFinite(h)&&Number.isFinite(m)?h-m:NaN}return i}function Se(n,e){const s=n.length,i=new Float32Array(s),r=Math.max(1,Math.floor(e));for(let u=0;u<s;u++){const t=u-r,h=n[u],m=t>=0?n[t]:NaN;!Number.isFinite(h)||!Number.isFinite(m)||m===0?i[u]=NaN:i[u]=(h-m)/m*100}return i}function xt(n,e){const s=n.length,i=new Float32Array(s),r=Math.max(1,Math.floor(e));for(let u=0;u<s;u++){const t=u-r,h=n[u],m=t>=0?n[t]:NaN;i[u]=Number.isFinite(h)&&Number.isFinite(m)?h-m:NaN}return i}function Y(n){const e=new Array(n.length);for(let s=0;s<n.length;s++){const i=n[s];e[s]=Number.isFinite(i)?i:void 0}return e}function ee(n){const e=new Float32Array(n.length);for(let s=0;s<n.length;s++){const i=n[s];e[s]=i==null||!Number.isFinite(i)?NaN:i}return e}function es(n,e,s,i){const r=Y(n),u=J(r,e),t=J(r,s),h=new Array(r.length);for(let a=0;a<r.length;a++){const o=u[a],f=t[a];h[a]=o==null||f==null?void 0:o-f}const m=J(h,i),g=new Array(r.length);for(let a=0;a<r.length;a++){const o=h[a],f=m[a];g[a]=o==null||f==null?void 0:o-f}return{line:ee(h),signal:ee(m),hist:ee(g)}}function ns(n,e,s,i,r){const u=s.length,t=new Array(u);for(let a=0;a<u;a++){const o=Math.max(0,a-i+1);let f=-1/0,l=1/0;for(let N=o;N<=a;N++){const v=Number.isFinite(n[N])?n[N]:s[N],p=Number.isFinite(e[N])?e[N]:s[N];Number.isFinite(v)&&v>f&&(f=v),Number.isFinite(p)&&p<l&&(l=p)}const c=s[a],d=f-l;!Number.isFinite(c)||!Number.isFinite(f)||!Number.isFinite(l)||d===0?t[a]=void 0:t[a]=100*((c-l)/d)}const h=t.map(a=>a??NaN),m=he(h,r),g=new Array(u);for(let a=0;a<u;a++){const o=m[a];g[a]=Number.isFinite(o)?o:void 0}return{k:ee(t),d:ee(g)}}function Cn(n,e,s,i){const r=s.length,u=new Float32Array(r);for(let t=0;t<r;t++){const h=Math.max(0,t-i+1);let m=-1/0,g=1/0,a=!1;for(let l=h;l<=t;l++){const c=Number.isFinite(n[l])?n[l]:s[l],d=Number.isFinite(e[l])?e[l]:s[l];Number.isFinite(c)&&(c>m&&(m=c),a=!0),Number.isFinite(d)&&(d<g&&(g=d),a=!0)}const o=s[t],f=m-g;if(!a||!Number.isFinite(o)||!Number.isFinite(m)||!Number.isFinite(g)||f===0){u[t]=NaN;continue}u[t]=-100*((m-o)/f)}return u}function je(n,e,s){const i=Ft(n,s),r=yt(e,s),u=n.length,t=new Float32Array(u),h=new Float32Array(u);for(let m=0;m<u;m++){const g=i[m],a=r[m];if(!Number.isFinite(g)||!Number.isFinite(a)){t[m]=NaN,h[m]=NaN;continue}t[m]=100*((s-g)/s),h[m]=100*((s-a)/s)}return{up:t,down:h}}function ts(n,e,s){const{up:i,down:r}=je(n,e,s),u=i.length,t=new Float32Array(u);for(let h=0;h<u;h++){const m=i[h],g=r[h];t[h]=Number.isFinite(m)&&Number.isFinite(g)?m-g:NaN}return t}function ie(n,e,s,i,r){const u=s.length,t=new Float32Array(u),h=new Float32Array(u),m=new Float32Array(u);for(let N=0;N<u;N++){const v=n[N],p=e[N],S=s[N];if(!Number.isFinite(v)||!Number.isFinite(p)||!Number.isFinite(S)){t[N]=NaN,h[N]=NaN,m[N]=NaN;continue}if(N===0){t[N]=Math.max(0,v-p),h[N]=0,m[N]=0;continue}const w=n[N-1],b=e[N-1],M=s[N-1];if(!Number.isFinite(w)||!Number.isFinite(b)||!Number.isFinite(M)){t[N]=NaN,h[N]=NaN,m[N]=NaN;continue}const F=v-w,A=b-p;h[N]=F>A&&F>0?F:0,m[N]=A>F&&A>0?A:0;const _=v-p,y=Math.abs(v-M),$=Math.abs(p-M);t[N]=Math.max(0,_,y,$)}const g=Fe(t,i),a=Fe(h,i),o=Fe(m,i),f=new Float32Array(u),l=new Float32Array(u),c=new Float32Array(u);for(let N=0;N<u;N++){const v=g[N],p=a[N],S=o[N];if(!Number.isFinite(v)||v===0||!Number.isFinite(p)||!Number.isFinite(S)){f[N]=NaN,l[N]=NaN,c[N]=NaN;continue}f[N]=100*(p/v),l[N]=100*(S/v);const w=f[N]+l[N];c[N]=w===0?NaN:100*(Math.abs(f[N]-l[N])/w)}const d=Fe(c,r);return{plus:f,minus:l,adx:d}}function Rn(n,e){const s=n.length,i=new Float32Array(s);for(let r=0;r<s;r++){const u=n[r],t=e[r],h=u+t;i[r]=Number.isFinite(u)&&Number.isFinite(t)&&h!==0?100*(Math.abs(u-t)/h):NaN}return i}function jn(n,e,s,i){const r=n.length,u=new Float32Array(r),t=Math.max(1,s+1),h=new Array(t);let m=0,g=0;const a=i||(o=>Number.isFinite(o)&&o!==0);for(let o=0;o<r;o++){const f=n[o];if(a(f)&&(h[g]=o,g=(g+1)%t,m<t&&(m+=1)),m>s){const l=h[(g-1-s+t)%t],c=e[l];u[o]=Number.isFinite(c)?c:NaN}else u[o]=NaN}return u}function Pn(n,e){if(!Number.isFinite(n)||!Number.isFinite(e)||!Number.isInteger(n)||!Number.isInteger(e)||n<1||e<1)throw new k("pivot left/right must be positive integers");return{left:n,right:e}}function ss(n,e,s,i){const r=n.length,u=new Float32Array(r);for(let t=0;t<r;t++){const h=t-s;if(h-e<0){u[t]=NaN;continue}const m=n[h];if(!Number.isFinite(m)){u[t]=NaN;continue}const g=h-e,a=h+s;let o=!0;for(let f=g;f<=a;f++){const l=n[f];if(!Number.isFinite(l)){o=!1;break}if(i==="high"){if(l>m){o=!1;break}}else if(l<m){o=!1;break}}u[t]=o?m:NaN}return u}const Un="time function args must be integers",Dn="timestamp month out of range";function nn(n){return Number.isFinite(n)?(new Date(n).getUTCDay()+6)%7+1:NaN}function tn(n,e){if(!Number.isFinite(n))return NaN;const s=new Date(n);switch(e){case"year":return s.getUTCFullYear();case"month":return s.getUTCMonth()+1;case"hour":return s.getUTCHours();case"minute":return s.getUTCMinutes();default:return s.getUTCSeconds()}}function re(n){if(!Number.isFinite(n)||!Number.isInteger(n))throw new k(Un)}function On(n){for(let e=0;e<n.length;e++){const s=n[e];if(Number.isFinite(s)&&!Number.isInteger(s))throw new k(Un)}}function qn(n,e,s,i,r,u){if(re(n),re(e),re(s),re(i),re(r),re(u),e<1||e>12)throw new k(Dn);return Date.UTC(n,e-1,s,i,r,u)}function Vn(n){var i,r;const e=(i=n.scalars)==null?void 0:i.__bardurationms;if(Number.isFinite(e)&&e>0)return e;const s=(r=n.series)==null?void 0:r.time;if(s&&s.length>1)for(let u=s.length-1;u>0;u--){const t=s[u],h=s[u-1];if(!Number.isFinite(t)||!Number.isFinite(h))continue;const m=t-h;if(Number.isFinite(m)&&m>0)return m}return 0}function Tn(n){var s;const e=(s=n.scalars)==null?void 0:s.__nowms;return Number.isFinite(e)?e:Date.now()}const Pe="session.isin session must be in HHMM-HHMM",sn="session.isin time must be a number",Bn=new Map;function Kn(n){const e=String(n||"").trim(),s=Bn.get(e);if(s)return s;const i=e.match(/^(\d{2})(\d{2})-(\d{2})(\d{2})$/);if(!i)throw new k(Pe);const r=Number(i[1]),u=Number(i[2]),t=Number(i[3]),h=Number(i[4]);if(![r,u,t,h].every(Number.isFinite)||r<0||r>23||t<0||t>23||u<0||u>59||h<0||h>59)throw new k(Pe);const m=r*60+u,g=t*60+h,a={start:m,end:g};return Bn.set(e,a),a}function rn(n){const e=new Date(n);return e.getUTCHours()*60+e.getUTCMinutes()}function on(n,e,s){return e<=s?n>=e&&n<=s:n>=e||n<=s}function L(n,e){if(n.kind==="series")return n.value;const s=new Float32Array(e.length);return s.fill(n.value),s}function j(n){if(n.kind==="scalar")return n.value;const e=n.value;return e.length?e[e.length-1]:NaN}function Ae(n,e){const s=n.length,i=new Float32Array(s);for(let r=0;r<s;r++)i[r]=e(n[r]);return i}function Ue(n,e,s){const i=n.length,r=new Float32Array(i);for(let u=0;u<i;u++)r[u]=s(n[u],e[u]);return r}const is="unsafe division: divisor is 0/na",oe="math domain error: sqrt/log/pow/asin/acos",zn="ternary branches must both be numeric or both non-numeric",$e="history index must be integer >= 0",Gn="array index must be integer >= 0",rs="array index must be an integer",os="Negative array index not allowed",as="array.set index must be within array size",Hn="array.push value must be a string",cs="condition is na; treated as false",De="condition must be bool or number",ls="math.mod divisor is 0/na",us="math.fmod divisor is 0/na",fs="atr length must be integer >= 1",Wn="williamsr length must be integer >= 1",Yn="aroon length must be integer >= 1",Xn="dmi length must be integer >= 1",Zn="dmi smoothing must be integer >= 1",Jn="adx length must be integer >= 1",Qn="plus_di length must be integer >= 1",xn="minus_di length must be integer >= 1",et="dx length must be integer >= 1",nt="aroonosc length must be integer >= 1",tt="highest length must be integer >= 1",st="lowest length must be integer >= 1",it="sum length must be integer >= 1",rt="rising length must be integer >= 1",ot="falling length must be integer >= 1",Oe="valuewhen occurrence must be integer >= 0",hs=new Set(["syminfo","strategy","barstate","timeframe"]),Ne=n=>{const e=[];let s=n;for(;s.kind==="MemberExpression";)e.unshift(s.property.name),s=s.object;if(s.kind!=="Identifier")return null;const i=s.name.toLowerCase();return hs.has(i)?[i,...e].join("_"):null},ae=n=>Number.isFinite(n)?n===0?0:1:NaN,an=n=>{const e=ae(n);return Number.isFinite(e)?e===0?1:0:NaN},be=(n,e)=>{const s=ae(n);if(s===0)return 0;const i=ae(e);return s===1?i:i===0?0:Number.isFinite(i)?NaN:NaN},pe=(n,e)=>{const s=ae(n);if(s===1)return 1;const i=ae(e);return s===0?i:i===1?1:Number.isFinite(i)?NaN:NaN},me=(n,e,s)=>Number.isFinite(n)?n!==0:(e&&s&&e.emitOnce(s,cs),!1),cn=(n,e,s)=>me(n,e==null?void 0:e.diagnostics,s),O=(n,e,s)=>{var i;(i=n==null?void 0:n.diagnostics)==null||i.emitOnce(e,s)},ms=n=>Number.isFinite(n)&&Math.floor(n)===n,ln=n=>n===">"||n==="<"||n===">="||n==="<="||n==="=="||n==="!=",ve=(n,e,s,i)=>s?Number.isFinite(n)?!Number.isFinite(e)||e===0?(O(i,"div_zero",is),NaN):n/e:NaN:e===0?NaN:n/e,at=(n,e,s,i)=>s&&(!Number.isFinite(n)||!Number.isFinite(e)||e===0)?(O(i,"fmod_div_zero",us),NaN):n%e,ct=(n,e,s,i)=>s&&(!Number.isFinite(n)||!Number.isFinite(e)||e===0)?(O(i,"mod_div_zero",ls),NaN):(n%e+e)%e,un=(n,e,s,i)=>{if(!s)return Math.pow(n,e);if(!Number.isFinite(n)||!Number.isFinite(e))return O(i,"math_domain",oe),NaN;if(n<0&&!ms(e))return O(i,"math_domain",oe),NaN;const r=Math.pow(n,e);return Number.isFinite(r)?r:(O(i,"math_domain",oe),NaN)},lt=(n,e,s)=>e&&(!Number.isFinite(n)||n<0)?(O(s,"math_domain",oe),NaN):Math.sqrt(n),ut=(n,e,s)=>{if(!e)return Math.log(n);if(!Number.isFinite(n)||n<=0)return O(s,"math_domain",oe),NaN;const i=Math.log(n);return Number.isFinite(i)?i:NaN},ft=(n,e,s)=>{if(!e)return Math.log10(n);if(!Number.isFinite(n)||n<=0)return O(s,"math_domain",oe),NaN;const i=Math.log10(n);return Number.isFinite(i)?i:NaN},ht=(n,e,s)=>e&&(!Number.isFinite(n)||n<-1||n>1)?(O(s,"math_domain",oe),NaN):Math.asin(n),mt=(n,e,s)=>e&&(!Number.isFinite(n)||n<-1||n>1)?(O(s,"math_domain",oe),NaN):Math.acos(n),dt=(n,e)=>{if(!e)return Math.tan(n);if(!Number.isFinite(n))return NaN;const s=Math.tan(n);return Number.isFinite(s)?s:NaN},gt=(n,e)=>{if(!e)return Math.exp(n);if(!Number.isFinite(n))return NaN;const s=Math.exp(n);return Number.isFinite(s)?s:NaN},ce=(n,e,s,i)=>!Number.isFinite(n)||!Number.isInteger(n)||n<0?(O(i,e,s),NaN):n,qe=(n,e,s)=>!Number.isFinite(n)||!Number.isInteger(n)?(O(s,`${e}:int`,rs),NaN):n<0?(O(s,`${e}:neg`,os),NaN):n,fn=(n,e,s,i)=>{const r=qe(n,s,i);return!Number.isFinite(r)||!Number.isFinite(e)?0:r>=e?(O(i,`${s}:oob`,as),0):1},V=(n,e,s,i)=>!Number.isFinite(n)||!Number.isInteger(n)||n<1?(O(i,e,s),NaN):n,W=n=>{const e=new Float32Array(n);return e.fill(NaN),e},ds=new Set(["tostring","format","upper","lower","trim","replace","replace_all","contains","startswith","endswith","length","substring","repeat"]),gs=new Set(["tostring","format","upper","lower","trim","replace","replace_all","substring","repeat"]),wt=new WeakMap,q=n=>{const e=wt.get(n);if(e)return e;let s="";switch(n.kind){case"NumberLiteral":s=`n:${n.value}`;break;case"StringLiteral":s=`s:${n.value}`;break;case"Identifier":s=`id:${n.name}`;break;case"UnaryExpression":s=`u:${n.operator}:${q(n.expr)}`;break;case"BinaryExpression":s=`b:${n.operator}:${q(n.left)}:${q(n.right)}`;break;case"CallExpression":s=`c:${n.callee}:${n.args.map(q).join(",")}`;break;case"MemberExpression":s=`m:${q(n.object)}:${n.property.name}`;break;case"IndexExpression":s=`i:${q(n.object)}:${q(n.index)}`;break;default:s="expr"}return wt.set(n,s),s},te=n=>{switch(n.kind){case"Identifier":return n.name;case"NumberLiteral":return Number.isFinite(n.value)?String(n.value):"na";case"StringLiteral":return JSON.stringify(n.value);case"MemberExpression":return`${te(n.object)}.${n.property.name}`;case"IndexExpression":return`${te(n.object)}[${te(n.index)}]`;case"CallExpression":return`${n.callee}(${n.args.map(te).join(", ")})`;case"UnaryExpression":return`${n.operator} ${te(n.expr)}`;case"BinaryExpression":return`${te(n.left)} ${n.operator} ${te(n.right)}`;default:return"expr"}},Nt=(n,e)=>{O(n,`member:${q(e)}`,`Unsupported member access: ${te(e)}`)},bt=(n,e)=>{O(n,`index:${q(e)}`,`Unsupported indexing: ${te(e)}`)},pt=new WeakMap,le=n=>{const e=pt.get(n);if(e!=null)return e;let s=!1;switch(n.kind){case"StringLiteral":s=!0;break;case"CallExpression":{const i=n.callee.toLowerCase();if(gs.has(i)){s=!0;break}(i==="iff"||i==="iif"||i==="if")&&n.args.length===3&&(s=le(n.args[1])||le(n.args[2]));break}default:s=!1}return pt.set(n,s),s},ue=(n,e,s)=>`cond:${e!=null&&e.selfKey?e.selfKey:"cond"}:${q(n)}:${s}`,ws=(n,e)=>{let s=!1;const i=r=>{if(!s)switch(r.kind){case"Identifier":{const u=r.name.replace(/\s+/g,"_").toLowerCase();e.series[u]&&(s=!0);return}case"MemberExpression":{const u=Ne(r);if(u){const t=u.replace(/\s+/g,"_").toLowerCase();e.series[t]&&(s=!0);return}i(r.object);return}case"IndexExpression":i(r.object),i(r.index);return;case"UnaryExpression":i(r.expr);return;case"BinaryExpression":i(r.left),i(r.right);return;case"CallExpression":r.args.forEach(u=>i(u));return;default:return}};return i(n),s},ke=n=>{switch(n.kind){case"StringLiteral":return"nonNumeric";case"NumberLiteral":return"numeric";case"Identifier":{const e=n.name.replace(/\s+/g,"_").toLowerCase();return e==="true"||e==="false"?"nonNumeric":"numeric"}case"MemberExpression":{const e=Ne(n);if(e){const s=e.replace(/\s+/g,"_").toLowerCase();if(s==="true"||s==="false")return"nonNumeric"}return"numeric"}case"IndexExpression":return"numeric";case"UnaryExpression":return n.operator==="not"?"nonNumeric":"numeric";case"BinaryExpression":return ln(n.operator)||n.operator==="and"||n.operator==="or"?"nonNumeric":"numeric";case"CallExpression":{const e=n.callee.toLowerCase();if((e==="iff"||e==="iif"||e==="if")&&n.args.length===3){const s=ke(n.args[1]),i=ke(n.args[2]);return s===i?s:"numeric"}return ds.has(e)?"nonNumeric":"numeric"}default:return"numeric"}};function vt(n,e,s,i){var l;const r=e.kind==="series",u=s.kind==="series",t=((l=i.scalars)==null?void 0:l.__pinev2)===1,h=t&&ln(n),m=c=>Number.isFinite(c)&&c!==0;if(!r&&!u){const c=e.value,d=s.value;if(h&&(!Number.isFinite(c)||!Number.isFinite(d)))return{kind:"scalar",value:NaN};switch(n){case"+":return{kind:"scalar",value:c+d};case"-":return{kind:"scalar",value:c-d};case"*":return{kind:"scalar",value:c*d};case"/":return{kind:"scalar",value:ve(c,d,t,i)};case"%":return{kind:"scalar",value:d===0?NaN:c%d};case">":return{kind:"scalar",value:Number.isFinite(c)&&Number.isFinite(d)&&c>d?1:0};case"<":return{kind:"scalar",value:Number.isFinite(c)&&Number.isFinite(d)&&c<d?1:0};case">=":return{kind:"scalar",value:Number.isFinite(c)&&Number.isFinite(d)&&c>=d?1:0};case"<=":return{kind:"scalar",value:Number.isFinite(c)&&Number.isFinite(d)&&c<=d?1:0};case"==":return{kind:"scalar",value:Number.isFinite(c)&&Number.isFinite(d)&&Math.abs(c-d)<1e-9?1:0};case"!=":return{kind:"scalar",value:Number.isFinite(c)&&Number.isFinite(d)&&Math.abs(c-d)>=1e-9?1:0};case"and":return{kind:"scalar",value:t?be(c,d):m(c)&&m(d)?1:0};case"or":return{kind:"scalar",value:t?pe(c,d):m(c)||m(d)?1:0}}}const g=L(e,i),a=L(s,i),o=i.length,f=new Float32Array(o);for(let c=0;c<o;c++){const d=g[c],N=a[c];if(h&&(!Number.isFinite(d)||!Number.isFinite(N))){f[c]=NaN;continue}switch(n){case"+":f[c]=d+N;break;case"-":f[c]=d-N;break;case"*":f[c]=d*N;break;case"/":f[c]=ve(d,N,t,i);break;case"%":f[c]=N===0?NaN:d%N;break;case">":f[c]=Number.isFinite(d)&&Number.isFinite(N)&&d>N?1:0;break;case"<":f[c]=Number.isFinite(d)&&Number.isFinite(N)&&d<N?1:0;break;case">=":f[c]=Number.isFinite(d)&&Number.isFinite(N)&&d>=N?1:0;break;case"<=":f[c]=Number.isFinite(d)&&Number.isFinite(N)&&d<=N?1:0;break;case"==":f[c]=Number.isFinite(d)&&Number.isFinite(N)&&Math.abs(d-N)<1e-9?1:0;break;case"!=":f[c]=Number.isFinite(d)&&Number.isFinite(N)&&Math.abs(d-N)>=1e-9?1:0;break;case"and":f[c]=t?be(d,N):m(d)&&m(N)?1:0;break;case"or":f[c]=t?pe(d,N):m(d)||m(N)?1:0;break}}return{kind:"series",value:f}}function Ns(n,e){var g;if(!(((g=e.scalars)==null?void 0:g.__pinev2)===1)||n.operator!=="and"&&n.operator!=="or")return vt(n.operator,ne(n.left,e),ne(n.right,e),e);const i=ne(n.left,e),r=n.operator;if(i.kind==="scalar"){const a=ae(i.value);if(r==="and"&&a===0)return{kind:"scalar",value:0};if(r==="or"&&a===1)return{kind:"scalar",value:1};const o=ne(n.right,e);if(o.kind==="scalar")return{kind:"scalar",value:r==="and"?be(a,o.value):pe(a,o.value)};const f=L(o,e),l=new Float32Array(f.length);for(let c=0;c<f.length;c++){const d=f[c];l[c]=r==="and"?be(a,d):pe(a,d)}return{kind:"series",value:l}}const u=L(i,e),t=u.length,h=new Float32Array(t),m={series:e.series,scalars:e.scalars,strings:e.strings,draw:e.draw,diagnostics:e.diagnostics,strategy:e.strategy,loopRuntime:e.loopRuntime,funcRuntime:e.funcRuntime,length:t,index:0};for(let a=0;a<t;a++){const o=u[a],f=ae(o);if(r==="and"&&f===0){h[a]=0;continue}if(r==="or"&&f===1){h[a]=1;continue}m.index=a;const l=P(n.right,m);h[a]=r==="and"?be(o,l):pe(o,l)}return{kind:"series",value:h}}function z(n,e){const s=n.length,i=new Float32Array(s);let r=0,u=0;for(let t=0;t<s;t++){const h=n[t];if(Number.isFinite(h)&&(r+=h,u+=1),t>=e){const m=n[t-e];Number.isFinite(m)&&(r-=m,u-=1)}t>=e-1?i[t]=u>0?r/u:NaN:i[t]=NaN}return i}function B(n,e){const s=n.length,i=new Float32Array(s),r=2/(e+1);let u;for(let t=0;t<s;t++){const h=n[t];if(!Number.isFinite(h)){i[t]=u===void 0?NaN:u;continue}if(u===void 0||!Number.isFinite(u)){u=h,i[t]=h;continue}u=h*r+u*(1-r),i[t]=u}return i}function hn(n,e,s){const i=n.length,r=new Float32Array(i);let u=NaN;for(let t=0;t<i;t++){const h=n[t],m=e[t],g=s[t];let a=Math.max(0,h-m);Number.isFinite(u)&&(a=Math.max(a,Math.abs(h-u),Math.abs(m-u))),r[t]=a,u=g}return r}function Fe(n,e){const s=n.length,i=new Float32Array(s);let r,u=0,t=0;for(let h=0;h<s;h++){const m=n[h];if(r===void 0){if(Number.isFinite(m)&&(u+=m,t+=1),t<e){i[h]=NaN;continue}r=u/e,i[h]=r;continue}Number.isFinite(m)&&(r=(r*(e-1)+m)/e),i[h]=r}return i}function kt(n,e){const s=n.length,i=new Float32Array(s);let r,u=0,t=0,h=!1;const m=[],g=[];for(let a=0;a<s;a++){const o=n[a];if(!Number.isFinite(o)){i[a]=NaN;continue}if(r===void 0){r=o,i[a]=NaN;continue}if(!Number.isFinite(r)){r=o,i[a]=NaN;continue}const f=o-r;r=o;const l=f>0?f:0,c=f<0?-f:0;if(h)u=(u*(e-1)+l)/e,t=(t*(e-1)+c)/e;else{m.push(l),g.push(c);const d=m.length,N=Math.max(1,Math.min(e,d));u=m.reduce((v,p)=>v+p,0)/N,t=g.reduce((v,p)=>v+p,0)/N,d>=e&&(h=!0)}if(t===0)i[a]=100;else{const d=u/t;i[a]=100-100/(1+d)}}return i}function mn(n,e){const s=n.length,i=new Float32Array(s);for(let r=0;r<s;r++){if(r<e-1){i[r]=NaN;continue}let u=0,t=0;for(let g=r-e+1;g<=r;g++){const a=n[g];Number.isFinite(a)&&(u+=a,t+=1)}if(t<2){i[r]=NaN;continue}const h=u/t;let m=0;for(let g=r-e+1;g<=r;g++){const a=n[g];if(!Number.isFinite(a))continue;const o=a-h;m+=o*o}i[r]=Math.sqrt(m/t)}return i}function Ve(n,e){const s=n.length,i=new Float32Array(s);for(let r=0;r<s;r++){if(r<e-1){i[r]=NaN;continue}let u=0,t=0;for(let h=0;h<e;h++){const m=n[r-h],g=e-h;Number.isFinite(m)&&(u+=m*g,t+=g)}i[r]=t>0?u/t:NaN}return i}function bs(n,e){const s=B(n,e),i=B(s,e),r=n.length,u=new Float32Array(r);for(let t=0;t<r;t++){const h=s[t],m=i[t];u[t]=Number.isFinite(h)&&Number.isFinite(m)?2*h-m:NaN}return u}function ps(n,e){const s=B(n,e),i=B(s,e),r=B(i,e),u=n.length,t=new Float32Array(u);for(let h=0;h<u;h++){const m=s[h],g=i[h],a=r[h];t[h]=Number.isFinite(m)&&Number.isFinite(g)&&Number.isFinite(a)?3*m-3*g+a:NaN}return t}function vs(n,e){const s=Math.ceil((e+1)/2),i=Math.floor((e+1)/2);return z(z(n,s),i)}function ks(n,e){const s=n.length,i=new Float32Array(s);for(let r=0;r<s;r++){if(r<e-1){i[r]=NaN;continue}let u=0,t=0;for(let h=0;h<e;h++){const m=n[r-h];if(!Number.isFinite(m))continue;const g=Math.min(h+1,e-h);u+=m*g,t+=g}i[r]=t>0?u/t:NaN}return i}function Fs(n,e){const s=Math.max(1,Math.floor(e/2)),i=Math.max(1,Math.round(Math.sqrt(e))),r=Ve(n,s),u=Ve(n,e),t=n.length,h=new Float32Array(t);for(let m=0;m<t;m++){const g=r[m],a=u[m];h[m]=Number.isFinite(g)&&Number.isFinite(a)?2*g-a:NaN}return Ve(h,i)}function ys(n,e,s,i){const r=n.length,u=new Float32Array(r),t=2/(s+1),h=2/(i+1);let m=NaN;for(let g=0;g<r;g++){const a=n[g];if(!Number.isFinite(a)||g<e){u[g]=NaN;continue}const o=n[g-e];if(!Number.isFinite(o)){u[g]=NaN;continue}let f=0,l=!0;for(let v=g-e+1;v<=g;v++){const p=n[v],S=n[v-1];if(!Number.isFinite(p)||!Number.isFinite(S)){l=!1;break}f+=Math.abs(p-S)}if(!l||f===0){u[g]=NaN;continue}const d=Math.abs(a-o)/f,N=Math.pow(d*(t-h)+h,2);Number.isFinite(m)||(m=a),m=m+N*(a-m),u[g]=m}return u}function _s(n,e,s,i){const r=n.length,u=new Float32Array(r),t=s*(e-1),h=e/i,m=[];for(let g=0;g<e;g++){const a=Math.exp(-((g-t)*(g-t))/(2*h*h));m.push(a)}for(let g=0;g<r;g++){if(g<e-1){u[g]=NaN;continue}let a=0,o=0;for(let f=0;f<e;f++){const l=n[g-e+1+f];if(!Number.isFinite(l))continue;const c=m[f];a+=l*c,o+=c}u[g]=o>0?a/o:NaN}return u}function Ms(n,e,s){const i=B(n,e),r=B(i,e),u=B(r,e),t=B(u,e),h=B(t,e),m=B(h,e),g=s,a=g*g,o=a*g,f=-o,l=3*a+3*o,c=-6*a-3*g-3*o,d=1+3*g+o+3*a,N=n.length,v=new Float32Array(N);for(let p=0;p<N;p++){const S=u[p],w=h[p],b=m[p],M=t[p];v[p]=Number.isFinite(S)&&Number.isFinite(M)&&Number.isFinite(w)&&Number.isFinite(b)?f*b+l*w+c*M+d*S:NaN}return v}function dn(n,e,s,i){const r=hn(n,e,s),u=r.length,t=new Float32Array(u);let h=0;for(let m=0;m<u;m++)h+=r[m],m===i-1?t[m]=h/i:m>=i?t[m]=(t[m-1]*(i-1)+r[m])/i:t[m]=NaN;return t}function Ss(n,e,s,i){const r=dn(n,e,s,i),u=r.length,t=new Float32Array(u);for(let h=0;h<u;h++){const m=r[h],g=s[h];t[h]=Number.isFinite(m)&&Number.isFinite(g)&&g!==0?m/g*100:NaN}return t}function As(n,e){const s=n.length,i=new Float32Array(s),r=[],u=[];for(let t=0;t<s;t++){const h=n[t],m=t>0?n[t-1]:NaN;if(!Number.isFinite(h)||!Number.isFinite(m))r.push(0),u.push(0);else{const f=h-m;r.push(f>0?f:0),u.push(f<0?-f:0)}if(t<e){i[t]=NaN;continue}let g=0,a=0;for(let f=t-e+1;f<=t;f++)g+=r[f],a+=u[f];const o=g+a;i[t]=o===0?NaN:100*(g-a)/o}return i}function $s(n,e,s){const i=n.length,r=new Float32Array(i);for(let o=0;o<i;o++){const f=n[o],l=o>0?n[o-1]:NaN;r[o]=Number.isFinite(f)&&Number.isFinite(l)?f-l:NaN}const u=B(r,e),t=B(u,s),h=new Float32Array(i);for(let o=0;o<i;o++)h[o]=Math.abs(r[o]);const m=B(h,e),g=B(m,s),a=new Float32Array(i);for(let o=0;o<i;o++){const f=t[o],l=g[o];a[o]=Number.isFinite(f)&&Number.isFinite(l)&&l!==0?100*f/l:NaN}return a}function Es(n,e,s,i){const r=kt(n,e),u=ye(r,e),t=_e(r,e),h=n.length,m=new Float32Array(h);for(let a=0;a<h;a++){const o=r[a],f=u[a],l=t[a],c=f-l;m[a]=Number.isFinite(o)&&Number.isFinite(c)&&c!==0?(o-l)/c*100:NaN}let g=m;return s&&s>1&&(g=z(g,s)),i&&i>1&&(g=z(g,i)),g}function Is(n,e,s){const i=B(n,e),r=B(n,s),u=n.length,t=new Float32Array(u);for(let h=0;h<u;h++){const m=i[h],g=r[h];t[h]=Number.isFinite(m)&&Number.isFinite(g)&&g!==0?(m-g)/g*100:NaN}return t}function Ls(n,e){const s=n.length,i=new Float32Array(s);for(let h=0;h<s;h++)i[h]=(n[h]+e[h])/2;const r=z(i,5),u=z(i,34),t=new Float32Array(s);for(let h=0;h<s;h++){const m=r[h],g=u[h];t[h]=Number.isFinite(m)&&Number.isFinite(g)?m-g:NaN}return t}function Cs(n,e){const s=B(n,e),i=B(s,e),r=B(i,e),u=n.length,t=new Float32Array(u);t[0]=NaN;for(let h=1;h<u;h++){const m=r[h-1],g=r[h];t[h]=Number.isFinite(m)&&Number.isFinite(g)&&m!==0?(g/m-1)*100:NaN}return t}function Rs(n,e){const s=z(n,e),i=mn(n,e),r=n.length,u=new Float32Array(r);for(let t=0;t<r;t++){const h=s[t],m=i[t],g=n[t];u[t]=Number.isFinite(g)&&Number.isFinite(h)&&Number.isFinite(m)&&m!==0?(g-h)/m:NaN}return u}function js(n,e,s,i){const r=s.length,u=new Float32Array(r);let t=0;for(let h=0;h<r;h++){const m=n[h],g=e[h],a=s[h],o=i[h];if(!Number.isFinite(m)||!Number.isFinite(g)||!Number.isFinite(a)){u[h]=NaN;continue}const f=m-g,l=Number.isFinite(f)&&f!==0?(2*a-m-g)/f:0;Number.isFinite(o)&&(t+=l*o),u[h]=t}return u}function Ps(n,e,s,i,r){const u=s.length,t=new Float32Array(u);for(let a=0;a<u;a++){const o=n[a],f=e[a],l=s[a],c=i[a];if(!Number.isFinite(o)||!Number.isFinite(f)||!Number.isFinite(l)){t[a]=NaN;continue}const d=o-f,N=Number.isFinite(d)&&d!==0?(2*l-o-f)/d:0;t[a]=Number.isFinite(c)?N*c:NaN}const h=H(t,r),m=H(i,r),g=new Float32Array(u);for(let a=0;a<u;a++){const o=h[a],f=m[a];g[a]=Number.isFinite(o)&&Number.isFinite(f)&&f!==0?o/f:NaN}return g}function Us(n,e,s,i,r){const u=s.length,t=dn(n,e,s,i),h=new Float32Array(u),m=new Float32Array(u);let g=NaN,a=NaN,o=!0;for(let f=0;f<u;f++){const l=n[f],c=e[f],d=s[f],N=t[f];if(!Number.isFinite(l)||!Number.isFinite(c)||!Number.isFinite(N)){h[f]=NaN,m[f]=NaN;continue}const v=(l+c)/2,p=v+r*N,S=v-r*N;if(g=Number.isFinite(g)?Math.min(p,g):p,a=Number.isFinite(a)?Math.max(S,a):S,!Number.isFinite(d)){h[f]=NaN,m[f]=NaN;continue}o?d<a?(o=!1,g=p,h[f]=g,m[f]=-1):(h[f]=a,m[f]=1):d>g?(o=!0,a=S,h[f]=a,m[f]=1):(h[f]=g,m[f]=-1)}return{line:h,dir:m}}function Ds(n,e,s,i,r){const u=B(s,i),t=dn(n,e,s,i),h=s.length,m=new Float32Array(h),g=new Float32Array(h);for(let a=0;a<h;a++){const o=u[a],f=t[a];m[a]=Number.isFinite(o)&&Number.isFinite(f)?o+r*f:NaN,g[a]=Number.isFinite(o)&&Number.isFinite(f)?o-r*f:NaN}return{mid:u,upper:m,lower:g}}function Os(n,e,s){const i=ye(n,s),r=_e(e,s),u=n.length,t=new Float32Array(u);for(let h=0;h<u;h++){const m=i[h],g=r[h];t[h]=Number.isFinite(m)&&Number.isFinite(g)?(m+g)/2:NaN}return{upper:i,lower:r,mid:t}}function qs(n,e,s,i,r){const u=n.length,t=new Float32Array(u);if(!u)return t;let h=!0;u>1&&Number.isFinite(n[1])&&Number.isFinite(n[0])&&(h=n[1]>=n[0]);let m=s,g=h?n[0]:e[0],a=h?e[0]:n[0];t[0]=a;for(let o=1;o<u;o++){const f=n[o],l=e[o];if(!Number.isFinite(f)||!Number.isFinite(l)){t[o]=NaN;continue}if(a=a+m*(g-a),h){const c=e[o-1],d=o>1?e[o-2]:c;Number.isFinite(c)&&(a=Math.min(a,c)),Number.isFinite(d)&&(a=Math.min(a,d)),l<a?(h=!1,a=g,g=l,m=s):f>g&&(g=f,m=Math.min(m+i,r))}else{const c=n[o-1],d=o>1?n[o-2]:c;Number.isFinite(c)&&(a=Math.max(a,c)),Number.isFinite(d)&&(a=Math.max(a,d)),f>a?(h=!0,a=g,g=f,m=s):l<g&&(g=l,m=Math.min(m+i,r))}t[o]=a}return t}function Vs(n,e){const s=n.length,i=new Float32Array(s);for(let r=0;r<s;r++){if(r<e-1){i[r]=NaN;continue}let u=0,t=0,h=!0;for(let m=0;m<e;m++){const g=n[r-m];if(!Number.isFinite(g)){h=!1;break}const a=m+1;u+=g,t+=g*a}if(!h||u===0){i[r]=NaN;continue}i[r]=-(t/u)+(e+1)/2}return i}function Ts(n,e,s,i,r,u){const t=ye(n,i),h=_e(e,i),m=s.length,g=new Float32Array(m);for(let l=0;l<m;l++){const c=s[l],d=t[l],N=h[l],v=d-N;g[l]=Number.isFinite(c)&&Number.isFinite(d)&&Number.isFinite(N)&&v!==0?(c-N)/v*100:NaN}const a=z(g,r),o=z(a,u),f=new Float32Array(m);for(let l=0;l<m;l++){const c=a[l],d=o[l];f[l]=Number.isFinite(c)&&Number.isFinite(d)?3*c-2*d:NaN}return{k:a,d:o,j:f}}function Bs(n,e,s,i,r,u,t,h,m,g){const a=Se(n,e),o=Se(n,s),f=Se(n,i),l=Se(n,r),c=z(a,u),d=z(o,t),N=z(f,h),v=z(l,m),p=n.length,S=new Float32Array(p);for(let b=0;b<p;b++){const M=c[b],F=d[b],A=N[b],_=v[b];S[b]=Number.isFinite(M)&&Number.isFinite(F)&&Number.isFinite(A)&&Number.isFinite(_)?M+2*F+3*A+4*_:NaN}const w=z(S,g);return{kst:S,signal:w}}function Ks(n,e,s,i,r,u){const t=s.length,h=new Float32Array(t),m=new Float32Array(t);let g=NaN;for(let v=0;v<t;v++){const p=n[v],S=e[v],w=s[v];if(!Number.isFinite(p)||!Number.isFinite(S)||!Number.isFinite(w)){h[v]=NaN,m[v]=NaN,g=w;continue}const b=Math.min(S,Number.isFinite(g)?g:S),M=Math.max(p,Number.isFinite(g)?g:p);h[v]=w-b,m[v]=M-b,g=w}const a=H(h,i),o=H(h,r),f=H(h,u),l=H(m,i),c=H(m,r),d=H(m,u),N=new Float32Array(t);for(let v=0;v<t;v++){const p=a[v],S=o[v],w=f[v],b=l[v],M=c[v],F=d[v];if(!Number.isFinite(p)||!Number.isFinite(S)||!Number.isFinite(w)||!Number.isFinite(b)||!Number.isFinite(M)||!Number.isFinite(F)||b===0||M===0||F===0){N[v]=NaN;continue}const A=p/b,_=S/M,y=w/F;N[v]=100*(4*A+2*_+y)/7}return N}function zs(n,e,s){const i=z(n,e),r=mn(n,e),u=n.length,t=new Float32Array(u);for(let h=0;h<u;h++){const m=i[h],g=r[h];t[h]=Number.isFinite(m)&&Number.isFinite(g)&&m!==0?2*s*g/m:NaN}return t}function Gs(n,e,s){const i=n.length,r=new Float32Array(i);let u=s;r[0]=u;for(let t=1;t<i;t++){const h=n[t],m=n[t-1],g=e[t],a=e[t-1];if(!Number.isFinite(h)||!Number.isFinite(m)||!Number.isFinite(g)||!Number.isFinite(a)||m===0){r[t]=u;continue}g>a&&(u=u+(h-m)/m*u),r[t]=u}return r}function Hs(n,e,s){const i=n.length,r=new Float32Array(i);let u=s;r[0]=u;for(let t=1;t<i;t++){const h=n[t],m=n[t-1],g=e[t],a=e[t-1];if(!Number.isFinite(h)||!Number.isFinite(m)||!Number.isFinite(g)||!Number.isFinite(a)||m===0){r[t]=u;continue}g<a&&(u=u+(h-m)/m*u),r[t]=u}return r}function Ws(n,e,s,i){const r=s.length,u=new Float32Array(r),t=new Float32Array(r);for(let l=0;l<r;l++){if(l===0){u[l]=NaN,t[l]=NaN;continue}const c=n[l],d=e[l],N=n[l-1],v=e[l-1];u[l]=Number.isFinite(c)&&Number.isFinite(v)?Math.abs(c-v):NaN,t[l]=Number.isFinite(d)&&Number.isFinite(N)?Math.abs(d-N):NaN}const h=hn(n,e,s),m=H(u,i),g=H(t,i),a=H(h,i),o=new Float32Array(r),f=new Float32Array(r);for(let l=0;l<r;l++){const c=m[l],d=g[l],N=a[l];o[l]=Number.isFinite(c)&&Number.isFinite(N)&&N!==0?c/N:NaN,f[l]=Number.isFinite(d)&&Number.isFinite(N)&&N!==0?d/N:NaN}return{plus:o,minus:f}}function ye(n,e){const s=n.length,i=new Float32Array(s);for(let r=0;r<s;r++){let u=-1/0,t=!1;const h=Math.max(0,r-e+1);for(let m=h;m<=r;m++){const g=n[m];Number.isFinite(g)&&(t=!0,g>u&&(u=g))}i[r]=t?u:NaN}return i}function _e(n,e){const s=n.length,i=new Float32Array(s);for(let r=0;r<s;r++){let u=1/0,t=!1;const h=Math.max(0,r-e+1);for(let m=h;m<=r;m++){const g=n[m];Number.isFinite(g)&&(t=!0,g<u&&(u=g))}i[r]=t?u:NaN}return i}function Ft(n,e){const s=n.length,i=new Float32Array(s);for(let r=0;r<s;r++){if(r<e-1){i[r]=NaN;continue}let u=-1/0,t=NaN;for(let h=0;h<e;h++){const m=r-h,g=n[m];Number.isFinite(g)&&g>u&&(u=g,t=h)}i[r]=Number.isFinite(t)?t:NaN}return i}function yt(n,e){const s=n.length,i=new Float32Array(s);for(let r=0;r<s;r++){if(r<e-1){i[r]=NaN;continue}let u=1/0,t=NaN;for(let h=0;h<e;h++){const m=r-h,g=n[m];Number.isFinite(g)&&g<u&&(u=g,t=h)}i[r]=Number.isFinite(t)?t:NaN}return i}function Ys(n,e){const s=n.length,i=new Float32Array(s);for(let r=0;r<s;r++){if(r<e-1){i[r]=NaN;continue}let u=0,t=0,h=0;const m=r-e+1;for(let o=m;o<=r;o++){const f=n[o];Number.isFinite(f)&&(u+=f,t+=f*f,h+=1)}if(h<2){i[r]=NaN;continue}const g=u/h,a=t/h-g*g;i[r]=Number.isFinite(a)?a:NaN}return i}function Xs(n,e,s){const i=n.length,r=new Float32Array(i);for(let u=0;u<i;u++){if(u<s-1){r[u]=NaN;continue}let t=0,h=0,m=0,g=0,a=0,o=0;const f=u-s+1;for(let S=f;S<=u;S++){const w=n[S],b=e[S];!Number.isFinite(w)||!Number.isFinite(b)||(t+=w,h+=b,m+=w*w,g+=b*b,a+=w*b,o+=1)}if(o<2){r[u]=NaN;continue}const l=t/o,c=h/o,d=a/o-l*c,N=m/o-l*l,v=g/o-c*c,p=Math.sqrt(N*v);r[u]=p>0?d/p:NaN}return r}function Zs(n,e,s){const i=n.length,r=new Float32Array(i),u=Math.max(1,Math.floor(e)),t=Math.floor(s),h=(u-1)*u/2,m=(u-1)*u*(2*u-1)/6,g=u*m-h*h;for(let a=0;a<i;a++){if(a<u-1||g===0){r[a]=NaN;continue}let o=0,f=0,l=0;for(let v=0;v<u;v++){const p=a-(u-1-v),S=n[p];Number.isFinite(S)&&(o+=S,f+=S*v,l+=1)}if(l<2){r[a]=NaN;continue}const c=(u*f-h*o)/g,d=(o-c*h)/u,N=u-1+t;r[a]=d+c*N}return r}function _t(n,e){var g;const s=e.funcRuntime;if(s){const a=s.funcs.get(n.callee.toLowerCase());if(a){const o=e.length,f=new Float32Array(o),l={series:e.series,scalars:e.scalars,strings:e.strings,diagnostics:e.diagnostics,draw:e.draw,strategy:e.strategy,loopRuntime:e.loopRuntime,funcRuntime:e.funcRuntime,length:o,index:0};for(let c=0;c<o;c++)l.index=c,f[c]=It(a,n,l);return{kind:"series",value:f}}}const i=((g=e.scalars)==null?void 0:g.__pinev2)===1,r=Rt(n.callee.toLowerCase(),i),u=Lt(r);if(u){if(!e.draw)return{kind:"scalar",value:NaN};const a=n.args[0];let o="";if(a&&a.kind==="Identifier"&&(o=a.name),a&&a.kind==="StringLiteral"&&(o=a.value),!o)return{kind:"scalar",value:NaN};const f=e.length,l=new Float32Array(f);for(let c=0;c<f;c++){const d=e.draw.get(u.kind,u.prop,o,c);typeof d=="string"?l[c]=Q(d):typeof d=="number"&&Number.isFinite(d)?l[c]=d:l[c]=NaN}return{kind:"series",value:l}}const t=n.args.map(a=>ne(a,e)),h=Ct(r);if(h){if(!e.strategy)return{kind:"scalar",value:NaN};if(!t.length)throw new k(`${n.callee} expects (index)`);const a=L(t[0],e),o=e.length,f=new Float32Array(o);for(let l=0;l<o;l++){const c=a[l],d=Number.isFinite(c)?Math.floor(c):NaN;if(!Number.isFinite(d)){f[l]=NaN;continue}f[l]=jt(e,h.kind,h.prop,l,d)}return{kind:"series",value:f}}const m=()=>{if(t.length!==2)throw new k(`${r} expects (series, period)`);const a=L(t[0],e),o=Math.max(1,Math.floor(j(t[1])));return[a,o]};switch(r){case"__hist_index":case"__arr_index":{if(t.length!==1)throw new k(`${n.callee} expects (index)`);const a=t[0];if(!i)return a;const o=r==="__hist_index"?"history_index":"array_index",f=r==="__hist_index"?$e:Gn;if(a.kind==="scalar")return{kind:"scalar",value:ce(a.value,o,f,e)};const l=L(a,e),c=new Float32Array(e.length);for(let d=0;d<c.length;d++)c[d]=ce(l[d],o,f,e);return{kind:"series",value:c}}case"__arr_index_str":{if(t.length!==1)throw new k(`${n.callee} expects (index)`);const a=t[0];if(!i)return a;const o=`arr_idx_str:${q(n)}`;if(a.kind==="scalar")return{kind:"scalar",value:qe(a.value,o,e)};const f=L(a,e),l=new Float32Array(e.length);for(let c=0;c<l.length;c++)l[c]=qe(f[c],o,e);return{kind:"series",value:l}}case"__arr_set_guard":{if(t.length!==2)throw new k(`${n.callee} expects (index, size)`);if(!i)return{kind:"scalar",value:1};const a=t[0],o=t[1],f=`arr_set_guard:${q(n)}`;if(a.kind==="scalar"&&o.kind==="scalar")return{kind:"scalar",value:fn(a.value,o.value,f,e)};const l=L(a,e),c=L(o,e),d=new Float32Array(e.length);for(let N=0;N<d.length;N++)d[N]=fn(l[N],c[N],f,e);return{kind:"series",value:d}}case"__arr_str_valid":{if(t.length!==1)throw new k(`${n.callee} expects (value)`);if(!i)return{kind:"scalar",value:1};const a=le(n.args[0]);return a||O(e,`arr_str_val:${q(n)}`,Hn),{kind:"scalar",value:a?1:0}}case"__str_num":{if(t.length!==1)throw new k(`${n.callee} expects (value)`);return t[0]}case"iff":case"iif":case"if":{if(t.length!==3)throw new k(`${n.callee} expects (cond, a, b)`);const a=t[0],o=t[1],f=t[2],l=n.args[0];if(i){const A=ke(n.args[1]),_=ke(n.args[2]);if(A!==_){if(O(e,"ternary_type",zn),a.kind==="scalar"&&o.kind==="scalar"&&f.kind==="scalar")return{kind:"scalar",value:NaN};const y=new Float32Array(e.length);return y.fill(NaN),{kind:"series",value:y}}}const c=i&&le(l),d=i?ue(l,e,"na"):void 0;c&&O(e,ue(l,e,"type"),De);const N=a.kind==="series",v=o.kind==="series",p=f.kind==="series";if(!N&&!v&&!p){const A=a.value;return c?{kind:"scalar",value:f.value}:{kind:"scalar",value:cn(A,e,d)?o.value:f.value}}const S=L(a,e),w=L(o,e),b=L(f,e),M=e.length,F=new Float32Array(M);for(let A=0;A<M;A++){if(c){F[A]=b[A];continue}const _=S[A],y=cn(_,e,d);F[A]=y?w[A]:b[A]}return{kind:"series",value:F}}case"nz":{if(t.length<1||t.length>2)throw new k("nz expects (series[, fallback])");const a=t[0],o=t[1]??{kind:"scalar",value:0};if(a.kind==="scalar"&&o.kind==="scalar")return{kind:"scalar",value:Number.isFinite(a.value)?a.value:o.value};const f=L(a,e),l=L(o,e),c=e.length,d=new Float32Array(c);for(let N=0;N<c;N++){const v=f[N];d[N]=Number.isFinite(v)?v:l[N]}return{kind:"series",value:d}}case"between":{if(t.length!==3)throw new k("between expects (x, a, b)");const a=L(t[0],e),o=L(t[1],e),f=L(t[2],e),l=e.length,c=new Float32Array(l);for(let d=0;d<l;d++){const N=a[d],v=o[d],p=f[d];if(!Number.isFinite(N)||!Number.isFinite(v)||!Number.isFinite(p)){c[d]=i?NaN:0;continue}const S=Math.min(v,p),w=Math.max(v,p);c[d]=N>=S&&N<=w?1:0}return{kind:"series",value:c}}case"above":case"below":{if(t.length<2||t.length>3)throw new k(`${r} expects (a, b[, tol])`);const a=L(t[0],e),o=L(t[1],e),f=t[2]?L(t[2],e):null,l=e.length,c=new Float32Array(l);for(let d=0;d<l;d++){const N=a[d],v=o[d],p=f?f[d]:0,S=Number.isFinite(p)?Math.max(0,p):0;if(!Number.isFinite(N)||!Number.isFinite(v)){c[d]=i?NaN:0;continue}c[d]=r==="above"?N>v+S?1:0:N<v-S?1:0}return{kind:"series",value:c}}case"higherhigh":{const a=t.length?Math.max(1,Math.floor(j(t[0]))):1,o=e.series.high;if(!o)throw new k("higherhigh requires high series");const f=e.length,l=new Float32Array(f);for(let c=0;c<f;c++){const d=o[c];if(!Number.isFinite(d)){l[c]=i?NaN:0;continue}const N=Math.max(0,c-a),v=In(o,N,Math.max(0,c-1));l[c]=d>v?1:0}return{kind:"series",value:l}}case"lowerlow":{const a=t.length?Math.max(1,Math.floor(j(t[0]))):1,o=e.series.low;if(!o)throw new k("lowerlow requires low series");const f=e.length,l=new Float32Array(f);for(let c=0;c<f;c++){const d=o[c];if(!Number.isFinite(d)){l[c]=i?NaN:0;continue}const N=Math.max(0,c-a),v=Ln(o,N,Math.max(0,c-1));l[c]=d<v?1:0}return{kind:"series",value:l}}case"swinghigh":{const a=t.length?Math.max(1,Math.floor(j(t[0]))):3,o=e.series.high;if(!o)throw new k("swinghigh requires high series");const f=e.length,l=new Float32Array(f);for(let c=0;c<f;c++){const d=o[c];if(!Number.isFinite(d)){l[c]=i?NaN:0;continue}let N=!0;for(let v=c-a;v<=c+a;v++){if(v===c||v<0||v>=f)continue;const p=o[v];if(Number.isFinite(p)&&p>=d){N=!1;break}}l[c]=N?1:0}return{kind:"series",value:l}}case"swinglow":{const a=t.length?Math.max(1,Math.floor(j(t[0]))):3,o=e.series.low;if(!o)throw new k("swinglow requires low series");const f=e.length,l=new Float32Array(f);for(let c=0;c<f;c++){const d=o[c];if(!Number.isFinite(d)){l[c]=i?NaN:0;continue}let N=!0;for(let v=c-a;v<=c+a;v++){if(v===c||v<0||v>=f)continue;const p=o[v];if(Number.isFinite(p)&&p<=d){N=!1;break}}l[c]=N?1:0}return{kind:"series",value:l}}case"volspike":{const a=t.length?Math.max(1,j(t[0])):1,o=e.series.volume;if(!o)throw new k("volspike requires volume series");const f=e.length,l=new Float32Array(f),c=20;for(let d=0;d<f;d++){const N=o[d];if(!Number.isFinite(N)){l[d]=i?NaN:0;continue}const v=Math.max(0,d-c+1);let p=0,S=0;for(let b=v;b<=d;b++){const M=o[b];Number.isFinite(M)&&(p+=M,S+=1)}const w=S?p/S:NaN;l[d]=Number.isFinite(w)&&N>a*w?1:0}return{kind:"series",value:l}}case"atrspike":{const a=t.length?Math.max(1,j(t[0])):1,o=e.series.high,f=e.series.low,l=e.series.close;if(!o||!f||!l)throw new k("atrspike requires high/low/close series");const c=e.length,d=new Float32Array(c),N=14,v=p=>{const S=o[p],w=f[p],b=p>0?l[p-1]:NaN;let M=Number.isFinite(S)&&Number.isFinite(w)?Math.max(0,S-w):NaN;return Number.isFinite(b)&&(M=Math.max(M,Math.abs(S-b),Math.abs(w-b))),M};for(let p=0;p<c;p++){let S=NaN,w=0;for(let A=0;A<=p;A++){const _=v(A);w+=Number.isFinite(_)?_:0,A===N-1?S=w/N:A>=N&&(S=(S*(N-1)+_)/N)}let b=NaN,M=0,F=0;for(let A=Math.max(0,p-N+1);A<=p;A++){const _=v(A);Number.isFinite(_)&&(M+=_,F+=1)}F&&(b=M/F),d[p]=Number.isFinite(S)&&Number.isFinite(b)&&S>a*b?1:0}return{kind:"series",value:d}}case"trend":{const a=n.args[0],o=a&&a.kind==="StringLiteral"?a.value:a&&a.kind==="Identifier"?a.name:"",f=String(o||"").toLowerCase()||"up",l=e.series.close;if(!l)throw new k("trend requires close series");const c=e.length,d=new Float32Array(c),N=10;for(let v=0;v<c;v++){const p=Math.max(0,v-N+1);let S=0,w=0,b=0,M=0,F=0;for(let y=p;y<=v;y++){const $=y-p,I=l[y];Number.isFinite(I)&&(S+=$,w+=I,b+=$*$,M+=$*I,F+=1)}const A=F*b-S*S,_=A===0||F===0?0:(F*M-S*w)/A;d[v]=f==="up"?_>0?1:0:_<0?1:0}return{kind:"series",value:d}}case"add":case"sub":case"mul":case"div":{if(t.length!==2)throw new k(`${r} expects 2 arguments`);const a=t[0],o=t[1];if(a.kind==="scalar"&&o.kind==="scalar"){const N=a.value,v=o.value;return r==="add"?{kind:"scalar",value:N+v}:r==="sub"?{kind:"scalar",value:N-v}:r==="mul"?{kind:"scalar",value:N*v}:{kind:"scalar",value:ve(N,v,i,e)}}const f=L(a,e),l=L(o,e),c=e.length,d=new Float32Array(c);for(let N=0;N<c;N++){const v=f[N],p=l[N];r==="add"?d[N]=v+p:r==="sub"?d[N]=v-p:r==="mul"?d[N]=v*p:d[N]=ve(v,p,i,e)}return{kind:"series",value:d}}case"mod":case"fmod":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length!==2)throw new k(`${n.callee} expects 2 arguments`);const a=t[0],o=t[1],f=r==="mod"?ct:at;if(a.kind==="scalar"&&o.kind==="scalar")return{kind:"scalar",value:f(a.value,o.value,!0,e)};const l=L(a,e),c=L(o,e);return{kind:"series",value:Ue(l,c,(d,N)=>f(d,N,!0,e))}}case"pow":{if(t.length!==2)throw new k("pow expects 2 arguments");const a=t[0],o=t[1];if(a.kind==="scalar"&&o.kind==="scalar")return{kind:"scalar",value:un(a.value,o.value,i,e)};const f=L(a,e),l=L(o,e);return{kind:"series",value:Ue(f,l,(c,d)=>un(c,d,i,e))}}case"sqrt":case"log":case"ln":case"log10":case"exp":case"floor":case"ceil":case"round":case"sin":case"cos":case"tan":case"asin":case"acos":case"atan":case"sign":{if(t.length!==1)throw new k(`${r} expects 1 argument`);const a=r==="sqrt"?f=>lt(f,i,e):r==="log"||r==="ln"?f=>ut(f,i,e):r==="log10"?f=>ft(f,i,e):r==="exp"?f=>gt(f,i):r==="floor"?Math.floor:r==="ceil"?Math.ceil:r==="round"?Math.round:r==="sin"?Math.sin:r==="cos"?Math.cos:r==="tan"?f=>dt(f,i):r==="asin"?f=>ht(f,i,e):r==="acos"?f=>mt(f,i,e):r==="atan"?Math.atan:Math.sign,o=t[0];return o.kind==="scalar"?{kind:"scalar",value:a(o.value)}:{kind:"series",value:Ae(L(o,e),a)}}case"todegrees":case"toradians":{if(t.length!==1)throw new k(`${r} expects 1 argument`);const a=t[0],o=r==="todegrees"?180/Math.PI:Math.PI/180;return a.kind==="scalar"?{kind:"scalar",value:a.value*o}:{kind:"series",value:Ae(L(a,e),f=>f*o)}}case"atan2":{if(t.length!==2)throw new k("atan2 expects (y, x)");const a=t[0],o=t[1];if(a.kind==="scalar"&&o.kind==="scalar")return{kind:"scalar",value:Math.atan2(a.value,o.value)};const f=L(a,e),l=L(o,e);return{kind:"series",value:Ue(f,l,(c,d)=>Math.atan2(c,d))}}case"avg":{if(t.length!==2)throw new k("avg expects (a, b)");const a=t[0],o=t[1];if(a.kind==="scalar"&&o.kind==="scalar")return{kind:"scalar",value:(a.value+o.value)/2};const f=L(a,e),l=L(o,e);return{kind:"series",value:Ue(f,l,(c,d)=>(c+d)/2)}}case"clamp":{if(t.length!==3)throw new k("clamp expects (x, min, max)");const a=t[0],o=t[1],f=t[2],l=(S,w,b)=>Math.min(b,Math.max(w,S));if(a.kind==="scalar"&&o.kind==="scalar"&&f.kind==="scalar")return{kind:"scalar",value:l(a.value,o.value,f.value)};const c=L(a,e),d=L(o,e),N=L(f,e),v=e.length,p=new Float32Array(v);for(let S=0;S<v;S++)p[S]=l(c[S],d[S],N[S]);return{kind:"series",value:p}}case"cum":case"cumsum":{if(t.length!==1)throw new k(`${r} expects 1 argument`);const a=L(t[0],e),o=e.length,f=new Float32Array(o);let l=0;for(let c=0;c<o;c++){const d=a[c];Number.isFinite(d)&&(l+=d),f[c]=l}return{kind:"series",value:f}}case"barssince":{if(t.length!==1)throw new k("barssince expects (condition)");const a=L(t[0],e),o=e.length,f=new Float32Array(o);let l=NaN;for(let c=0;c<o;c++){const d=a[c];Number.isFinite(d)&&d!==0?(l=0,f[c]=0):Number.isFinite(l)?(l+=1,f[c]=l):f[c]=NaN}return{kind:"series",value:f}}case"sma":{const[a,o]=m();return{kind:"series",value:z(a,o)}}case"wma":{const[a,o]=m();return{kind:"series",value:Ve(a,o)}}case"ema":{const[a,o]=m();return{kind:"series",value:B(a,o)}}case"smma":{const[a,o]=m();return{kind:"series",value:Fe(a,o)}}case"rsi":{const[a,o]=m();return{kind:"series",value:kt(a,o)}}case"rma":{const[a,o]=m();return{kind:"series",value:Fe(a,o)}}case"dema":{const[a,o]=m();return{kind:"series",value:bs(a,o)}}case"tema":{const[a,o]=m();return{kind:"series",value:ps(a,o)}}case"trima":{const[a,o]=m();return{kind:"series",value:vs(a,o)}}case"swma":{const[a,o]=m();return{kind:"series",value:ks(a,o)}}case"hma":{const[a,o]=m();return{kind:"series",value:Fs(a,o)}}case"kama":{if(t.length<2||t.length>4)throw new k("kama expects (series, period[, fast, slow])");const a=L(t[0],e),o=Math.max(1,Math.floor(j(t[1]))),f=t[2]?Math.max(1,Math.floor(j(t[2]))):2,l=t[3]?Math.max(1,Math.floor(j(t[3]))):30;return{kind:"series",value:ys(a,o,f,l)}}case"alma":{if(t.length<2||t.length>4)throw new k("alma expects (series, period[, offset, sigma])");const a=L(t[0],e),o=Math.max(1,Math.floor(j(t[1]))),f=t[2]?j(t[2]):.85,l=t[3]?Math.max(.1,j(t[3])):6;return{kind:"series",value:_s(a,o,f,l)}}case"t3":{if(t.length<2||t.length>3)throw new k("t3 expects (series, period[, factor])");const a=L(t[0],e),o=Math.max(1,Math.floor(j(t[1]))),f=t[2]?j(t[2]):.7;return{kind:"series",value:Ms(a,o,f)}}case"cmo":{const[a,o]=m();return{kind:"series",value:As(a,o)}}case"tsi":{if(t.length!==3)throw new k("tsi expects (series, long, short)");const a=L(t[0],e),o=Math.max(1,Math.floor(j(t[1]))),f=Math.max(1,Math.floor(j(t[2])));return{kind:"series",value:$s(a,o,f)}}case"stochrsi":{if(t.length<2||t.length>4)throw new k("stochrsi expects (series, length[, smoothK, smoothD])");const a=L(t[0],e),o=Math.max(1,Math.floor(j(t[1]))),f=t[2]?Math.max(1,Math.floor(j(t[2]))):0,l=t[3]?Math.max(1,Math.floor(j(t[3]))):0;return{kind:"series",value:Es(a,o,f||void 0,l||void 0)}}case"ppo":{if(t.length!==3)throw new k("ppo expects (series, fast, slow)");const a=L(t[0],e),o=Math.max(1,Math.floor(j(t[1]))),f=Math.max(1,Math.floor(j(t[2])));return{kind:"series",value:Is(a,o,f)}}case"cog":{if(t.length!==1&&t.length!==2)throw new k("cog expects (length) or (series, length)");const a=t.length===1?e.series.close:L(t[0],e);if(!a)throw new k("cog requires a source series");const o=Math.max(1,Math.floor(j(t[t.length===1?0:1])));return{kind:"series",value:X(e,`cog:${o}:${q(n)}`,()=>Vs(a,o))}}case"bbw":{if(t.length!==2&&t.length!==3)throw new k("bbw expects (length, mult) or (series, length, mult)");const a=t.length===2?e.series.close:L(t[0],e);if(!a)throw new k("bbw requires a source series");const o=Math.max(1,Math.floor(j(t[t.length===2?0:1]))),f=j(t[t.length===2?1:2]);return{kind:"series",value:X(e,`bbw:${o}:${q(n)}`,()=>zs(a,o,f))}}case"uo":{if(t.length!==3&&t.length!==6)throw new k("uo expects (len1, len2, len3) or (high, low, close, len1, len2, len3)");const a=t.length===6?L(t[0],e):e.series.high,o=t.length===6?L(t[1],e):e.series.low,f=t.length===6?L(t[2],e):e.series.close;if(!a||!o||!f)throw new k("uo requires high/low/close series");const l=Math.max(1,Math.floor(j(t[t.length===6?3:0]))),c=Math.max(1,Math.floor(j(t[t.length===6?4:1]))),d=Math.max(1,Math.floor(j(t[t.length===6?5:2])));return{kind:"series",value:X(e,`uo:${l}:${c}:${d}:${q(n)}`,()=>Ks(a,o,f,l,c,d))}}case"pvi":case"nvi":{if(t.length!==0&&t.length!==2&&t.length!==3)throw new k(`${n.callee} expects () or (close, volume[, start])`);const a=t.length?L(t[0],e):e.series.close,o=t.length?L(t[1],e):e.series.volume,f=t.length===3?j(t[2]):1e3;if(!a||!o)throw new k(`${n.callee} requires close/volume series`);const l=`${r}:${q(n)}`;return{kind:"series",value:X(e,l,()=>r==="pvi"?Gs(a,o,f):Hs(a,o,f))}}case"kdj":{const a=t.length===6||t.length===7,o=t.length===3||t.length===4;if(!a&&!o)throw new k("kdj expects (len, smoothK, smoothD[, output]) or (high, low, close, len, smoothK, smoothD[, output])");const f=a,l=f?L(t[0],e):e.series.high,c=f?L(t[1],e):e.series.low,d=f?L(t[2],e):e.series.close;if(!l||!c||!d)throw new k("kdj requires high/low/close series");const N=f?3:0,v=Math.max(1,Math.floor(j(t[N+0]))),p=Math.max(1,Math.floor(j(t[N+1]))),S=Math.max(1,Math.floor(j(t[N+2]))),w=t[N+3]?Math.floor(j(t[N+3])):0;if(!Number.isFinite(w)||w<0||w>2)throw new k("kdj output must be 0, 1, or 2");const b=`kdj:${v}:${p}:${S}:${q(n)}`,M=Ke(e,b,()=>{const A=Ts(l,c,d,v,p,S);return{a:A.k,b:A.d,c:A.j}});return{kind:"series",value:w===0?M.a:w===1?M.b:M.c}}case"kst":{if(t.length<9||t.length>11)throw new k("kst expects (src, r1, r2, r3, r4, n1, n2, n3, n4[, signal, output])");const a=L(t[0],e),o=Math.max(1,Math.floor(j(t[1]))),f=Math.max(1,Math.floor(j(t[2]))),l=Math.max(1,Math.floor(j(t[3]))),c=Math.max(1,Math.floor(j(t[4]))),d=Math.max(1,Math.floor(j(t[5]))),N=Math.max(1,Math.floor(j(t[6]))),v=Math.max(1,Math.floor(j(t[7]))),p=Math.max(1,Math.floor(j(t[8]))),S=t[9]?Math.max(1,Math.floor(j(t[9]))):9,w=t[10]?Math.floor(j(t[10])):0;if(!Number.isFinite(w)||w<0||w>1)throw new k("kst output must be 0 or 1");const b=`kst:${o}:${f}:${l}:${c}:${d}:${N}:${v}:${p}:${S}:${q(n)}`,M=Be(e,b,()=>{const F=Bs(a,o,f,l,c,d,N,v,p,S);return{a:F.kst,b:F.signal}});return{kind:"series",value:w===0?M.a:M.b}}case"vortex":{const a=t.length===4||t.length===5,o=t.length===1||t.length===2;if(!a&&!o)throw new k("vortex expects (length[, output]) or (high, low, close, length[, output])");const f=a,l=f?L(t[0],e):e.series.high,c=f?L(t[1],e):e.series.low,d=f?L(t[2],e):e.series.close;if(!l||!c||!d)throw new k("vortex requires high/low/close series");const N=f?3:0,v=Math.max(1,Math.floor(j(t[N]))),p=t[N+1]?Math.floor(j(t[N+1])):0;if(!Number.isFinite(p)||p<0||p>1)throw new k("vortex output must be 0 or 1");const S=`vortex:${v}:${q(n)}`,w=Be(e,S,()=>{const b=Ws(l,c,d,v);return{a:b.plus,b:b.minus}});return{kind:"series",value:p===0?w.a:w.b}}case"linreg":{if(t.length<2||t.length>3)throw new k("linreg expects (series, period[, offset])");const a=L(t[0],e),o=Math.max(1,Math.floor(j(t[1]))),f=t[2]?Math.floor(j(t[2])):0;return{kind:"series",value:Zs(a,o,f)}}case"tr":case"trange":case"true_range":{if(t.length!==0&&t.length!==3)throw new k("tr expects () or (high, low, close)");const a=t.length===3?L(t[0],e):e.series.high,o=t.length===3?L(t[1],e):e.series.low,f=t.length===3?L(t[2],e):e.series.close;if(!a||!o||!f)throw new k("tr requires high/low/close series");const l=e.length,c=new Float32Array(l);let d=NaN;for(let N=0;N<l;N++){const v=a[N],p=o[N],S=f[N];let w=Math.max(0,v-p);Number.isFinite(d)&&(w=Math.max(w,Math.abs(v-d),Math.abs(p-d))),c[N]=w,d=S}return{kind:"series",value:c}}case"atr":{if(t.length!==1&&t.length!==4)throw new k("atr expects (length) or (high, low, close, length)");const a=j(t[t.length===1?0:3]),o=i?V(a,`atr_len:${q(n)}`,fs,e):Math.max(1,Math.floor(a));if(!Number.isFinite(o))return{kind:"series",value:W(e.length)};const f=t.length===1?e.series.high:L(t[0],e),l=t.length===1?e.series.low:L(t[1],e),c=t.length===1?e.series.close:L(t[2],e);if(!f||!l||!c)throw new k("atr requires high/low/close series");const d=e.length,N=hn(f,l,c),v=new Float32Array(d);let p=0;for(let S=0;S<d;S++)p+=N[S],S===o-1?v[S]=p/o:S>=o?v[S]=(v[S-1]*(o-1)+N[S])/o:v[S]=NaN;return{kind:"series",value:v}}case"atrp":case"natr":{if(t.length!==1&&t.length!==4)throw new k(`${n.callee} expects (length) or (high, low, close, length)`);const a=j(t[t.length===1?0:3]),o=Math.max(1,Math.floor(a));if(!Number.isFinite(o))return{kind:"series",value:W(e.length)};const f=t.length===1?e.series.high:L(t[0],e),l=t.length===1?e.series.low:L(t[1],e),c=t.length===1?e.series.close:L(t[2],e);if(!f||!l||!c)throw new k(`${n.callee} requires high/low/close series`);return{kind:"series",value:Ss(f,l,c,o)}}case"stdev":case"stddev":case"dev":{const[a,o]=m();return{kind:"series",value:mn(a,o)}}case"variance":case"var":{const[a,o]=m();return{kind:"series",value:Ys(a,o)}}case"zscore":{const[a,o]=m();return{kind:"series",value:Rs(a,o)}}case"correlation":case"corr":{if(t.length!==3)throw new k(`${n.callee} expects (a, b, period)`);const a=L(t[0],e),o=L(t[1],e),f=Math.max(1,Math.floor(j(t[2])));return{kind:"series",value:Xs(a,o,f)}}case"highest":{if(!i){const[l,c]=m();return{kind:"series",value:ye(l,c)}}if(t.length!==2)throw new k("highest expects (series, period)");const a=L(t[0],e),o=j(t[1]),f=V(o,`highest_len:${q(n)}`,tt,e);return Number.isFinite(f)?{kind:"series",value:ye(a,f)}:{kind:"series",value:W(e.length)}}case"highestbars":{const[a,o]=m();return{kind:"series",value:Ft(a,o)}}case"lowest":{if(!i){const[l,c]=m();return{kind:"series",value:_e(l,c)}}if(t.length!==2)throw new k("lowest expects (series, period)");const a=L(t[0],e),o=j(t[1]),f=V(o,`lowest_len:${q(n)}`,st,e);return Number.isFinite(f)?{kind:"series",value:_e(a,f)}:{kind:"series",value:W(e.length)}}case"lowestbars":{const[a,o]=m();return{kind:"series",value:yt(a,o)}}case"sum":{if(!i){const[l,c]=m();return{kind:"series",value:H(l,c)}}if(t.length!==2)throw new k("sum expects (series, period)");const a=L(t[0],e),o=j(t[1]),f=V(o,`sum_len:${q(n)}`,it,e);if(!Number.isFinite(f)){const l=new Float32Array(e.length);return l.fill(NaN),{kind:"series",value:l}}return{kind:"series",value:H(a,f)}}case"rising":case"falling":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length!==2)throw new k(`${n.callee} expects (series, length)`);const a=L(t[0],e),o=j(t[1]),f=`${r}_len:${q(n)}`,c=V(o,f,r==="rising"?rt:ot,e);if(!Number.isFinite(c)){const d=new Float32Array(e.length);return d.fill(NaN),{kind:"series",value:d}}return{kind:"series",value:En(a,c,r)}}case"lag":{if(t.length!==2)throw new k("lag expects (series, n)");const a=L(t[0],e),o=j(t[1]);if(i){const l=ce(o,"history_index",$e,e);if(!Number.isFinite(l)){const c=new Float32Array(e.length);return c.fill(NaN),{kind:"series",value:c}}return{kind:"series",value:Ye(a,l)}}const f=Math.max(1,Math.floor(o));return{kind:"series",value:Ye(a,f)}}case"prev":{if(t.length<1||t.length>2)throw new k("prev expects (series[, n])");const a=L(t[0],e),o=j(t[1]??{kind:"scalar",value:1});if(i){const l=ce(o,"history_index",$e,e);if(!Number.isFinite(l)){const c=new Float32Array(e.length);return c.fill(NaN),{kind:"series",value:c}}return{kind:"series",value:Ye(a,l)}}const f=Math.max(1,Math.floor(o));return{kind:"series",value:Ye(a,f)}}case"change":{if(t.length<1||t.length>2)throw new k("change expects (series[, n])");const a=L(t[0],e),o=Math.max(1,Math.floor(j(t[1]??{kind:"scalar",value:1})));return{kind:"series",value:Qt(a,o)}}case"roc":{if(t.length<1||t.length>2)throw new k("roc expects (series[, n])");const a=L(t[0],e),o=Math.max(1,Math.floor(j(t[1]??{kind:"scalar",value:1})));return{kind:"series",value:Se(a,o)}}case"mom":case"momentum":{if(t.length<1||t.length>2)throw new k("mom expects (series[, n])");const a=L(t[0],e),o=Math.max(1,Math.floor(j(t[1]??{kind:"scalar",value:1})));return{kind:"series",value:xt(a,o)}}case"crossover":case"crossunder":{if(t.length<2||t.length>3)throw new k(`${n.callee} expects (series, series[, tol])`);const a=L(t[0],e),o=t[1],f=o.kind==="series",l=L(o,e),c=t[2]?Math.max(0,j(t[2])):0,d=e.length,N=new Float32Array(d);N[0]=0;for(let v=1;v<d;v++){const p=a[v-1],S=a[v],w=f?l[v-1]:l[0],b=f?l[v]:l[0];if(![p,S,w,b].every(Number.isFinite)){N[v]=0;continue}r==="crossover"?N[v]=p<=w+c&&S>b+c?1:0:N[v]=p>=w-c&&S<b-c?1:0}return{kind:"series",value:N}}case"hl2":{if(t.length!==0)throw new k("hl2 expects no arguments");const a=e.series.high,o=e.series.low;if(!a||!o)throw new k("hl2 requires high/low series");const f=e.length,l=new Float32Array(f);for(let c=0;c<f;c++)l[c]=(a[c]+o[c])/2;return{kind:"series",value:l}}case"hlc3":{if(t.length!==0)throw new k("hlc3 expects no arguments");const a=e.series.high,o=e.series.low,f=e.series.close;if(!a||!o||!f)throw new k("hlc3 requires high/low/close series");const l=e.length,c=new Float32Array(l);for(let d=0;d<l;d++)c[d]=(a[d]+o[d]+f[d])/3;return{kind:"series",value:c}}case"ohlc4":{if(t.length!==0)throw new k("ohlc4 expects no arguments");const a=e.series.open,o=e.series.high,f=e.series.low,l=e.series.close;if(!a||!o||!f||!l)throw new k("ohlc4 requires open/high/low/close series");const c=e.length,d=new Float32Array(c);for(let N=0;N<c;N++)d[N]=(a[N]+o[N]+f[N]+l[N])/4;return{kind:"series",value:d}}case"vwap":{if(t.length!==0&&t.length!==2)throw new k("vwap expects () or (close, volume)");const a=t.length===0?e.series.close:L(t[0],e),o=t.length===0?e.series.volume:L(t[1],e);if(!a||!o)throw new k("vwap requires close/volume series");const f=t.length===0?e.series.high:void 0,l=t.length===0?e.series.low:void 0,c=t.length===0?e.series.time:void 0;if(t.length===0&&(!f||!l))throw new k("vwap requires high/low/close series");const d=e.length,N=new Float32Array(d);let v=0,p=0,S=Number.NaN;for(let w=0;w<d;w++){if(t.length===0&&c){const F=c[w];if(Number.isFinite(F)){const A=Math.floor(F/864e5);(!Number.isFinite(S)||A!==S)&&(v=0,p=0,S=A)}}const b=o[w],M=t.length===0?(f[w]+l[w]+a[w])/3:a[w];if(!Number.isFinite(M)||!Number.isFinite(b)){N[w]=NaN;continue}v+=M*b,p+=b,N[w]=p===0?NaN:v/p}return{kind:"series",value:N}}case"vwma":{if(t.length!==3)throw new k("vwma expects (close, volume, period)");const a=L(t[0],e),o=L(t[1],e),f=Math.max(1,Math.floor(j(t[2]))),l=e.length,c=new Float32Array(l);let d=0,N=0;for(let v=0;v<l;v++){const p=a[v],S=o[v];if(Number.isFinite(p)&&Number.isFinite(S)&&(d+=p*S,N+=S),v>=f){const w=a[v-f],b=o[v-f];Number.isFinite(w)&&Number.isFinite(b)&&(d-=w*b,N-=b)}c[v]=v>=f-1&&N!==0?d/N:NaN}return{kind:"series",value:c}}case"evwma":{if(t.length!==3)throw new k("evwma expects (close, volume, period)");const a=L(t[0],e),o=L(t[1],e),f=Math.max(1,Math.floor(j(t[2]))),l=An(Y(a),Y(o),f);return{kind:"series",value:ee(l)}}case"bbands":case"bollinger":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length<3||t.length>4)throw new k("bbands expects (series, period, mult[, output])");const a=L(t[0],e),o=Math.max(1,Math.floor(j(t[1]))),f=j(t[2]),l=t[3]?Math.floor(j(t[3])):0;if(!Number.isFinite(l)||l<0||l>2)throw new k("bbands output must be 0, 1, or 2");const c=en(Y(a),o,f),d=l===0?c.mid:l===1?c.upper:c.lower;return{kind:"series",value:ee(d)}}case"keltner":case"kc":{if(t.length<2||t.length>6)throw new k("keltner expects (period, mult[, output]) or (high, low, close, period, mult[, output])");let a,o,f,l=0,c=1,d=2;if(t.length>=5?(a=L(t[0],e),o=L(t[1],e),f=L(t[2],e),l=3,c=4,d=5):(a=e.series.high,o=e.series.low,f=e.series.close),!a||!o||!f)throw new k("keltner requires high/low/close series");const N=Math.max(1,Math.floor(j(t[l]))),v=j(t[c]),p=t[d]?Math.floor(j(t[d])):0;if(!Number.isFinite(p)||p<0||p>2)throw new k("keltner output must be 0, 1, or 2");const S=Ds(a,o,f,N,v);return{kind:"series",value:p===0?S.mid:p===1?S.upper:S.lower}}case"donchian":{if(t.length<1||t.length>4)throw new k("donchian expects (period[, output]) or (high, low, period[, output])");let a,o,f=0,l=1;if(t.length>=3?(a=L(t[0],e),o=L(t[1],e),f=2,l=3):(a=e.series.high,o=e.series.low),!a||!o)throw new k("donchian requires high/low series");const c=Math.max(1,Math.floor(j(t[f]))),d=t[l]?Math.floor(j(t[l])):0;if(!Number.isFinite(d)||d<0||d>2)throw new k("donchian output must be 0, 1, or 2");const N=Os(a,o,c);return{kind:"series",value:d===0?N.upper:d===1?N.lower:N.mid}}case"supertrend":{if(t.length<2||t.length>3)throw new k("supertrend expects (factor, period[, output])");const a=j(t[0]),o=Math.max(1,Math.floor(j(t[1]))),f=t[2]?Math.floor(j(t[2])):0;if(!Number.isFinite(f)||f<0||f>1)throw new k("supertrend output must be 0 or 1");const l=e.series.high,c=e.series.low,d=e.series.close;if(!l||!c||!d)throw new k("supertrend requires high/low/close series");const N=Us(l,c,d,o,a);return{kind:"series",value:f===0?N.line:N.dir}}case"sar":{if(t.length!==0&&t.length!==3)throw new k("sar expects () or (start, increment, maximum)");const a=t.length===3?j(t[0]):.02,o=t.length===3?j(t[1]):.02,f=t.length===3?j(t[2]):.2,l=e.series.high,c=e.series.low;if(!l||!c)throw new k("sar requires high/low series");return{kind:"series",value:qs(l,c,a,o,f)}}case"macd":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length<4||t.length>5)throw new k("macd expects (series, fast, slow, signal[, output])");const a=L(t[0],e),o=Math.max(1,Math.floor(j(t[1]))),f=Math.max(1,Math.floor(j(t[2]))),l=Math.max(1,Math.floor(j(t[3]))),c=t[4]?Math.floor(j(t[4])):0;if(!Number.isFinite(c)||c<0||c>2)throw new k("macd output must be 0, 1, or 2");const d=es(a,o,f,l);return{kind:"series",value:c===0?d.line:c===1?d.signal:d.hist}}case"stoch":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length<5||t.length>6)throw new k("stoch expects (high, low, close, k, d[, output])");const a=L(t[0],e),o=L(t[1],e),f=L(t[2],e),l=Math.max(1,Math.floor(j(t[3]))),c=Math.max(1,Math.floor(j(t[4]))),d=t[5]?Math.floor(j(t[5])):0;if(!Number.isFinite(d)||d<0||d>1)throw new k("stoch output must be 0 or 1");const N=ns(a,o,f,l,c);return{kind:"series",value:d===0?N.k:N.d}}case"ao":{if(t.length!==0&&t.length!==2)throw new k("ao expects () or (high, low)");const a=t.length===2?L(t[0],e):e.series.high,o=t.length===2?L(t[1],e):e.series.low;if(!a||!o)throw new k("ao requires high/low series");return{kind:"series",value:Ls(a,o)}}case"trix":{const[a,o]=m();return{kind:"series",value:Cs(a,o)}}case"williamsr":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length!==1&&t.length!==4)throw new k("williamsr expects (length) or (high, low, close, length)");const a=t.length===1?j(t[0]):j(t[3]),o=V(a,"williamsr_len",Wn,e);if(!Number.isFinite(o))return{kind:"series",value:W(e.length)};const f=t.length===1?e.series.high:L(t[0],e),l=t.length===1?e.series.low:L(t[1],e),c=t.length===1?e.series.close:L(t[2],e);if(!f||!l||!c)throw new k("williamsr requires high/low/close series");return{kind:"series",value:Cn(f,l,c,o)}}case"aroon":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length<1||t.length>2)throw new k("aroon expects (length[, output])");const a=j(t[0]),o=V(a,"aroon_len",Yn,e);if(!Number.isFinite(o))return{kind:"series",value:W(e.length)};const f=t[1]?Math.floor(j(t[1])):0;if(!Number.isFinite(f)||f<0||f>1)throw new k("aroon output must be 0 or 1");const l=e.series.high,c=e.series.low;if(!l||!c)throw new k("aroon requires high/low series");const d=je(l,c,o);return{kind:"series",value:f===0?d.up:d.down}}case"aroonosc":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length!==1)throw new k("aroonosc expects (length)");const a=j(t[0]),o=V(a,"aroonosc_len",nt,e);if(!Number.isFinite(o))return{kind:"series",value:W(e.length)};const f=e.series.high,l=e.series.low;if(!f||!l)throw new k("aroonosc requires high/low series");return{kind:"series",value:ts(f,l,o)}}case"dmi":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length<2||t.length>3)throw new k("dmi expects (length, smoothing[, output])");const a=j(t[0]),o=j(t[1]),f=V(a,"dmi_len",Xn,e),l=V(o,"dmi_smooth",Zn,e);if(!Number.isFinite(f)||!Number.isFinite(l))return{kind:"series",value:W(e.length)};const c=t[2]?Math.floor(j(t[2])):0;if(!Number.isFinite(c)||c<0||c>2)throw new k("dmi output must be 0, 1, or 2");const d=e.series.high,N=e.series.low,v=e.series.close;if(!d||!N||!v)throw new k("dmi requires high/low/close series");const p=ie(d,N,v,f,l);return{kind:"series",value:c===0?p.plus:c===1?p.minus:p.adx}}case"plus_di":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length!==1)throw new k("plus_di expects (length)");const a=j(t[0]),o=V(a,"plus_di_len",Qn,e);if(!Number.isFinite(o))return{kind:"series",value:W(e.length)};const f=e.series.high,l=e.series.low,c=e.series.close;if(!f||!l||!c)throw new k("plus_di requires high/low/close series");return{kind:"series",value:ie(f,l,c,o,o).plus}}case"minus_di":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length!==1)throw new k("minus_di expects (length)");const a=j(t[0]),o=V(a,"minus_di_len",xn,e);if(!Number.isFinite(o))return{kind:"series",value:W(e.length)};const f=e.series.high,l=e.series.low,c=e.series.close;if(!f||!l||!c)throw new k("minus_di requires high/low/close series");return{kind:"series",value:ie(f,l,c,o,o).minus}}case"dx":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length!==1)throw new k("dx expects (length)");const a=j(t[0]),o=V(a,"dx_len",et,e);if(!Number.isFinite(o))return{kind:"series",value:W(e.length)};const f=e.series.high,l=e.series.low,c=e.series.close;if(!f||!l||!c)throw new k("dx requires high/low/close series");const d=ie(f,l,c,o,o);return{kind:"series",value:Rn(d.plus,d.minus)}}case"adx":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length!==1)throw new k("adx expects (length)");const a=j(t[0]),o=V(a,"adx_len",Jn,e);if(!Number.isFinite(o))return{kind:"series",value:W(e.length)};const f=e.series.high,l=e.series.low,c=e.series.close;if(!f||!l||!c)throw new k("adx requires high/low/close series");return{kind:"series",value:ie(f,l,c,o,o).adx}}case"valuewhen":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length!==3)throw new k("valuewhen expects (condition, source, occurrence)");const a=n.args[0],o=le(a);o&&O(e,ue(a,e,"type"),De);const f=`valuewhen_occ:${q(n)}`;if(t[2].kind!=="scalar")return O(e,f,Oe),{kind:"series",value:W(e.length)};const l=ce(t[2].value,f,Oe,e);if(!Number.isFinite(l)||o)return{kind:"series",value:W(e.length)};const c=L(t[0],e),d=L(t[1],e),N=ue(a,e,"na");return{kind:"series",value:jn(c,d,l,S=>me(S,e.diagnostics,N))}}case"pivothigh":case"pivotlow":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length!==3)throw new k(`${n.callee} expects (source, left, right)`);const a=j(t[1]),o=j(t[2]),{left:f,right:l}=Pn(a,o),c=L(t[0],e);return{kind:"series",value:ss(c,f,l,r==="pivothigh"?"high":"low")}}case"year":case"month":case"dayofweek":case"hour":case"minute":case"second":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length!==1)throw new k(`${n.callee} expects (time)`);const a=t[0];if(a.kind==="scalar"){if(re(a.value),r==="dayofweek")return{kind:"scalar",value:nn(a.value)};const l=r==="year"||r==="month"?r:r==="hour"?"hour":r==="minute"?"minute":"second";return{kind:"scalar",value:tn(a.value,l)}}const o=L(a,e);if(On(o),r==="dayofweek")return{kind:"series",value:Ae(o,nn)};const f=r==="year"||r==="month"?r:r==="hour"?"hour":r==="minute"?"minute":"second";return{kind:"series",value:Ae(o,l=>tn(l,f))}}case"timestamp":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length<5||t.length>6)throw new k("timestamp expects (year, month, day, hour, minute[, second])");const a=t.length===6?t[5]:{kind:"scalar",value:0};if([t[0],t[1],t[2],t[3],t[4],a].every(w=>(w==null?void 0:w.kind)==="scalar")){const w=t[0].value,b=t[1].value,M=t[2].value,F=t[3].value,A=t[4].value,_=a.value;return{kind:"scalar",value:qn(w,b,M,F,A,_)}}const f=L(t[0],e),l=L(t[1],e),c=L(t[2],e),d=L(t[3],e),N=L(t[4],e),v=L(a,e);[f,l,c,d,N,v].forEach(On);const p=e.length,S=new Float32Array(p);for(let w=0;w<p;w++){const b=f[w],M=l[w],F=c[w],A=d[w],_=N[w],y=v[w];if(![b,M,F,A,_,y].every(Number.isFinite)){S[w]=NaN;continue}if(M<1||M>12)throw new k(Dn);S[w]=Date.UTC(b,M-1,F,A,_,y)}return{kind:"series",value:S}}case"timenow":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length!==0)throw new k("timenow expects ()");return{kind:"scalar",value:Tn(e)}}case"time_close":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length!==0)throw new k("time_close expects ()");const a=e.series.time;if(!a)throw new k("time_close requires time series");const o=Vn(e);return{kind:"series",value:Ae(a,f=>Number.isFinite(f)?f+o:NaN)}}case"isin":case"session_isin":case"session.isin":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length!==2)throw new k("session.isin expects (time, session)");const a=n.args[1];if(!a||a.kind!=="StringLiteral")throw new k(Pe);const{start:o,end:f}=Kn(a.value),l=t[0];if(l.kind==="scalar"){const N=l.value;if(!Number.isFinite(N))throw new k(sn);const v=rn(N);return{kind:"scalar",value:on(v,o,f)?1:0}}const c=L(l,e),d=new Float32Array(c.length);for(let N=0;N<c.length;N++){const v=c[N];if(!Number.isFinite(v))throw new k(sn);const p=rn(v);d[N]=on(p,o,f)?1:0}return{kind:"series",value:d}}case"cci":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length!==4)throw new k("cci expects (high, low, close, period)");const a=L(t[0],e),o=L(t[1],e),f=L(t[2],e),l=Math.max(1,Math.floor(j(t[3]))),c=Fn(Y(a),Y(o),Y(f),l);return{kind:"series",value:ee(c)}}case"mfi":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length!==5)throw new k("mfi expects (high, low, close, volume, period)");const a=L(t[0],e),o=L(t[1],e),f=L(t[2],e),l=L(t[3],e),c=Math.max(1,Math.floor(j(t[4]))),d=yn(Y(a),Y(o),Y(f),Y(l),c);return{kind:"series",value:ee(d)}}case"obv":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length!==2)throw new k("obv expects (close, volume)");const a=L(t[0],e),o=L(t[1],e),f=kn(Y(a),Y(o));return{kind:"series",value:ee(f)}}case"ad":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length!==0&&t.length!==4)throw new k("ad expects () or (high, low, close, volume)");const a=t.length===4?L(t[0],e):e.series.high,o=t.length===4?L(t[1],e):e.series.low,f=t.length===4?L(t[2],e):e.series.close,l=t.length===4?L(t[3],e):e.series.volume;if(!a||!o||!f||!l)throw new k("ad requires high/low/close/volume series");return{kind:"series",value:js(a,o,f,l)}}case"cmf":{if(!i)throw new k(`Unknown function "${n.callee}"`);if(t.length!==1&&t.length!==5)throw new k("cmf expects (length) or (high, low, close, volume, length)");const a=Math.max(1,Math.floor(j(t[t.length===1?0:4]))),o=t.length===5?L(t[0],e):e.series.high,f=t.length===5?L(t[1],e):e.series.low,l=t.length===5?L(t[2],e):e.series.close,c=t.length===5?L(t[3],e):e.series.volume;if(!o||!f||!l||!c)throw new k("cmf requires high/low/close/volume series");return{kind:"series",value:Ps(o,f,l,c,a)}}case"min":{if(t.length!==2)throw new k("min expects 2 arguments");const a=t[0],o=t[1];if(a.kind==="scalar"&&o.kind==="scalar")return{kind:"scalar",value:Math.min(a.value,o.value)};const f=L(a,e),l=L(o,e),c=e.length,d=new Float32Array(c);for(let N=0;N<c;N++)d[N]=Math.min(f[N],l[N]);return{kind:"series",value:d}}case"max":{if(t.length!==2)throw new k("max expects 2 arguments");const a=t[0],o=t[1];if(a.kind==="scalar"&&o.kind==="scalar")return{kind:"scalar",value:Math.max(a.value,o.value)};const f=L(a,e),l=L(o,e),c=e.length,d=new Float32Array(c);for(let N=0;N<c;N++)d[N]=Math.max(f[N],l[N]);return{kind:"series",value:d}}case"abs":{if(t.length!==1)throw new k("abs expects 1 argument");const a=t[0];if(a.kind==="scalar")return{kind:"scalar",value:Math.abs(a.value)};const o=a.value,f=e.length,l=new Float32Array(f);for(let c=0;c<f;c++)l[c]=Math.abs(o[c]);return{kind:"series",value:l}}default:throw new k(`Unknown function "${n.callee}"`)}}function ne(n,e){var s,i;switch(n.kind){case"NumberLiteral":return{kind:"scalar",value:n.value};case"StringLiteral":return{kind:"scalar",value:Q(n.value)};case"Identifier":{const r=n.name.replace(/\s+/g,"_").toLowerCase();if(r==="na"||r==="nan")return{kind:"scalar",value:NaN};if(r==="pi")return{kind:"scalar",value:Math.PI};if(r==="e")return{kind:"scalar",value:Math.E};const u=e.series[r];if(u)return{kind:"series",value:u};const t=(s=e.scalars)==null?void 0:s[r];if(typeof t=="number"&&Number.isFinite(t))return{kind:"scalar",value:t};throw e.seriesNames.has(r)?new k(`Series "${n.name}" is used before it is defined (circular or forward reference)`):new k(`Unknown identifier "${n.name}"`)}case"MemberExpression":{const r=Ne(n);return r?ne({kind:"Identifier",name:r},e):(Nt(e,n),{kind:"scalar",value:NaN})}case"IndexExpression":return bt(e,n),{kind:"scalar",value:NaN};case"UnaryExpression":{const r=ne(n.expr,e);if(n.operator==="not"){const u=((i=e.scalars)==null?void 0:i.__pinev2)===1;if(r.kind==="scalar"){const m=r.value;return{kind:"scalar",value:u?an(m):Number.isFinite(m)&&m!==0?0:1}}const t=r.value,h=new Float32Array(t.length);for(let m=0;m<t.length;m++){const g=t[m];h[m]=u?an(g):Number.isFinite(g)&&g!==0?0:1}return{kind:"series",value:h}}throw new k("Unsupported unary operator")}case"BinaryExpression":return n.operator==="and"||n.operator==="or"?Ns(n,e):vt(n.operator,ne(n.left,e),ne(n.right,e),e);case"CallExpression":return _t(n,e);default:throw new k("Unsupported expression node")}}function Te(n,e,s,i,r,u){var A;const t=new Set;for(const _ of n){const y=_.name.replace(/\s+/g,"_").toLowerCase();t.add(y)}const h=Object.entries(e),m=((A=h[0])==null?void 0:A[1].length)??0;for(const[,_]of h)if(_.length!==m)throw new k("All base series must have the same length");const g=n.map(_=>{try{const y=Ce(_.expr);return{name:_.name.replace(/\s+/g,"_").toLowerCase(),expr:_.expr,ast:y}}catch(y){throw y instanceof se?new k(`Syntax error in series "${_.name}" at position ${y.position}: ${y.message}`):y}}),a=(()=>{if(!s||typeof s!="object")return;const _={};return Object.entries(s).forEach(([y,$])=>{const I=y.replace(/\s+/g,"_").toLowerCase();if(typeof $=="number"&&Number.isFinite($)){_[I]=$;return}if(typeof $=="string"){const R=Number($);_[I]=Number.isFinite(R)?R:Q($)}}),Object.keys(_).length?_:void 0})(),o=(()=>{if(!s||typeof s!="object")return;const _={};return Object.entries(s).forEach(([y,$])=>{typeof $=="string"&&(_[y.replace(/\s+/g,"_").toLowerCase()]=$)}),Object.keys(_).length?_:void 0})(),f=At(u==null?void 0:u.loopPlans,a,!!(u!=null&&u.userFunctions)),l=$t(u==null?void 0:u.userFunctions),c={length:m,series:{...e},seriesNames:t,scalars:a,diagnostics:r,strategy:i,strings:o,loopRuntime:f,funcRuntime:l},d={},N=_=>{const y=new Set,$=I=>{switch(I.kind){case"Identifier":{const R=I.name.replace(/\s+/g,"_").toLowerCase();y.add(R);break}case"MemberExpression":{const R=Ne(I);if(R){const E=R.replace(/\s+/g,"_").toLowerCase();y.add(E);break}$(I.object);break}case"IndexExpression":$(I.object),$(I.index);break;case"BinaryExpression":$(I.left),$(I.right);break;case"UnaryExpression":$(I.expr);break;case"CallExpression":I.args.forEach(R=>$(R));break}};return $(_),y},v=new Set(g.map(_=>_.name)),p={},S={};g.forEach(_=>{p[_.name]=new Set,S[_.name]=new Set}),g.forEach(_=>{N(_.ast).forEach($=>{v.has($)&&$!==_.name&&(p[_.name].add($),S[$].add(_.name))})});const w={};Object.keys(p).forEach(_=>{var y;w[_]=((y=p[_])==null?void 0:y.size)??0});const b=Object.keys(w).filter(_=>(w[_]||0)===0),M=[];for(;b.length;){const _=b.shift();M.push(_);for(const y of S[_]||[])w[y]=(w[y]||0)-1,w[y]===0&&b.push(y)}if(M.length!==g.length){const _=g.map(y=>y.name).filter(y=>!M.includes(y));throw new k(`Circular dependency detected among series: ${_.join(" -> ")}`)}const F={};g.forEach(_=>{F[_.name]=_});for(const _ of M){const y=F[_];if(c.series[y.name])throw new k(`Series name "${y.name}" conflicts with an existing base series`);const $=ne(y.ast,c),I=L($,c);c.series[y.name]=I,d[y.name]=I}return d}const X=(n,e,s)=>{if(!n.memo)return s();const i=n.memo.get(e);if(i)return i;const r=s();return n.memo.set(e,r),r},fe=(n,e)=>{if(n.kind==="Identifier"){const s=n.name.replace(/\s+/g,"_").toLowerCase();return e.series[s]??null}if(n.kind==="MemberExpression"){const s=Ne(n);if(!s)return null;const i=s.replace(/\s+/g,"_").toLowerCase();return e.series[i]??null}if(n.kind==="NumberLiteral")return X(e,`const:${n.value}`,()=>{const s=new Float32Array(e.length);return s.fill(n.value),s});if(n.kind==="StringLiteral"){const s=Q(n.value);return X(e,`const_str:${n.value}`,()=>{const i=new Float32Array(e.length);return i.fill(s),i})}return null},Be=(n,e,s)=>{if(!n.memo)return s();const i=`${e}:a`,r=n.memo.get(i);if(r)return{a:r,b:n.memo.get(`${e}:b`)};const u=s();return n.memo.set(i,u.a),n.memo.set(`${e}:b`,u.b),u},Ke=(n,e,s)=>{if(!n.memo)return s();const i=`${e}:a`,r=n.memo.get(i);if(r)return{a:r,b:n.memo.get(`${e}:b`),c:n.memo.get(`${e}:c`)};const u=s();return n.memo.set(i,u.a),n.memo.set(`${e}:b`,u.b),n.memo.set(`${e}:c`,u.c),u};function Mt(n,e){var u;const s=n.replace(/\s+/g,"_").toLowerCase();if(s==="na"||s==="nan")return NaN;if(s==="pi")return Math.PI;if(s==="e")return Math.E;if(e.locals&&Object.prototype.hasOwnProperty.call(e.locals,s))return e.locals[s];if(e.selfKey&&e.selfOut&&s===e.selfKey){if(e.selfMode==="current"){const h=e.selfOut[e.index];if(Number.isFinite(h))return h}const t=e.index-1;return t>=0?e.selfOut[t]:NaN}const i=e.series[s];if(i)return i[e.index]??NaN;const r=(u=e.scalars)==null?void 0:u[s];if(typeof r=="number"&&Number.isFinite(r))return r;throw new k(`Unknown identifier "${n}"`)}const gn=1e3,Js=1e6,St=(n,e,s)=>{if(!Number.isFinite(n)||!Number.isFinite(e)||!Number.isFinite(s)||s===0)return null;if(s>0){if(n>e)return 0;const i=(e-n)/s;return Math.floor(i+1+1e-12)}if(s<0){if(n<e)return 0;const i=(n-e)/Math.abs(s);return Math.floor(i+1+1e-12)}return null},K=(n,e)=>{try{return Ce(n)}catch(s){throw s instanceof se?new k(`Syntax error in ${e} at position ${s.position}: ${s.message}`):s}},ze=n=>n.map(e=>e.kind==="assign"?{kind:"assign",name:e.name,expr:K(e.expr,`loop assignment "${e.name}"`),lineNo:e.lineNo}:e.kind==="if"?{kind:"if",lineNo:e.lineNo,branches:e.branches.map(s=>({cond:s.cond?K(s.cond,"loop if condition"):void 0,body:ze(s.body),lineNo:s.lineNo}))}:e.kind==="for"?{kind:"for",lineNo:e.lineNo,varName:e.varName,startExpr:K(e.startExpr,"loop for start"),endExpr:K(e.endExpr,"loop for end"),stepExpr:K(e.stepExpr,"loop for step"),body:ze(e.body)}:e.kind==="while"?{kind:"while",lineNo:e.lineNo,condExpr:K(e.condExpr,"loop while condition"),body:ze(e.body)}:{kind:e.kind,lineNo:e.lineNo}),wn=(n,e)=>{for(const s of n){if(s.kind==="assign"){e.add(s.name);continue}if(s.kind==="if"){s.branches.forEach(i=>wn(i.body,e));continue}(s.kind==="for"||s.kind==="while")&&wn(s.body,e)}},Qs=n=>{const e=ze(n.body||[]),s=new Set;return wn(e,s),{id:n.id,kind:n.kind,lineNo:n.lineNo,varName:n.varName,startExpr:n.startExpr?K(n.startExpr,"loop start"):void 0,endExpr:n.endExpr?K(n.endExpr,"loop end"):void 0,stepExpr:n.stepExpr?K(n.stepExpr,"loop step"):void 0,condExpr:n.condExpr?K(n.condExpr,"loop condition"):void 0,body:e,targets:Array.from(s)}},At=(n,e,s)=>{if((!n||!n.length)&&!s)return;const i=e==null?void 0:e.__loop_max_iters,r=typeof i=="number"&&Number.isFinite(i),u=r&&i<=0?Number.POSITIVE_INFINITY:r?Math.min(Js,Math.max(1,Math.floor(i))):gn,t=new Map;return(n||[]).forEach(h=>{if(!h||typeof h!="object")return;const m=String(h.id||"").trim();m&&t.set(m,Qs(h))}),{plans:t,maxIters:u,hasCustomMax:r,running:new Set}},Ge=n=>n.map(e=>e.kind==="assign"?{kind:"assign",name:e.name,op:e.op,decl:e.decl,expr:K(e.expr,`function assignment "${e.name}"`),lineNo:e.lineNo}:e.kind==="return"?{kind:"return",expr:K(e.expr,"function return"),lineNo:e.lineNo}:e.kind==="if"?{kind:"if",lineNo:e.lineNo,branches:e.branches.map(s=>({cond:s.cond?K(s.cond,"function if condition"):void 0,body:Ge(s.body),lineNo:s.lineNo}))}:e.kind==="for"?{kind:"for",lineNo:e.lineNo,varName:e.varName,startExpr:K(e.startExpr,"function for start"),endExpr:K(e.endExpr,"function for end"),stepExpr:K(e.stepExpr,"function for step"),body:Ge(e.body)}:e.kind==="while"?{kind:"while",lineNo:e.lineNo,condExpr:K(e.condExpr,"function while condition"),body:Ge(e.body)}:{kind:e.kind,lineNo:e.lineNo}),Nn=(n,e)=>{for(const s of n){if(s.kind==="assign"){if(s.decl==="var"||s.decl==="varip"){const i=s.name.replace(/\s+/g,"_").toLowerCase();e.add(i)}continue}if(s.kind==="if"){s.branches.forEach(i=>Nn(i.body,e));continue}(s.kind==="for"||s.kind==="while")&&Nn(s.body,e)}},xs=n=>{const e=Ge(n.body||[]),s=new Set;return Nn(e,s),{name:n.name,args:n.args||[],lineNo:n.lineNo,body:e,statefulVars:s}},$t=n=>{if(!n||!n.length)return;const e=new Map;return n.forEach(s=>{if(!s||typeof s!="object")return;const i=String(s.name||"").trim();if(i)try{e.set(i.toLowerCase(),xs(s))}catch{}}),{funcs:e,callState:new WeakMap,running:new Set}},Me=(n,e,s,i,r)=>P(n,{...e,locals:s,selfKey:i,selfOut:r,selfMode:"current"}),bn=(n,e,s)=>{for(const i of n){if(i.kind==="assign"){const r=i.name.replace(/\s+/g,"_").toLowerCase();let u=e.series[r];u||(u=new Float32Array(e.length),u.fill(NaN),e.series[r]=u);const t=Me(i.expr,e,s,r,u);u[e.index]=t;continue}if(i.kind==="break")return"break";if(i.kind==="continue")return"continue";if(i.kind==="if"){let r=!1;for(const u of i.branches){if(r)break;if(u.cond){const h=Me(u.cond,e,s);if(!me(h,e.diagnostics,`loop_cond_na:${i.lineNo}`))continue}r=!0;const t=bn(u.body,e,s);if(t!=="none")return t}continue}if(i.kind==="for"){He({kind:"for",varName:i.varName,startExpr:i.startExpr,endExpr:i.endExpr,stepExpr:i.stepExpr,body:i.body,lineNo:i.lineNo},e,s);continue}if(i.kind==="while"){He({kind:"while",condExpr:i.condExpr,body:i.body,lineNo:i.lineNo},e,s);continue}}return"none"},He=(n,e,s)=>{const i=e.loopRuntime,r=(i==null?void 0:i.maxIters)??gn,u=(i==null?void 0:i.hasCustomMax)??!1,t=`loop_max:${n.lineNo}`,h=`Loop exceeded max iterations (${r})`;if(n.kind==="for"){const a=Object.prototype.hasOwnProperty.call(s,n.varName)?s[n.varName]:void 0,o=Me(n.startExpr,e,s),f=Me(n.endExpr,e,s),l=Me(n.stepExpr,e,s);if(!Number.isFinite(l)||l===0){O(e,`loop_step_zero:${n.lineNo}`,"for-loop step must not be 0");return}const c=St(o,f,l),d=Number.isFinite(r)?r:null;let N=null,v=!1;u&&d!=null?c==null?(N=d,v=!0):(N=Math.min(d,c),v=c>d):c!=null&&(N=c);const p=l>0;let S=o,w=0;for(;(N==null||w<N)&&!(!Number.isFinite(S)||!Number.isFinite(f)||p&&S>f+1e-12||!p&&S<f-1e-12);){s[n.varName]=S;const b=bn(n.body,e,s);if(b==="break")break;S+=l,w+=1}v&&N!=null&&w>=N&&O(e,t,h),a===void 0?delete s[n.varName]:s[n.varName]=a;return}let m=0;const g=Number.isFinite(r)?r:null;for(;g==null||m<g;){const a=Me(n.condExpr,e,s);if(!me(a,e.diagnostics,`loop_cond_na:${n.lineNo}`))break;const f=bn(n.body,e,s);if(f==="break")break;m+=1}g!=null&&m>=g&&O(e,t,h)},ei=(n,e)=>{const s=e.locals?{...e.locals}:{},i=e.scalars??{};n.targets.forEach(u=>{const t=u.replace(/\s+/g,"_").toLowerCase();let h=e.series[t];h||(h=new Float32Array(e.length),h.fill(NaN),e.series[t]=h);const m=h[e.index];if(Number.isFinite(m))return;const g=i[t];if(typeof g=="number"&&Number.isFinite(g)){h[e.index]=g;return}if(e.index>0){const a=h[e.index-1];Number.isFinite(a)&&(h[e.index]=a)}}),n.kind==="for"?n.varName&&n.startExpr&&n.endExpr&&n.stepExpr&&He({kind:"for",varName:n.varName,startExpr:n.startExpr,endExpr:n.endExpr,stepExpr:n.stepExpr,body:n.body,lineNo:n.lineNo??0},{...e,locals:s},s):n.condExpr&&He({kind:"while",condExpr:n.condExpr,body:n.body,lineNo:n.lineNo??0},{...e,locals:s},s);const r={};return n.targets.forEach(u=>{const t=u.replace(/\s+/g,"_").toLowerCase(),h=e.series[t];r[t]=h?h[e.index]??NaN:NaN}),r},de=(n,e,s)=>P(n,{...e,locals:s,selfMode:"current"}),We=(n,e,s,i,r,u)=>{const t=(h,m)=>O(e,h,m);for(const h of n){if(h.kind==="assign"){const m=h.name.replace(/\s+/g,"_").toLowerCase(),g=de(h.expr,e,s);h.decl==="var"||h.decl==="varip"||r.has(m)?h.decl&&h.op==="="?(i.inited.has(m)||(i.vars[m]=g,i.inited.add(m)),s[m]=i.vars[m]??NaN):(!i.inited.has(m)&&h.op===":="&&t(`fn_var_uninit:${m}`,`Function var "${h.name}" is used before initialization`),i.vars[m]=g,i.inited.add(m),s[m]=g):(h.op===":="&&!Object.prototype.hasOwnProperty.call(s,m)&&t(`fn_local_uninit:${m}`,`Function local "${h.name}" is used before initialization`),s[m]=g);continue}if(h.kind==="return")return{kind:"return",value:de(h.expr,e,s)};if(h.kind==="break"){if(!u){t(`fn_break_outside:${h.lineNo}`,"break used outside of a loop");continue}return{kind:"break"}}if(h.kind==="continue"){if(!u){t(`fn_continue_outside:${h.lineNo}`,"continue used outside of a loop");continue}return{kind:"continue"}}if(h.kind==="if"){let m=!1;for(const g of h.branches){if(m)break;if(g.cond){const o=de(g.cond,e,s);if(!me(o,e.diagnostics,`fn_cond_na:${h.lineNo}`))continue}m=!0;const a=We(g.body,e,s,i,r,u);if(a.kind!=="none")return a}continue}if(h.kind==="for"){const m=Et({kind:"for",varName:h.varName,startExpr:h.startExpr,endExpr:h.endExpr,stepExpr:h.stepExpr,body:h.body,lineNo:h.lineNo},e,s,i,r);if(m.kind==="return")return m;continue}if(h.kind==="while"){const m=Et({kind:"while",condExpr:h.condExpr,body:h.body,lineNo:h.lineNo},e,s,i,r);if(m.kind==="return")return m;continue}}return{kind:"none"}},Et=(n,e,s,i,r)=>{const u=e.loopRuntime,t=(u==null?void 0:u.maxIters)??gn,h=(u==null?void 0:u.hasCustomMax)??!1,m=`fn_loop_max:${n.lineNo}`,g=`Loop exceeded max iterations (${t})`;if(n.kind==="for"){const f=n.varName.replace(/\s+/g,"_").toLowerCase(),l=Object.prototype.hasOwnProperty.call(s,f),c=s[f],d=de(n.startExpr,e,s),N=de(n.endExpr,e,s),v=de(n.stepExpr,e,s);if(!Number.isFinite(v)||v===0)return O(e,`fn_loop_step_zero:${n.lineNo}`,"for-loop step must not be 0"),{kind:"none"};const p=St(d,N,v),S=Number.isFinite(t)?t:null;let w=null,b=!1;h&&S!=null?p==null?(w=S,b=!0):(w=Math.min(S,p),b=p>S):p!=null&&(w=p);const M=v>0;let F=d,A=0;for(;(w==null||A<w)&&!(!Number.isFinite(F)||!Number.isFinite(N)||M&&F>N+1e-12||!M&&F<N-1e-12);){s[f]=F;const _=We(n.body,e,s,i,r,!0);if(_.kind==="return")return _;if(_.kind==="break")break;F+=v,A+=1,_.kind}return b&&w!=null&&A>=w&&O(e,m,g),l?s[f]=c:delete s[f],{kind:"none"}}let a=0;const o=Number.isFinite(t)?t:null;for(;o==null||a<o;){const f=de(n.condExpr,e,s);if(!me(f,e.diagnostics,`fn_loop_cond_na:${n.lineNo}`))break;const c=We(n.body,e,s,i,r,!0);if(c.kind==="return")return c;if(c.kind==="break")break;a+=1,c.kind}return o!=null&&a>=o&&O(e,m,g),{kind:"none"}},It=(n,e,s)=>{const i=s.funcRuntime;if(!i)return NaN;const r=i.callState.get(e)??(()=>{const g={vars:{},inited:new Set};return i.callState.set(e,g),g})();if(r.lastIndex===s.index)return r.lastValue??NaN;const u=n.name.toLowerCase();if(i.running.has(u))return O(s,`fn_recursion:${u}`,`Function "${n.name}" is recursive`),NaN;i.running.add(u);const t={};n.args.forEach((g,a)=>{const o=g.replace(/\s+/g,"_").toLowerCase(),f=e.args[a];t[o]=f?P(f,s):NaN}),n.statefulVars.forEach(g=>{Object.prototype.hasOwnProperty.call(r.vars,g)&&(t[g]=r.vars[g])});const h=We(n.body,s,t,r,n.statefulVars,!1);i.running.delete(u);const m=h.kind==="return"?h.value:NaN;return r.lastIndex=s.index,r.lastValue=m,m};function Lt(n){const e=n.match(/^(line|label|box|table)_get_([a-z0-9_]+)$/i);return e?{kind:e[1].toLowerCase(),prop:e[2].toLowerCase()}:null}function Ct(n){const e=n.match(/^strategy_(closedtrades|opentrades)_([a-z0-9_]+)$/i);return e?{kind:e[1].toLowerCase(),prop:e[2].toLowerCase()}:null}function Rt(n,e){return e?n==="session.isin"?"session_isin":n.startsWith("ta_")?n.slice(3):n.startsWith("math_")?n.slice(5):n:n}const ni={profit_pct:"profit_percent",pnl:"profit",net_pnl:"net_profit",net_pnl_pct:"net_profit_percent",net_pnl_percent:"net_profit_percent",fee:"fees",max_profit:"max_runup",max_profit_pct:"max_runup_percent",max_profit_percent:"max_runup_percent",max_runup_pct:"max_runup_percent",max_drawdown_pct:"max_drawdown_percent",max_loss:"max_drawdown",max_loss_pct:"max_drawdown_percent",max_loss_percent:"max_drawdown_percent"};function ti(n){const e=n.toLowerCase();return ni[e]??e}function jt(n,e,s,i,r){const u=ti(s),t=n.strategy;if(!t)return NaN;if(r<0)return NaN;if(e==="closedtrades"){const y=t.closedTrades||[];if(!y.length)return 0;const $=n.series.strategy_closedtrades,I=$?$[i]:NaN,E=(typeof I=="number"&&Number.isFinite(I)?Math.floor(I):0)-1-r;if(E<0||E>=y.length)return 0;const C=y[E],U=Number.isFinite(C.entryPrice)&&Number.isFinite(C.qty)&&C.entryPrice>0&&C.qty>0?C.entryPrice*C.qty:NaN,D=Number.isFinite(C.netPnl)?C.netPnl:Number.isFinite(C.pnl)?C.pnl-(C.fees??0):NaN,T=Number.isFinite(U)&&U!==0?D/U*100:NaN;switch(u){case"entry_price":return C.entryPrice;case"entry_time":return C.entryTimestamp;case"entry_bar_index":return C.entryIndex;case"exit_price":return C.exitPrice;case"exit_time":return C.exitTimestamp;case"exit_bar_index":return C.exitIndex;case"size":return C.qty;case"profit":return Number.isFinite(C.pnl)?C.pnl:0;case"profit_percent":return Number.isFinite(C.pnlPct)?C.pnlPct:0;case"net_profit":return Number.isFinite(D)?D:0;case"net_profit_percent":return Number.isFinite(T)?T:0;case"fees":return Number.isFinite(C.fees)?C.fees:0;case"entry_fee":return Number.isFinite(C.entryFee)?C.entryFee:0;case"exit_fee":return Number.isFinite(C.exitFee)?C.exitFee:0;case"max_runup":return typeof C.mfePct!="number"||!Number.isFinite(C.mfePct)?0:C.mfePct/100*C.entryPrice*C.qty;case"max_runup_percent":return typeof C.mfePct=="number"&&Number.isFinite(C.mfePct)?C.mfePct:0;case"max_drawdown":return typeof C.maePct!="number"||!Number.isFinite(C.maePct)?0:C.maePct/100*C.entryPrice*C.qty;case"max_drawdown_percent":return typeof C.maePct=="number"&&Number.isFinite(C.maePct)?C.maePct:0;case"is_long":return C.side==="long"?1:0;case"is_short":return C.side==="short"?1:0;case"entry_id":return Q(String(C.entryOrderId??C.entrySignalId??""));case"exit_id":return Q(String(C.exitOrderId??C.exitSignalId??""));default:return 0}}const h=t.openTradesByBar||[];if(i<0||i>=h.length)return 0;const m=h[i]||[];if(r>=m.length)return 0;const g=m[r],a=n.series.close,o=a&&Number.isFinite(a[i])?a[i]:NaN,f=g.qty,l=g.entryPrice,c=l>0&&f>0?l*f:NaN,d=typeof g.entryFee=="number"&&Number.isFinite(g.entryFee)?g.entryFee:0,N=Number.isFinite(o)&&Number.isFinite(l)?g.side==="long"?(o-l)*f:(l-o)*f:NaN,v=Number.isFinite(c)&&c!==0?N/c*100:NaN,p=Number.isFinite(N)&&Number.isFinite(d)?N-d:NaN,S=Number.isFinite(c)&&c!==0?p/c*100:NaN,w=g.maxFav,b=g.maxAdv,M=Number.isFinite(l)&&Number.isFinite(f)&&Number.isFinite(w)?g.side==="long"?(w-l)*f:(l-w)*f:NaN,F=Number.isFinite(l)&&l>0&&Number.isFinite(w)?g.side==="long"?(w-l)/l*100:(l-w)/l*100:NaN,A=Number.isFinite(l)&&Number.isFinite(f)&&Number.isFinite(b)?g.side==="long"?(b-l)*f:(l-b)*f:NaN,_=Number.isFinite(l)&&l>0&&Number.isFinite(b)?g.side==="long"?(b-l)/l*100:(l-b)/l*100:NaN;switch(u){case"entry_price":return l;case"entry_time":return g.entryTimestamp;case"entry_bar_index":return g.entryIndex;case"size":return f;case"profit":return Number.isFinite(N)?N:0;case"profit_percent":return Number.isFinite(v)?v:0;case"net_profit":return Number.isFinite(p)?p:0;case"net_profit_percent":return Number.isFinite(S)?S:0;case"fees":return Number.isFinite(d)?d:0;case"entry_fee":return Number.isFinite(d)?d:0;case"max_runup":return Number.isFinite(M)?M:0;case"max_runup_percent":return Number.isFinite(F)?F:0;case"max_drawdown":return Number.isFinite(A)?A:0;case"max_drawdown_percent":return Number.isFinite(_)?_:0;case"is_long":return g.side==="long"?1:0;case"is_short":return g.side==="short"?1:0;case"entry_id":return Q(String(g.entryOrderId??g.entrySignalId??""));default:return 0}}function P(n,e){var i,r,u,t,h,m,g,a,o,f;const s=((i=e.scalars)==null?void 0:i.__pinev2)===1;switch(n.kind){case"NumberLiteral":return n.value;case"StringLiteral":return Q(n.value);case"Identifier":return Mt(n.name,e);case"MemberExpression":{const l=Ne(n);return l?Mt(l,e):(Nt(e,n),NaN)}case"IndexExpression":return bt(e,n),NaN;case"UnaryExpression":{if(n.operator==="not"){const l=P(n.expr,e);return s?an(l):Number.isFinite(l)&&l!==0?0:1}return NaN}case"BinaryExpression":{if(n.operator==="and"||n.operator==="or"){if(s){const v=P(n.left,e),p=ae(v);if(n.operator==="and"){if(p===0)return 0;const w=P(n.right,e);return be(v,w)}if(p===1)return 1;const S=P(n.right,e);return pe(v,S)}const d=P(n.left,e),N=P(n.right,e);return n.operator==="and"?Number.isFinite(d)&&d!==0&&Number.isFinite(N)&&N!==0?1:0:Number.isFinite(d)&&d!==0||Number.isFinite(N)&&N!==0?1:0}const l=P(n.left,e),c=P(n.right,e);if(s&&ln(n.operator)&&(!Number.isFinite(l)||!Number.isFinite(c)))return NaN;switch(n.operator){case"+":return l+c;case"-":return l-c;case"*":return l*c;case"/":return ve(l,c,s,e);case"%":return c===0?NaN:l%c;case">":return Number.isFinite(l)&&Number.isFinite(c)&&l>c?1:0;case"<":return Number.isFinite(l)&&Number.isFinite(c)&&l<c?1:0;case">=":return Number.isFinite(l)&&Number.isFinite(c)&&l>=c?1:0;case"<=":return Number.isFinite(l)&&Number.isFinite(c)&&l<=c?1:0;case"==":return Number.isFinite(l)&&Number.isFinite(c)&&Math.abs(l-c)<1e-9?1:0;case"!=":return Number.isFinite(l)&&Number.isFinite(c)&&Math.abs(l-c)>=1e-9?1:0;default:return NaN}}case"CallExpression":{const l=e.funcRuntime;if(l){const w=l.funcs.get(n.callee.toLowerCase());if(w)return It(w,n,e)}const c=Rt(n.callee.toLowerCase(),s);if(c==="__loop_exec"){const w=y=>y?y.kind==="StringLiteral"?y.value:y.kind==="Identifier"?y.name:null:null,b=w(n.args[0]);if(!b)return O(e,`loop_exec_missing:${q(n)}`,"__loop_exec requires loop id"),NaN;const M=e.loopRuntime;if(!M)return O(e,`loop_runtime_missing:${b}`,"Loop runtime not configured"),NaN;const F=M.plans.get(b);if(!F)return O(e,`loop_missing:${b}`,`Unknown loop "${b}"`),NaN;if(F.lastIndex!==e.index){if(M.running.has(b))return O(e,`loop_recursion:${b}`,`Loop "${b}" is recursive`),NaN;M.running.add(b);const y=ei(F,e);F.lastIndex=e.index,F.lastValues=y,M.running.delete(b)}const A=w(n.args[1]);if(!A)return 0;const _=A.replace(/\s+/g,"_").toLowerCase();return((r=F.lastValues)==null?void 0:r[_])??NaN}const d=Lt(c);if(d&&e.draw){const w=n.args[0];let b="";if(w&&w.kind==="Identifier"&&(b=w.name),w&&w.kind==="StringLiteral"&&(b=w.value),!b)return NaN;const M=e.draw.get(d.kind,d.prop,b,e.index);return typeof M=="string"?Q(M):typeof M=="number"&&Number.isFinite(M)?M:NaN}const N=Ct(c);if(N){if(!e.strategy)return NaN;if(!n.args.length)throw new k(`${n.callee} expects (index)`);const w=P(n.args[0],e),b=Number.isFinite(w)?Math.floor(w):NaN;return Number.isFinite(b)?jt(e,N.kind,N.prop,e.index,b):NaN}const v=n.args[0],p=n.args[1];if(c==="__hist_index"||c==="__arr_index"){if(n.args.length!==1)throw new k(`${n.callee} expects (index)`);const w=P(v,e);return s?ce(w,c==="__hist_index"?"history_index":"array_index",c==="__hist_index"?$e:Gn,e):w}if(c==="__arr_index_str"){if(n.args.length!==1)throw new k(`${n.callee} expects (index)`);const w=P(v,e);if(!s)return w;const b=`arr_idx_str:${q(n)}`;return qe(w,b,e)}if(c==="__arr_set_guard"){if(n.args.length!==2)throw new k(`${n.callee} expects (index, size)`);if(!s)return 1;const w=P(v,e),b=P(p,e),M=`arr_set_guard:${q(n)}`;return fn(w,b,M,e)}if(c==="__arr_str_valid"){if(n.args.length!==1)throw new k(`${n.callee} expects (value)`);if(!s)return 1;const w=le(n.args[0]);return w||O(e,`arr_str_val:${q(n)}`,Hn),w?1:0}if(c==="__str_num"){if(n.args.length!==1)throw new k(`${n.callee} expects (value)`);return P(v,e)}if(c==="nz"){if(n.args.length<1||n.args.length>2)throw new k("nz expects (x[, fallback])");const w=P(v,e);return Number.isFinite(w)?w:n.args.length===2?P(p,e):0}if(c==="between"){if(n.args.length!==3)throw new k("between expects (x, a, b)");const w=P(v,e),b=P(p,e),M=P(n.args[2],e);if(!Number.isFinite(w)||!Number.isFinite(b)||!Number.isFinite(M))return s?NaN:0;const F=Math.min(b,M),A=Math.max(b,M);return w>=F&&w<=A?1:0}if(c==="above"||c==="below"){if(n.args.length<2||n.args.length>3)throw new k(`${n.callee} expects (a, b[, tol])`);const w=P(v,e),b=P(p,e),M=n.args.length===3?P(n.args[2],e):0,F=Number.isFinite(M)?Math.max(0,M):0;return!Number.isFinite(w)||!Number.isFinite(b)?s?NaN:0:c==="above"?w>b+F?1:0:w<b-F?1:0}if(c==="higherhigh"){const w=n.args.length>=1?Math.max(1,Math.floor(P(n.args[0],e))):1,b=e.series.high;if(!b)throw new k("higherhigh requires high series");const M=b[e.index];if(!Number.isFinite(M))return s?NaN:0;const F=Math.max(0,e.index-w),A=In(b,F,Math.max(0,e.index-1));return M>A?1:0}if(c==="lowerlow"){const w=n.args.length>=1?Math.max(1,Math.floor(P(n.args[0],e))):1,b=e.series.low;if(!b)throw new k("lowerlow requires low series");const M=b[e.index];if(!Number.isFinite(M))return s?NaN:0;const F=Math.max(0,e.index-w),A=Ln(b,F,Math.max(0,e.index-1));return M<A?1:0}if(c==="swinghigh"){const w=n.args.length>=1?Math.max(1,Math.floor(P(n.args[0],e))):3,b=e.series.high;if(!b)throw new k("swinghigh requires high series");const M=b[e.index];if(!Number.isFinite(M))return s?NaN:0;for(let F=e.index-w;F<=e.index+w;F++){if(F===e.index||F<0||F>=b.length)continue;const A=b[F];if(Number.isFinite(A)&&A>=M)return 0}return 1}if(c==="swinglow"){const w=n.args.length>=1?Math.max(1,Math.floor(P(n.args[0],e))):3,b=e.series.low;if(!b)throw new k("swinglow requires low series");const M=b[e.index];if(!Number.isFinite(M))return s?NaN:0;for(let F=e.index-w;F<=e.index+w;F++){if(F===e.index||F<0||F>=b.length)continue;const A=b[F];if(Number.isFinite(A)&&A<=M)return 0}return 1}if(c==="volspike"){const w=n.args.length>=1?Math.max(1,P(n.args[0],e)):1,b=e.series.volume;if(!b)throw new k("volspike requires volume series");const M=b[e.index];if(!Number.isFinite(M))return s?NaN:0;const A=Math.max(0,e.index-20+1);let _=0,y=0;for(let I=A;I<=e.index;I++){const R=b[I];Number.isFinite(R)&&(_+=R,y+=1)}const $=y?_/y:NaN;return Number.isFinite($)&&M>w*$?1:0}if(c==="atrspike"){const w=n.args.length>=1?Math.max(1,P(n.args[0],e)):1,b=e.series.high,M=e.series.low,F=e.series.close;if(!b||!M||!F)throw new k("atrspike requires high/low/close series");const A=E=>{const C=b[E],U=M[E],D=E>0?F[E-1]:NaN;let T=Number.isFinite(C)&&Number.isFinite(U)?Math.max(0,C-U):NaN;return Number.isFinite(D)&&(T=Math.max(T,Math.abs(C-D),Math.abs(U-D))),T};let _=NaN,y=0;for(let E=0;E<=e.index;E++){const C=A(E);y+=Number.isFinite(C)?C:0,E===13?_=y/14:E>=14&&(_=(_*13+C)/14)}let $=NaN,I=0,R=0;for(let E=Math.max(0,e.index-13);E<=e.index;E++){const C=A(E);Number.isFinite(C)&&(I+=C,R+=1)}return R&&($=I/R),Number.isFinite(_)&&Number.isFinite($)&&_>w*$?1:0}if(c==="trend"){const w=n.args[0],b=w&&w.kind==="StringLiteral"?w.value:w&&w.kind==="Identifier"?w.name:"",M=String(b||"").toLowerCase()||"up",F=e.series.close;if(!F)throw new k("trend requires close series");const _=Math.max(0,e.index-10+1);let y=0,$=0,I=0,R=0,E=0;for(let D=_;D<=e.index;D++){const T=D-_,G=F[D];Number.isFinite(G)&&(y+=T,$+=G,I+=T*T,R+=T*G,E+=1)}const C=E*I-y*y,U=C===0||E===0?0:(E*R-y*$)/C;return M==="up"?U>0?1:0:U<0?1:0}if(c==="iff"||c==="iif"||c==="if"){if(n.args.length!==3)throw new k(`${n.callee} expects (cond, a, b)`);if(s){const $=ke(n.args[1]),I=ke(n.args[2]);if($!==I)return O(e,"ternary_type",zn),NaN}const w=n.args[0],b=s&&le(w),M=s?ue(w,e,"na"):void 0;b&&O(e,ue(w,e,"type"),De);const F=P(v,e),A=b?!1:cn(F,e,M),_=P(n.args[1],e),y=P(n.args[2],e);return A?_:y}if(c==="tostring"||c==="format"||c==="upper"||c==="lower"||c==="trim"||c==="replace"||c==="replace_all"||c==="contains"||c==="startswith"||c==="endswith"||c==="length"||c==="substring"||c==="repeat"){const w=F=>Number.isFinite(F)?String(F):"",b=F=>Q(F),M=F=>{var y;const A=n.args[F];if(!A)return"";if(A.kind==="StringLiteral")return A.value;if(A.kind==="Identifier"){const $=A.name.replace(/\s+/g,"_").toLowerCase(),I=(y=e.strings)==null?void 0:y[$];if(typeof I=="string")return I}const _=P(A,e);return w(_)};if(c==="tostring"){if(n.args.length<1||n.args.length>2)throw new k("tostring expects (x[, format])");const F=P(n.args[0],e),A=n.args[1];let _="";if(A){if(A.kind==="StringLiteral")_=A.value;else if(A.kind==="Identifier"){const $=A.name.replace(/\s+/g,"_").toLowerCase(),I=(u=e.strings)==null?void 0:u[$];typeof I=="string"&&(_=I)}}const y=Jt(F,_||void 0);return b(y)}if(c==="format"){if(n.args.length<1)throw new k("format expects (fmt, ...)");const F=M(0),A=n.args.slice(1).map(y=>$n(P(y,e))),_=F.replace(/\{(\d+)\}/g,(y,$)=>A[Number($)]??"");return b(_.replace(/{{/g,"{").replace(/}}/g,"}"))}if(c==="upper")return b(M(0).toUpperCase());if(c==="lower")return b(M(0).toLowerCase());if(c==="trim")return b(M(0).trim());if(c==="replace"||c==="replace_all"){if(n.args.length<3)throw new k("replace expects (s, from, to)");const F=M(0),A=M(1),_=M(2);return b(F.split(A).join(_))}if(c==="contains"){if(n.args.length<2)throw new k("contains expects (s, sub)");const F=M(0),A=M(1);return F.includes(A)?1:0}if(c==="startswith"){if(n.args.length<2)throw new k("startswith expects (s, sub)");const F=M(0),A=M(1);return F.startsWith(A)?1:0}if(c==="endswith"){if(n.args.length<2)throw new k("endswith expects (s, sub)");const F=M(0),A=M(1);return F.endsWith(A)?1:0}if(c==="length"){if(n.args.length!==1)throw new k("length expects (s)");return M(0).length}if(c==="substring"){if(n.args.length<2)throw new k("substring expects (s, from[, to])");const F=M(0),A=P(n.args[1],e),_=n.args.length>2?P(n.args[2],e):NaN,y=Math.max(0,Math.floor(A)),$=Number.isFinite(_)?Math.max(y,Math.floor(_)):void 0;return b($==null?F.slice(y):F.slice(y,$))}if(c==="repeat"){if(n.args.length<2)throw new k("repeat expects (s, count)");const F=M(0),A=Math.max(0,Math.floor(P(n.args[1],e)));return b(F.repeat(A))}}if(c==="add"||c==="sub"||c==="mul"||c==="div"){if(n.args.length!==2)throw new k(`${n.callee} expects 2 arguments`);const w=P(v,e),b=P(p,e);return c==="add"?w+b:c==="sub"?w-b:c==="mul"?w*b:ve(w,b,s,e)}if(c==="mod"||c==="fmod"){if(!s)throw new k(`Unknown function "${n.callee}"`);if(n.args.length!==2)throw new k(`${n.callee} expects 2 arguments`);const w=P(v,e),b=P(p,e);return c==="mod"?ct(w,b,!0,e):at(w,b,!0,e)}if(c==="min"||c==="max"){if(n.args.length!==2)throw new k(`${n.callee} expects 2 arguments`);const w=P(v,e),b=P(p,e);return c==="min"?Math.min(w,b):Math.max(w,b)}if(c==="abs"){if(n.args.length!==1)throw new k("abs expects 1 argument");return Math.abs(P(v,e))}if(c==="pow"){if(n.args.length!==2)throw new k("pow expects 2 arguments");const w=P(v,e),b=P(p,e);return un(w,b,s,e)}if(c==="sqrt"||c==="log"||c==="ln"||c==="log10"||c==="exp"||c==="floor"||c==="ceil"||c==="round"||c==="sin"||c==="cos"||c==="tan"||c==="asin"||c==="acos"||c==="atan"||c==="sign"){if(n.args.length!==1)throw new k(`${n.callee} expects 1 argument`);const w=P(v,e);switch(c){case"sqrt":return lt(w,s,e);case"log":case"ln":return ut(w,s,e);case"log10":return ft(w,s,e);case"exp":return gt(w,s);case"floor":return Math.floor(w);case"ceil":return Math.ceil(w);case"round":return Math.round(w);case"sin":return Math.sin(w);case"cos":return Math.cos(w);case"tan":return dt(w,s);case"asin":return ht(w,s,e);case"acos":return mt(w,s,e);case"atan":return Math.atan(w);default:return Math.sign(w)}}if(c==="cum"||c==="cumsum"){if(n.args.length!==1)throw new k(`${n.callee} expects 1 argument`);const w=v;if(w.kind!=="Identifier")throw new k(`${n.callee} expects a series identifier`);const b=w.name.replace(/\s+/g,"_").toLowerCase(),M=e.series[b];if(!M)throw new k(`Unknown identifier "${w.name}"`);let F=0;for(let A=0;A<=e.index;A++){const _=M[A];Number.isFinite(_)&&(F+=_)}return F}if(c==="barssince"){if(n.args.length!==1)throw new k("barssince expects (condition)");const w=v;if(w.kind!=="Identifier")throw new k("barssince expects a series identifier");const b=w.name.replace(/\s+/g,"_").toLowerCase(),M=e.series[b];if(!M)throw new k(`Unknown identifier "${w.name}"`);for(let F=e.index;F>=0;F--){const A=M[F];if(Number.isFinite(A)&&A!==0)return e.index-F}return NaN}if(c==="tr"){if(n.args.length!==0&&n.args.length!==3)throw new k("tr expects () or (high, low, close)");const w=(I,R)=>{if(!I){const U=e.series[R];if(!U)throw new k(`Unknown identifier "${R}"`);return U}if(I.kind!=="Identifier")throw new k("tr expects series identifiers");const E=I.name.replace(/\s+/g,"_").toLowerCase(),C=e.series[E];if(!C)throw new k(`Unknown identifier "${I.name}"`);return C},b=w(n.args[0],"high"),M=w(n.args[1],"low"),F=w(n.args[2],"close"),A=b[e.index],_=M[e.index],y=e.index>0?F[e.index-1]:NaN;let $=Math.max(0,A-_);return Number.isFinite(y)&&($=Math.max($,Math.abs(A-y),Math.abs(_-y))),$}if(c==="prev"||c==="lag"||c==="change"){if(n.args.length!==2)throw new k(`${n.callee} expects (series, n)`);const w=v;if(w.kind!=="Identifier")throw new k(`${n.callee} expects first argument to be a series identifier`);const b=w.name.replace(/\s+/g,"_").toLowerCase(),M=P(p,e),F=s?ce(M,"history_index",$e,e):Math.max(1,Math.floor(M));if(!Number.isFinite(F))return NaN;const A=e.index-F,_=I=>{if(I<0)return NaN;if(e.selfKey&&e.selfOut&&b===e.selfKey)return e.selfOut[I]??NaN;const R=e.series[b];if(!R)throw new k(`Unknown identifier "${w.name}"`);return R[I]??NaN};if(c==="prev"||c==="lag")return _(A);const y=_(e.index),$=_(A);return Number.isFinite(y)&&Number.isFinite($)?y-$:NaN}if(c==="sum"){if(n.args.length!==2)throw new k("sum expects (series, period)");const w=fe(v,e);if(!w)throw new k("sum expects first argument to be a series identifier");const b=P(p,e),M=s?V(b,`sum_len:${q(n)}`,it,e):Math.max(1,Math.floor(b));return Number.isFinite(M)?X(e,`sum:${M}:${q(v)}`,()=>H(w,M))[e.index]??NaN:NaN}if(c==="highest"||c==="lowest"){if(n.args.length!==2)throw new k(`${n.callee} expects (series, period)`);const w=fe(v,e);if(!w)throw new k(`${n.callee} expects first argument to be a series identifier`);const b=P(p,e),M=`${c}_len:${q(n)}`,A=s?V(b,M,c==="highest"?tt:st,e):Math.max(1,Math.floor(b));return Number.isFinite(A)?X(e,`${c}:${A}:${q(v)}`,()=>c==="highest"?ye(w,A):_e(w,A))[e.index]??NaN:NaN}if(c==="rising"||c==="falling"){if(!s)throw new k(`Unknown function "${n.callee}"`);if(n.args.length!==2)throw new k(`${n.callee} expects (series, length)`);const w=fe(v,e);if(!w)throw new k(`${n.callee} expects first argument to be a series identifier`);const b=P(p,e),M=`${c}_len:${q(n)}`,A=V(b,M,c==="rising"?rt:ot,e);return Number.isFinite(A)?X(e,`${c}:${A}:${q(v)}`,()=>En(w,A,c))[e.index]??NaN:NaN}if(c==="crossover"||c==="crossunder"){if(n.args.length<2||n.args.length>3)throw new k(`${n.callee} expects (series, series[, tol])`);const w=v;if(w.kind!=="Identifier")throw new k(`${n.callee} expects first argument to be a series identifier`);const b=w.name.replace(/\s+/g,"_").toLowerCase(),M=e.series[b];if(!M)throw new k(`Unknown identifier "${w.name}"`);const F=n.args[1];let A=null,_=NaN;if(F.kind==="Identifier"){const C=F.name.replace(/\s+/g,"_").toLowerCase();if(A=e.series[C]||null,!A){const U=Number(F.name);_=Number.isFinite(U)?U:NaN}}else _=P(F,e);const y=n.args[2]?Math.max(0,P(n.args[2],e)):0;if(e.index<=0)return 0;const $=M[e.index-1],I=M[e.index],R=A?A[e.index-1]:_,E=A?A[e.index]:_;return[$,I,R,E].every(Number.isFinite)?c==="crossover"?$<=R+y&&I>E+y?1:0:$>=R-y&&I<E-y?1:0:0}if(c==="williamsr"){if(!s)throw new k(`Unknown function "${n.callee}"`);if(n.args.length!==1&&n.args.length!==4)throw new k("williamsr expects (length) or (high, low, close, length)");const w=n.args.length===1?P(n.args[0],e):P(n.args[3],e),b=V(w,"williamsr_len",Wn,e);if(!Number.isFinite(b))return NaN;const M=n.args.length===1?e.series.high:fe(n.args[0],e),F=n.args.length===1?e.series.low:fe(n.args[1],e),A=n.args.length===1?e.series.close:fe(n.args[2],e);if(!M||!F||!A)throw new k("williamsr requires high/low/close series");const _=n.args.length===1?`williamsr:${b}`:`williamsr:${b}:${n.args.map($=>$.kind==="Identifier"?$.name:$.kind==="NumberLiteral"||$.kind==="StringLiteral"?$.value:"expr").join("|")}`;return X(e,_,()=>Cn(M,F,A,b))[e.index]??NaN}if(c==="aroon"){if(!s)throw new k(`Unknown function "${n.callee}"`);if(n.args.length<1||n.args.length>2)throw new k("aroon expects (length[, output])");const w=P(n.args[0],e),b=V(w,"aroon_len",Yn,e);if(!Number.isFinite(b))return NaN;const M=n.args[1]?Math.floor(P(n.args[1],e)):0;if(!Number.isFinite(M)||M<0||M>1)throw new k("aroon output must be 0 or 1");const F=e.series.high,A=e.series.low;if(!F||!A)throw new k("aroon requires high/low series");const _=`aroon:${b}`,y=Be(e,_,()=>{const I=je(F,A,b);return{a:I.up,b:I.down}});return(M===0?y.a:y.b)[e.index]??NaN}if(c==="aroonosc"){if(!s)throw new k(`Unknown function "${n.callee}"`);if(n.args.length!==1)throw new k("aroonosc expects (length)");const w=P(n.args[0],e),b=V(w,"aroonosc_len",nt,e);if(!Number.isFinite(b))return NaN;const M=e.series.high,F=e.series.low;if(!M||!F)throw new k("aroonosc requires high/low series");const A=`aroon:${b}`,_=Be(e,A,()=>{const I=je(M,F,b);return{a:I.up,b:I.down}}),y=_.a[e.index],$=_.b[e.index];return Number.isFinite(y)&&Number.isFinite($)?y-$:NaN}if(c==="dmi"){if(!s)throw new k(`Unknown function "${n.callee}"`);if(n.args.length<2||n.args.length>3)throw new k("dmi expects (length, smoothing[, output])");const w=P(n.args[0],e),b=P(n.args[1],e),M=V(w,"dmi_len",Xn,e),F=V(b,"dmi_smooth",Zn,e);if(!Number.isFinite(M)||!Number.isFinite(F))return NaN;const A=n.args[2]?Math.floor(P(n.args[2],e)):0;if(!Number.isFinite(A)||A<0||A>2)throw new k("dmi output must be 0, 1, or 2");const _=e.series.high,y=e.series.low,$=e.series.close;if(!_||!y||!$)throw new k("dmi requires high/low/close series");const I=`dmi:${M}:${F}`,R=Ke(e,I,()=>{const C=ie(_,y,$,M,F);return{a:C.plus,b:C.minus,c:C.adx}});return(A===0?R.a:A===1?R.b:R.c)[e.index]??NaN}if(c==="plus_di"||c==="minus_di"||c==="dx"){if(!s)throw new k(`Unknown function "${n.callee}"`);if(n.args.length!==1)throw new k(`${n.callee} expects (length)`);const w=P(n.args[0],e),F=V(w,c==="plus_di"?"plus_di_len":c==="minus_di"?"minus_di_len":"dx_len",c==="plus_di"?Qn:c==="minus_di"?xn:et,e);if(!Number.isFinite(F))return NaN;const A=e.series.high,_=e.series.low,y=e.series.close;if(!A||!_||!y)throw new k(`${c} requires high/low/close series`);const $=`dmi:${F}:${F}`,I=Ke(e,$,()=>{const E=ie(A,_,y,F,F);return{a:E.plus,b:E.minus,c:E.adx}});return c==="plus_di"?I.a[e.index]??NaN:c==="minus_di"?I.b[e.index]??NaN:X(e,`dx:${F}`,()=>Rn(I.a,I.b))[e.index]??NaN}if(c==="adx"){if(!s)throw new k(`Unknown function "${n.callee}"`);if(n.args.length!==1)throw new k("adx expects (length)");const w=P(n.args[0],e),b=V(w,"adx_len",Jn,e);if(!Number.isFinite(b))return NaN;const M=e.series.high,F=e.series.low,A=e.series.close;if(!M||!F||!A)throw new k("adx requires high/low/close series");const _=`dmi:${b}:${b}`;return Ke(e,_,()=>{const $=ie(M,F,A,b,b);return{a:$.plus,b:$.minus,c:$.adx}}).c[e.index]??NaN}if(c==="valuewhen"){if(!(((t=e.scalars)==null?void 0:t.__pinev2)===1))throw new k(`Unknown function "${n.callee}"`);if(n.args.length!==3)throw new k("valuewhen expects (condition, source, occurrence)");const b=n.args[0],M=le(b);M&&O(e,ue(b,e,"type"),De);const F=n.args[2],A=`valuewhen_occ:${q(n)}`;if(ws(F,e))return O(e,A,Oe),NaN;const _=P(F,e),y=ce(_,A,Oe,e);if(!Number.isFinite(y)||M)return NaN;const $=ue(b,e,"na"),I=U=>me(U,e.diagnostics,$),R=fe(b,e),E=fe(n.args[1],e);if(R&&E)return X(e,`valuewhen:${y}:${q(b)}:${q(n.args[1])}`,()=>jn(R,E,y,I))[e.index]??NaN;let C=0;for(let U=e.index;U>=0;U--){const D={...e,index:U},T=P(b,D);if(I(T)){if(C===y)return P(n.args[1],D);C+=1}}return NaN}if(c==="pivothigh"||c==="pivotlow"){if(!(((h=e.scalars)==null?void 0:h.__pinev2)===1))throw new k(`Unknown function "${n.callee}"`);if(n.args.length!==3)throw new k(`${n.callee} expects (source, left, right)`);const b=P(n.args[1],e),M=P(n.args[2],e),{left:F,right:A}=Pn(b,M),_=e.index-A;if(_-F<0)return NaN;const y=C=>P(n.args[0],{...e,index:C}),$=y(_);if(!Number.isFinite($))return NaN;const I=_-F,R=_+A,E=c==="pivothigh";for(let C=I;C<=R;C++){const U=y(C);if(!Number.isFinite(U))return NaN;if(E){if(U>$)return NaN}else if(U<$)return NaN}return $}if(c==="isin"||c==="session_isin"||c==="session.isin"){if(!(((m=e.scalars)==null?void 0:m.__pinev2)===1))throw new k(`Unknown function "${n.callee}"`);if(n.args.length!==2)throw new k("session.isin expects (time, session)");const b=n.args[1];if(!b||b.kind!=="StringLiteral")throw new k(Pe);const{start:M,end:F}=Kn(b.value),A=P(n.args[0],e);if(!Number.isFinite(A))throw new k(sn);const _=rn(A);return on(_,M,F)?1:0}if(c==="year"||c==="month"||c==="dayofweek"||c==="hour"||c==="minute"||c==="second"){if(!(((g=e.scalars)==null?void 0:g.__pinev2)===1))throw new k(`Unknown function "${n.callee}"`);if(n.args.length!==1)throw new k(`${n.callee} expects (time)`);const b=P(n.args[0],e);return re(b),c==="dayofweek"?nn(b):tn(b,c==="year"||c==="month"?c:c==="hour"?"hour":c==="minute"?"minute":"second")}if(c==="timestamp"){if(!(((a=e.scalars)==null?void 0:a.__pinev2)===1))throw new k(`Unknown function "${n.callee}"`);if(n.args.length<5||n.args.length>6)throw new k("timestamp expects (year, month, day, hour, minute[, second])");const b=P(n.args[0],e),M=P(n.args[1],e),F=P(n.args[2],e),A=P(n.args[3],e),_=P(n.args[4],e),y=n.args[5]?P(n.args[5],e):0;return qn(b,M,F,A,_,y)}if(c==="timenow"){if(!(((o=e.scalars)==null?void 0:o.__pinev2)===1))throw new k(`Unknown function "${n.callee}"`);if(n.args.length!==0)throw new k("timenow expects ()");return Tn(e)}if(c==="time_close"){if(!(((f=e.scalars)==null?void 0:f.__pinev2)===1))throw new k(`Unknown function "${n.callee}"`);if(n.args.length!==0)throw new k("time_close expects ()");const b=e.series.time;if(!b)throw new k("time_close requires time series");const M=Vn(e),F=b[e.index];return Number.isFinite(F)?F+M:NaN}const S={length:e.length,series:e.series,seriesNames:new Set(Object.keys(e.series)),scalars:e.scalars,strings:e.strings,diagnostics:e.diagnostics,draw:e.draw,strategy:e.strategy,loopRuntime:e.loopRuntime,funcRuntime:e.funcRuntime};try{const w=`call:${q(n)}`;return X(e,w,()=>{const M=_t(n,S);if(M.kind==="series")return M.value;const F=new Float32Array(e.length);return F.fill(M.value),F})[e.index]??NaN}catch(w){if(w instanceof k)throw w}throw new k(`Unknown function "${n.callee}"`)}default:return NaN}}function Pt(n,e,s,i,r){var v;const u=Object.entries(e),t=((v=u[0])==null?void 0:v[1].length)??0;for(const[,p]of u)if(p.length!==t)throw new k("All base series must have the same length");const h=(()=>{if(!s||typeof s!="object")return;const p={};return Object.entries(s).forEach(([S,w])=>{const b=S.replace(/\s+/g,"_").toLowerCase();if(typeof w=="number"&&Number.isFinite(w)){p[b]=w;return}if(typeof w=="string"){const M=Number(w);p[b]=Number.isFinite(M)?M:Q(w)}}),Object.keys(p).length?p:void 0})(),m=(()=>{if(!s||typeof s!="object")return;const p={};return Object.entries(s).forEach(([S,w])=>{typeof w=="string"&&(p[S.replace(/\s+/g,"_").toLowerCase()]=w)}),Object.keys(p).length?p:void 0})(),g=n.map(p=>{const S=p.name.replace(/\s+/g,"_").toLowerCase();try{const w=p.initExpr?Ce(p.initExpr):null,b=Ce(p.updateExpr);return{name:S,initAst:w,updateAst:b,initExpr:p.initExpr,updateExpr:p.updateExpr,selfMode:p.selfMode}}catch(w){throw w instanceof se?new k(`Syntax error in series "${p.name}" at position ${w.position}: ${w.message}`):w}}),a=(()=>{if(!(r!=null&&r.autoSort)||g.length<=1)return g;const p=new Set(g.map(E=>E.name)),S={},w={},b=new Map;g.forEach((E,C)=>{S[E.name]=new Set,w[E.name]=new Set,b.set(E.name,C)});const M=E=>E.replace(/\s+/g,"_").toLowerCase(),F=E=>{const C=new Set,U=(D,T)=>{switch(D.kind){case"Identifier":{const G=M(D.name);T||C.add(G);break}case"BinaryExpression":U(D.left,T),U(D.right,T);break;case"UnaryExpression":U(D.expr,T);break;case"CallExpression":{const G=String(D.callee||"").toLowerCase(),Qe=G==="prev"||G==="lag";D.args.forEach((xe,gi)=>{U(xe,T||Qe&&gi===0)});break}}};return E&&U(E,!1),{direct:C}},A=(E,C)=>{if(!C)return;const{direct:U}=F(C);U.forEach(D=>{!p.has(D)||D===E||(S[E].add(D),w[D].add(E))})};g.forEach(E=>{A(E.name,E.updateAst),A(E.name,E.initAst)});const _={};Object.keys(S).forEach(E=>{var C;_[E]=((C=S[E])==null?void 0:C.size)??0});const y=Object.keys(_).filter(E=>(_[E]||0)===0);y.sort((E,C)=>(b.get(E)??0)-(b.get(C)??0));const $=[],I=E=>{const C=y.findIndex(U=>(b.get(U)??0)>(b.get(E)??0));C===-1?y.push(E):y.splice(C,0,E)};for(;y.length;){const E=y.shift();$.push(E);const C=Array.from(w[E]||[]).sort((U,D)=>(b.get(U)??0)-(b.get(D)??0));for(const U of C)_[U]=(_[U]||0)-1,_[U]===0&&I(U)}if($.length!==g.length){const E=g.map(C=>C.name).filter(C=>!$.includes(C));throw new k(`Circular dependency detected among state series: ${E.join(" -> ")}`)}const R={};return g.forEach(E=>{R[E.name]=E}),$.map(E=>R[E])})(),o={},f={...e},l=new Set(Object.keys(e));for(const p of g){if(l.has(p.name))throw new k(`Series name "${p.name}" conflicts with an existing base series`);if(f[p.name])o[p.name]||(o[p.name]=f[p.name]);else{const S=new Float32Array(t);S.fill(NaN),f[p.name]=S,o[p.name]=S}}const c=r==null?void 0:r.diagnostics,d=At(r==null?void 0:r.loopPlans,h,!!(r!=null&&r.userFunctions)),N=$t(r==null?void 0:r.userFunctions);for(let p=0;p<t;p++)for(const S of a){const w=o[S.name],b={series:f,scalars:h,strings:m,diagnostics:c,length:t,index:p,selfKey:S.name,selfOut:w,selfMode:S.selfMode,strategy:i,loopRuntime:d,funcRuntime:N},M=p===0&&S.initAst?S.initAst:S.updateAst,F=P(M,b);w[p]=F}return o}function Ye(n,e){const s=n.length,i=new Float32Array(s);for(let r=0;r<s;r++){const u=r-e;i[r]=u>=0?n[u]:NaN}return i}const Xe=n=>/[A-Za-z_$]/.test(n),Ze=n=>/[A-Za-z0-9_$]/.test(n);function si(n){return String(n||"").replace(/\u00A0/g," ")}function ii(n){const e=String(n||"");let s="",i=null,r=!1;for(let u=0;u<e.length;u++){const t=e[u],h=e[u+1];if(i){if(s+=t,r){r=!1;continue}if(t==="\\"){r=!0;continue}t===i&&(i=null);continue}if(t==="'"||t==='"'){i=t,s+=t;continue}if(t==="/"&&h==="/"){for(u+=1;u+1<e.length;){const m=e[u+1];if(m===`
`||m==="\r")break;u+=1}continue}s+=t}return s}function ri(n,e){const s=String(n||""),i=s.length;let r="",u=null,t=0;for(;t<i;){const h=s[t];if(u){r+=h,h===u&&s[t-1]!=="\\"&&(u=null),t+=1;continue}if(h==="'"||h==='"'){u=h,r+=h,t+=1;continue}if(Xe(h)){let m=t+1;for(;m<i&&Ze(s[m]);)m+=1;const g=s.slice(t,m),a=g.toLowerCase();let o=m;for(;o<i&&/\s/.test(s[o]);)o+=1;if(s[o]==="."){let f=o+1;for(;f<i&&/\s/.test(s[f]);)f+=1;if(f<i&&Xe(s[f])){let l=f+1;for(;l<i&&Ze(s[l]);)l+=1;const c=s.slice(f,l),d=c.toLowerCase();if(a==="strategy"&&(d==="closedtrades"||d==="opentrades")){let v=l;for(;v<i&&/\s/.test(s[v]);)v+=1;if(s[v]==="."){let p=v+1;for(;p<i&&/\s/.test(s[p]);)p+=1;if(p<i&&Xe(s[p])){let S=p+1;for(;S<i&&Ze(s[S]);)S+=1;const w=s.slice(p,S);r+=`strategy_${d}_${w}`,t=S;continue}}}if(a==="barstate"||a==="timeframe"||a==="syminfo"||a==="strategy"){r+=`${a}_${c}`,t=l;continue}if(e){if(a==="ta"||a==="math"||a==="session"||a==="color"){r+=`${a}_${c}`,t=l;continue}}else if(a==="ta"||a==="math"){r+=c,t=l;continue}}}r+=g,t=m;continue}r+=h,t+=1}return r}function oi(n,e){const s=String(n||"");let i="",r=null,u=0;for(;u<s.length;){const t=s[u];if(r){i+=t,t===r&&s[u-1]!=="\\"&&(r=null),u+=1;continue}if(t==="'"||t==='"'){r=t,i+=t,u+=1;continue}if(Xe(t)){let h=u+1;for(;h<s.length&&Ze(s[h]);)h+=1;const m=s.slice(u,h);let g=u-1;for(;g>=0&&/\s/.test(s[g]);)g-=1;if(g>=0&&s[g]==="."){i+=m,u=h;continue}let a=h;for(;a<s.length&&/\s/.test(s[a]);)a+=1;if(s[a]==="["&&e){let o=0,f=a,l=null;for(;f<s.length;f++){const c=s[f];if(l){c===l&&s[f-1]!=="\\"&&(l=null);continue}if(c==="'"||c==='"'){l=c;continue}if(c==="[")o+=1;else if(c==="]"&&(o-=1,o===0))break}if(f<s.length&&o===0){const c=s.slice(a+1,f).trim();if(c){i+=`prev(${m}, __hist_index(${c}))`,u=f+1;continue}}}else if(s[a]==="["){let o=a+1;for(;o<s.length&&/\s/.test(s[o]);)o+=1;let f=1;s[o]==="-"&&(f=-1,o+=1);let l=o;for(;l<s.length&&/[0-9]/.test(s[l]);)l+=1;const c=s.slice(o,l);for(;l<s.length&&/\s/.test(s[l]);)l+=1;if(c&&s[l]==="]"){const d=f*Number(c);if(Number.isFinite(d)&&d>=1){i+=`prev(${m}, ${Math.floor(d)})`,u=l+1;continue}if(Number.isFinite(d)&&d===0){i+=m,u=l+1;continue}}}i+=m,u=h;continue}i+=t,u+=1}return i}function ai(n){if(!n)return 0;let e=2166136261;for(let i=0;i<n.length;i++)e^=n.charCodeAt(i),e=Math.imul(e,16777619);const s=e>>>0;return s===0?1:s}function ci(n){const e=String(n||"");let s="",i=0;for(;i<e.length;){const r=e[i];if(r==='"'||r==="'"){const u=r;i+=1;let t="",h=!1;for(;i<e.length;){const m=e[i];if(h){t+=m,h=!1,i+=1;continue}if(m==="\\"){h=!0,i+=1;continue}if(m===u){i+=1;break}t+=m,i+=1}s+=String(ai(t));continue}s+=r,i+=1}return s}function Ut(n,e){const s=!!(e!=null&&e.pineV2);let i=si(String(n||""));return i=ii(i),i=ri(i,s),s||(i=ci(i)),i=oi(i,s),{expr:i}}function Je(n){return typeof n=="number"&&Number.isFinite(n)}function Ee(n,e,s){const i=n[s];if(Je(i))return i;const r=e[s];return Je(r)?r:NaN}function Ie(n,e,s){const i=n[s];if(Je(i))return i;const r=e[s];return Je(r)?r:NaN}function Dt(n,e,s,i){let r=-1,u=-1/0;for(let t=s;t<=i;t++){const h=Ee(n,e,t);Number.isFinite(h)&&h>u&&(u=h,r=t)}return r}function Ot(n,e,s,i){let r=-1,u=1/0;for(let t=s;t<=i;t++){const h=Ie(n,e,t);Number.isFinite(h)&&h<u&&(u=h,r=t)}return r}function li(n,e,s,i,r){const u=Math.min(n.length,e.length,s.length);if(u<=1)return null;const t=Math.min(u-1,Math.max(0,Math.trunc(i))),h=Math.max(2,Math.trunc(r.lookback||200)),m=Math.max(0,t-h+1),g=r.direction==="down"?"down":"up";if((r.method==="pivots"?"pivots":"extremes")==="pivots"){const d=Math.max(1,Math.floor(Number(r.pivotLeft??3))),N=Math.max(1,Math.floor(Number(r.pivotRight??3))),v=t;if(v<N)return null;const p=[],S=[],w=y=>{const $=Ee(n,s,y);if(!Number.isFinite($))return null;const I=Math.max(0,y-d),R=Math.min(v,y+N);if(R<y+N)return null;for(let E=I;E<=R;E++){if(E===y)continue;const C=Ee(n,s,E);if(!Number.isFinite(C)||C>=$)return null}return $},b=y=>{const $=Ie(e,s,y);if(!Number.isFinite($))return null;const I=Math.max(0,y-d),R=Math.min(v,y+N);if(R<y+N)return null;for(let E=I;E<=R;E++){if(E===y)continue;const C=Ie(e,s,E);if(!Number.isFinite(C)||C<=$)return null}return $},M=Math.max(m,0),F=Math.min(t-N,t);for(let y=M;y<=F;y++){const $=w(y);$!=null&&p.push({index:y,value:$});const I=b(y);I!=null&&S.push({index:y,value:I})}const A=p.length?p[p.length-1]:null,_=S.length?S[S.length-1]:null;if(!(!A||!_))if(g==="up"){let y=null;for(let $=S.length-1;$>=0;$--)if(S[$].index<A.index){y=S[$];break}if(y)return{fromIndex:y.index,toIndex:A.index,fromValue:y.value,toValue:A.value}}else{let y=null;for(let $=p.length-1;$>=0;$--)if(p[$].index<_.index){y=p[$];break}if(y)return{fromIndex:y.index,toIndex:_.index,fromValue:y.value,toValue:_.value}}}if(g==="up"){const d=Dt(n,s,m,t);if(d<0)return null;const N=Ot(e,s,m,d);if(N<0)return null;const v=Ie(e,s,N),p=Ee(n,s,d);return[v,p].every(Number.isFinite)?{fromIndex:N,toIndex:d,fromValue:v,toValue:p}:null}const o=Ot(e,s,m,t);if(o<0)return null;const f=Dt(n,s,m,o);if(f<0)return null;const l=Ie(e,s,o),c=Ee(n,s,f);return[l,c].every(Number.isFinite)?{fromIndex:f,toIndex:o,fromValue:c,toValue:l}:null}function ui(n,e,s,i){const r=Math.min(n.length,e.length,s.length),u=new Array(r),t=new Array(r),h=new Array(r),m=new Array(r),g=new Array(r),a=new Array(r),o=new Array(r);for(let f=0;f<r;f++){const l=li(n,e,s,f,i);if(!l){u[f]=void 0,t[f]=void 0,h[f]=void 0,m[f]=void 0,g[f]=void 0,a[f]=void 0,o[f]=void 0;continue}u[f]=l.fromValue,t[f]=l.toValue,h[f]=l.fromIndex,m[f]=l.toIndex,g[f]=l.fromValue,o[f]=l.toValue,a[f]=l.fromValue+(l.toValue-l.fromValue)*.5}return{from:u,to:t,fromIndex:h,toIndex:m,lvl0:g,lvl50:a,lvl100:o}}function fi(n){const{seriesMap:e,calcDefs:s,len:i,params:r,lastPrevSource:u,resolveNum:t,onError:h}=n,m=r||{},g=(m==null?void 0:m.__pinev2)===1,a=o=>g?Ut(o,{pineV2:!0}).expr:String(o??"");for(const o of s){const f=o.name||o.type;if(!f)continue;const l=String(f).replace(/\s+/g,"_").toLowerCase(),c=String(o.type||"").toLowerCase();if(c!=="security"){if(c==="sma"){const d=o.source||"close";e[l]=he(e[d]||e.close,Math.max(1,t(o.period,`${l}_period`,14)))}else if(c==="smma"){const d=o.source||"close";e[l]=Tt(e[d]||e.close,Math.max(1,t(o.period,`${l}_period`,13)))}else if(c==="ema"){const d=o.source||"close";e[l]=J(e[d]||e.close,Math.max(1,t(o.period,`${l}_period`,14)))}else if(c==="wma"){const d=o.source||"close";e[l]=Vt(e[d]||e.close,Math.max(1,t(o.period,`${l}_period`,14)))}else if(c==="rsi"){const d=o.source||"close";e[l]=Bt(e[d]||e.close,Math.max(1,t(o.period,`${l}_period`,14)))}else if(c==="bbands"||c==="bollinger"||c==="bollinger_bands"){const d=o.source||"close",N=Math.max(1,t(o.period,`${l}_period`,20)),v=Math.max(.1,t(o.std,`${l}_std`,t(o.deviation,`${l}_deviation`,2))),{mid:p,upper:S,lower:w}=en(e[d]||e.close,N,v);e[l+"_mid"]=p,e[l+"_upper"]=S,e[l+"_lower"]=w}else if(c==="atr"){const d=Math.max(1,t(o.period,`${l}_period`,14));e[l]=Re(e.high,e.low,e.close,d)}else if(c==="obv")e[l]=kn(e.close,e.volume);else if(c==="cci"){const d=Math.max(1,t(o.period,`${l}_period`,20));e[l]=Fn(e.high,e.low,e.close,d)}else if(c==="mfi"){const d=Math.max(1,t(o.period,`${l}_period`,14));e[l]=yn(e.high,e.low,e.close,e.volume,d)}else if(c==="ao")e[l]=Kt(e.high,e.low);else if(c==="trix"){const d=Math.max(1,t(o.period,`${l}_period`,12));e[l]=zt(e.close,d)}else if(c==="vwap")e[l]=_n(e.close,e.volume);else if(c==="vwma"){const d=Math.max(1,t(o.period,`${l}_period`,20));e[l]=Gt(e.close,e.volume,d)}else if(c==="macd"){const d=(o.source||"close").replace(/\s+/g,"_").toLowerCase(),N=Math.max(1,Number(o.fast)||12),v=Math.max(1,Number(o.slow)||26),p=Math.max(1,Number(o.signal)||9),S=e[d]||e.close,w=J(S,N),b=J(S,v),M=new Array(i);for(let y=0;y<i;y++)M[y]=w[y]===void 0||b[y]===void 0?void 0:w[y]-b[y];const F=J(M,p),A=new Array(i),_=new Array(i);for(let y=0;y<i;y++){const $=M[y],I=F[y];A[y]=typeof I=="number"&&Number.isFinite(I)?I:void 0,_[y]=$!==void 0&&I!==void 0?$-I:void 0}e.macd_line=M,e.macd_signal=A,e.macd_hist=_}else if(c==="supertrend"){const d=Math.max(1,Number(o.period)||10),N=Math.max(.1,Number(o.factor)||3);e[l]=Ht(e.high,e.low,e.close,d,N)}else if(c==="kc"||c==="keltner"){const d=Math.max(1,Number(o.period)||20),N=Math.max(.1,Number(o.mult)||2),v=Wt(e.high,e.low,e.close,d,N);e[l+"_mid"]=v.mid,e[l+"_upper"]=v.upper,e[l+"_lower"]=v.lower}else if(c==="donchian"){const d=Math.max(1,Number(o.period)||20),N=Yt(e.high,e.low,d);e[l+"_mid"]=N.mid,e[l+"_upper"]=N.upper,e[l+"_lower"]=N.lower}else if(c==="atr_bands"){const d=Math.max(1,Number(o.period)||14),N=Math.max(.1,Number(o.mult)||2),v=Re(e.high,e.low,e.close,d),p=new Array(i),S=new Array(i);for(let w=0;w<i;w++){const b=v[w],M=e.close[w];p[w]=b!=null&&M!=null?M+N*b:void 0,S[w]=b!=null&&M!=null?M-N*b:void 0}e[l+"_upper"]=p,e[l+"_lower"]=S}else if(c==="zscore"){const d=Math.max(1,Number(o.period)||20),N=o.source||"close";e[l]=Mn(e[N]||e.close,d)}else if(c==="volume_delta")e[l]=Sn(e.close,e.volume);else if(c==="cum_delta"){const d=Sn(e.close,e.volume);e[l]=Xt(d)}else if(c==="vwap_bands"){const d=Math.max(1,Number(o.period)||20),N=_n(e.close,e.volume),{upper:v,lower:p}=en(Array.from(N).map(S=>S),d,Math.max(.1,Number(o.std)||2));e[l+"_mid"]=Array.from(N),e[l+"_upper"]=v,e[l+"_lower"]=p}else if(c==="linreg_channel"){const d=Math.max(1,Number(o.period)||20),N=o.source||"close",v=Zt(e[N]||e.close,d);e[l+"_mid"]=v.mid,e[l+"_upper"]=v.upper,e[l+"_lower"]=v.lower}else if(c==="evwma"){const d=Math.max(1,Number(o.period)||20);e[l]=An(e.close,e.volume,d)}else if(c==="sar"){const d=Math.max(.001,Number(o.step)||.02),N=Math.max(d,Number(o.max)||.2),v=e.high,p=e.low,S=new Array(i);let w=d,b=v[0],M=p[0],F=!0;for(let A=1;A<i;A++){const _=v[A]??NaN,y=p[A]??NaN;if(!Number.isFinite(_)||!Number.isFinite(y)){S[A]=void 0;continue}let $=M;F?($=M+w*(b-M),_>b&&(b=_,w=Math.min(N,w+d)),$>y&&(F=!1,$=b,b=y,w=d)):($=M-w*(M-b),y<b&&(b=y,w=Math.min(N,w+d)),$<_&&(F=!0,$=b,b=_,w=d)),S[A]=$,M=$}S[0]=M,e.sar=S}else if(c==="stoch"){const d=Number(o.kPeriod)||14,N=Number(o.dPeriod)||3,v=[],p=[];for(let w=0;w<i;w++){const b=Math.max(0,w-d+1);let M=-1/0,F=1/0;for(let $=b;$<=w;$++){const I=e.high[$]??e.close[$]??NaN,R=e.low[$]??e.close[$]??NaN;I>M&&(M=I),R<F&&(F=R)}const A=e.close[w]??NaN,_=M-F,y=_===0?void 0:100*((A-F)/_);v.push(y)}const S=he(v.map(w=>w??NaN),N);for(let w=0;w<i;w++)p.push(isNaN(S[w])?void 0:S[w]);e[l+"_k"]=v,e[l+"_d"]=p}else if(c==="roc"){const d=o.source||"close",N=e[d]||e.close,v=Math.max(1,Number(o.period)||10),p=new Array(i);for(let S=0;S<i;S++){const w=N[S],b=N[S-v];w===void 0||b===void 0||b===0?p[S]=void 0:p[S]=(w/b-1)*100}e[l]=p}else if(c==="ichimoku"){const d=Math.max(1,Number(o.tenkan)||9),N=Math.max(1,Number(o.kijun)||26),v=Math.max(1,Number(o.senkouB)||52),p=N,S=new Array(i),w=new Array(i),b=new Array(i),M=new Array(i),F=new Array(i),A=new Array(i),_=new Array(i),y=e.high,$=e.low,I=e.close,R=(E,C)=>{let U=-1/0,D=1/0;const T=Math.max(0,E-C+1);for(let G=T;G<=E;G++){const Qe=y[G]??I[G]??NaN,xe=$[G]??I[G]??NaN;Qe>U&&(U=Qe),xe<D&&(D=xe)}return{hi:U,lo:D}};for(let E=0;E<i;E++){if(E>=d-1){const{hi:C,lo:U}=R(E,d);S[E]=(C+U)/2}if(E>=N-1){const{hi:C,lo:U}=R(E,N);w[E]=(C+U)/2}if(S[E]!==void 0&&w[E]!==void 0&&(b[E]=(S[E]+w[E])/2),E>=v-1){const{hi:C,lo:U}=R(E,v);M[E]=(C+U)/2}_[E]=E+p<i?I[E+p]:void 0}for(let E=0;E<i;E++)F[E]=E>=p?b[E-p]:void 0,A[E]=E>=p?M[E-p]:void 0;e.tenkan=S,e.kijun=w,e.spana=F,e.spanb=A,e.chikou=_}else if(c==="pivot_high"){const d=Math.max(0,Number(o.left)||3),N=Math.max(0,Number(o.right)||3),v=new Array(i);for(let p=0;p<i;p++){const S=e.high[p]??e.close[p]??NaN;if(!Number.isFinite(S)){v[p]=void 0;continue}let w=!0;const b=Math.max(0,p-d),M=Math.min(i-1,p+N);for(let F=b;F<=M;F++){if(F===p)continue;const A=e.high[F]??e.close[F]??NaN;if(!Number.isFinite(A)){w=!1;break}if(A>=S){w=!1;break}}v[p]=w?S:void 0}e[l]=v}else if(c==="pivot_low"){const d=Math.max(0,Number(o.left)||3),N=Math.max(0,Number(o.right)||3),v=new Array(i);for(let p=0;p<i;p++){const S=e.low[p]??e.close[p]??NaN;if(!Number.isFinite(S)){v[p]=void 0;continue}let w=!0;const b=Math.max(0,p-d),M=Math.min(i-1,p+N);for(let F=b;F<=M;F++){if(F===p)continue;const A=e.low[F]??e.close[F]??NaN;if(!Number.isFinite(A)){w=!1;break}if(A<=S){w=!1;break}}v[p]=w?S:void 0}e[l]=v}else if(c==="auto_fib"||c==="autofib"){const d=Math.max(2,Math.floor(t(o.lookback,`${l}_lookback`,200))),v=String(o.direction||"up").trim().toLowerCase()==="down"?"down":"up",p=String(o.method||o.mode||"extremes").trim().toLowerCase(),S=p==="pivots"||p==="pivot"||p==="swing"?"pivots":"extremes",w=Math.max(1,Math.floor(Number(o.pivotLeft??o.left??3))),b=Math.max(1,Math.floor(Number(o.pivotRight??o.right??3))),M=ui(e.high,e.low,e.close,{lookback:d,direction:v,method:S,pivotLeft:w,pivotRight:b});e[`${l}_from`]=M.from,e[`${l}_to`]=M.to,e[`${l}_from_idx`]=M.fromIndex,e[`${l}_to_idx`]=M.toIndex,e[`${l}_0`]=M.lvl0,e[`${l}_50`]=M.lvl50,e[`${l}_100`]=M.lvl100}else if(c==="last_value"){const d=String(o.source||"close").replace(/\s+/g,"_").toLowerCase(),N=e[d]||e.close,v=new Array(i);let p;for(let S=0;S<i;S++){const w=N[S];w!=null&&Number.isFinite(w)&&(p=w),v[S]=p}e[l]=v,u[l]=d}else if(c==="prev_value"){const d=String(o.source||"close").replace(/\s+/g,"_").toLowerCase(),N=e[d]||e.close,v=new Array(i);let p,S;for(let w=0;w<i;w++){const b=N[w];if(b!=null&&Number.isFinite(b)){const M=b;(p===void 0||M!==p)&&(S=p,p=M)}v[w]=S}e[l]=v,u[l]=d}else if(c==="line_value"){const d=String(o.startValue||"").replace(/\s+/g,"_").toLowerCase(),N=String(o.endValue||"").replace(/\s+/g,"_").toLowerCase();let p=u[d]||u[N]||"";p||(/pl|low/i.test(d)||/pl|low/i.test(N)?p="pl":(/ph|high/i.test(d)||/ph|high/i.test(N))&&(p="ph"));const S=e[p],w=new Array(i);if(S){const b=[];for(let M=i-1;M>=0&&b.length<2;M--){const F=S[M];F!=null&&Number.isFinite(F)&&b.push(M)}if(b.reverse(),b.length===2){const M=b[0],F=b[1],A=S[M],_=S[F];if(Number.isFinite(A)&&Number.isFinite(_)&&F!==M){const y=(_-A)/(F-M),$=A-y*M,I=Math.max(1,Number(o.lookback)||i),R=Math.max(0,F-I);for(let E=0;E<i;E++)w[E]=E>=R?y*E+$:void 0}}}e[l]=w}else if(c==="compare"){const d=String(o.left??"").trim(),N=String(o.right??"").trim(),v=String(o.op||">"),p=/^[-+]?\d+(?:\.\d+)?$/.test(d),S=/^[-+]?\d+(?:\.\d+)?$/.test(N),w=d.replace(/\s+/g,"_").toLowerCase(),b=N.replace(/\s+/g,"_").toLowerCase(),M=p?null:e[w]||e.close,F=S?null:e[b]||e.close,A=p?Number(d):NaN,_=S?Number(N):NaN,y=new Array(i);for(let $=0;$<i;$++){const I=p?A:(M==null?void 0:M[$])??NaN,R=S?_:(F==null?void 0:F[$])??NaN;if(!Number.isFinite(I)||!Number.isFinite(R)){y[$]=0;continue}let E=!1;switch(v){case">":E=I>R;break;case"<":E=I<R;break;case">=":E=I>=R;break;case"<=":E=I<=R;break;case"==":E=Math.abs(I-R)<1e-9;break;default:E=I>R;break}y[$]=E?1:0}e[l]=y}else if(typeof o.expr=="string"&&String(o.expr).trim().length)try{const d={};Object.entries(e).forEach(([S,w])=>{const b=new Float32Array(i);for(let M=0;M<i;M++)b[M]=w[M]??NaN;d[S.replace(/\s+/g,"_").toLowerCase()]=b});const N=Te([{name:l,expr:a(String(o.expr).replace(/\$\{([^}]+)\}/g,(S,w)=>String(m[w]??S)))}],d,m),v=new Array(i),p=N[l];for(let S=0;S<i;S++){const w=p==null?void 0:p[S];v[S]=Number.isFinite(w)?w:void 0}e[l]=v}catch(d){if(h){const N=(d==null?void 0:d.message)!=null?String(d.message):String(d);h(`Expression error: ${N}`,d)}}}}}function hi(n){if(!n)return 0;let e=2166136261;for(let i=0;i<n.length;i++)e^=n.charCodeAt(i),e=Math.imul(e,16777619);const s=e>>>0;return s===0?1:s}function mi(n){const e=String(n||"");let s="",i=0;for(;i<e.length;){const r=e[i];if(r==='"'||r==="'"){const u=r;i+=1;let t="",h=!1;for(;i<e.length;){const m=e[i];if(h){t+=m,h=!1,i+=1;continue}if(m==="\\"){h=!0,i+=1;continue}if(m===u){i+=1;break}t+=m,i+=1}s+=String(hi(t));continue}s+=r,i+=1}return s}function ge(n,e){const s=new Array(e);if(!n)return s.fill(void 0);for(let i=0;i<e;i++)s[i]=n[i];return s}function pn(n,e){const s={};return Object.entries(n).forEach(([i,r])=>{const u=i.replace(/\s+/g,"_").toLowerCase(),t=new Float32Array(e);for(let h=0;h<e;h++)t[h]=r[h]??NaN;s[u]=t}),s}function Le(n,e){const s=new Array(e);if(!n)return s;for(let i=0;i<e;i++){const r=n[i];s[i]=Number.isFinite(r)?r:void 0}return s}function di(n,e,s,i){if(typeof e=="number"&&Number.isFinite(e))return e;if(typeof e=="string"){const r=Number(e);if(Number.isFinite(r))return r;const u=e.match(/^\$\{([^}]+)\}$/),t=u?u[1]:e,h=n[t],m=typeof h=="number"?h:Number(h);if(Number.isFinite(m))return m}if(s&&n[s]!=null){const r=n[s],u=typeof r=="number"?r:Number(r);if(Number.isFinite(u))return u}return i??0}self.onmessage=n=>{var i,r;const e=n.data,s=(e==null?void 0:e.id)||"unknown";try{if(!(e!=null&&e.base)||!(e!=null&&e.calc)||!(e!=null&&e.series)||!(e!=null&&e.stateSeries)){const F={id:s,seriesMap:{},error:"Invalid request"};self.postMessage(F);return}const u=((i=e.base.close)==null?void 0:i.length)??0,t={};t.open=ge(e.base.open,u),t.high=ge(e.base.high,u),t.low=ge(e.base.low,u),t.close=ge(e.base.close,u),t.volume=ge(e.base.volume,u),t.time=ge(e.base.time,u);const h=new Array(u);for(let F=0;F<u;F++)h[F]=F;if(t.bar_index=h,e.extraSeries&&Object.entries(e.extraSeries).forEach(([F,A])=>{t[F.replace(/\s+/g,"_").toLowerCase()]=ge(A,u)}),e.params&&typeof e.params=="object"){const F=A=>{if(!t[A]){if(A==="hl2"){const _=new Array(u);for(let y=0;y<u;y++){const $=t.high[y],I=t.low[y];_[y]=$==null||I==null||!Number.isFinite($)||!Number.isFinite(I)?void 0:($+I)/2}t[A]=_}else if(A==="hlc3"){const _=new Array(u);for(let y=0;y<u;y++){const $=t.high[y],I=t.low[y],R=t.close[y];_[y]=$==null||I==null||R==null?void 0:($+I+R)/3}t[A]=_}else if(A==="ohlc4"){const _=new Array(u);for(let y=0;y<u;y++){const $=t.open[y],I=t.high[y],R=t.low[y],E=t.close[y];_[y]=$==null||I==null||R==null||E==null?void 0:($+I+R+E)/4}t[A]=_}}};Object.entries(e.params).forEach(([A,_])=>{if(typeof _!="string")return;const y=A.replace(/\s+/g,"_").toLowerCase(),$=String(_).replace(/\s+/g,"_").toLowerCase();F($),t[$]&&(t[y]=t[$])})}const m=e.stage||"full",g=((r=e.params)==null?void 0:r.__pinev2)===1,a=F=>Ut(F,{pineV2:g}).expr,o=!!e.autoSortStateSeries,f=new Map,l={emitOnce:(F,A)=>{const _=String(F||A||"").trim(),y=String(A||F||"").trim();!_||!y||f.has(_)||f.set(_,y)}},c=F=>String(F||"").replace(/\s+/g,"_").toLowerCase(),d=(F,A)=>{const _=new Set,y=mi(F),$=/[A-Za-z_$][A-Za-z0-9_$]*/g;let I;for(;I=$.exec(y);){const R=c(I[0]||"");A.has(R)&&_.add(R)}return _},N=F=>{const A=[],_=[],y=[],$=new Map;F.forEach((C,U)=>{const D=c(String((C==null?void 0:C.name)||`series_${U}`));y[U]=D,$.set(D,String((C==null?void 0:C.expr)??""))});const I=new Set($.keys()),R=new Set;$.forEach((C,U)=>{/\b__arr_/i.test(C)&&R.add(U)});let E=!0;for(;E;)E=!1,$.forEach((C,U)=>{if(R.has(U))return;const D=d(C,I);for(const T of D)if(R.has(T)){R.add(U),E=!0;break}});return F.forEach((C,U)=>{const D=y[U]||"";R.has(D)?_.push(C):A.push(C)}),{primary:A,arrayDependent:_}},{primary:v,arrayDependent:p}=N(e.series||[]),S=(e.stateSeries||[]).filter(F=>/^__arr_/i.test(String((F==null?void 0:F.name)||""))),w=(e.stateSeries||[]).filter(F=>!/^__arr_/i.test(String((F==null?void 0:F.name)||"")));if(v.length&&u>0){const F=pn(t,u),A=Te(v.map((_,y)=>({name:String(_.name||`series_${y}`),expr:a(String(_.expr||"").replace(/\$\{([^}]+)\}/g,($,I)=>{var R;return String(((R=e.params)==null?void 0:R[I])??$)}))})),F,e.params,void 0,l,{loopPlans:e.loopPlans,userFunctions:e.userFunctions});Object.entries(A).forEach(([_,y])=>{const $=_.replace(/\s+/g,"_").toLowerCase();t[$]=Le(y,u)})}const b={};if(fi({seriesMap:t,calcDefs:e.calc,len:u,params:e.params,lastPrevSource:b,resolveNum:(F,A,_)=>di(e.params||{},F,A,_)}),m!=="calc_only"&&v.length&&u>0){const F=new Set(v.map((y,$)=>String(y.name||`series_${$}`)).map(y=>y.replace(/\s+/g,"_").toLowerCase()).filter(Boolean)),A={};Object.entries(t).forEach(([y,$])=>{const I=String(y||"").replace(/\s+/g,"_").toLowerCase();if(F.has(I))return;const R=new Float32Array(u);for(let E=0;E<u;E++)R[E]=$[E]??NaN;A[I]=R});const _=Te(v.map((y,$)=>({name:String(y.name||`series_${$}`),expr:a(String(y.expr||"").replace(/\$\{([^}]+)\}/g,(I,R)=>{var E;return String(((E=e.params)==null?void 0:E[R])??I)}))})),A,e.params,void 0,l,{loopPlans:e.loopPlans,userFunctions:e.userFunctions});Object.entries(_).forEach(([y,$])=>{const I=y.replace(/\s+/g,"_").toLowerCase();t[I]=Le($,u)})}if(m!=="calc_only"&&S.length&&u>0){const F=pn(t,u),A=Pt(S.map((_,y)=>({name:String((_==null?void 0:_.name)||`state_${y}`),initExpr:(_==null?void 0:_.initExpr)!=null?a(String(_.initExpr).replace(/\$\{([^}]+)\}/g,($,I)=>{var R;return String(((R=e.params)==null?void 0:R[I])??$)})):void 0,updateExpr:a(String((_==null?void 0:_.updateExpr)??(_==null?void 0:_.expr)??"").replace(/\$\{([^}]+)\}/g,($,I)=>{var R;return String(((R=e.params)==null?void 0:R[I])??$)})),selfMode:_==null?void 0:_.selfMode})),F,e.params,void 0,{autoSort:o,diagnostics:l,loopPlans:e.loopPlans,userFunctions:e.userFunctions});Object.entries(A).forEach(([_,y])=>{const $=_.replace(/\s+/g,"_").toLowerCase();t[$]=Le(y,u)})}if(m!=="calc_only"&&p.length&&u>0){const F=new Set(p.map((y,$)=>String(y.name||`series_${$}`)).map(y=>y.replace(/\s+/g,"_").toLowerCase()).filter(Boolean)),A={};Object.entries(t).forEach(([y,$])=>{const I=String(y||"").replace(/\s+/g,"_").toLowerCase();if(F.has(I))return;const R=new Float32Array(u);for(let E=0;E<u;E++)R[E]=$[E]??NaN;A[I]=R});const _=Te(p.map((y,$)=>({name:String(y.name||`series_${$}`),expr:a(String(y.expr||"").replace(/\$\{([^}]+)\}/g,(I,R)=>{var E;return String(((E=e.params)==null?void 0:E[R])??I)}))})),A,e.params,void 0,l,{loopPlans:e.loopPlans,userFunctions:e.userFunctions});Object.entries(_).forEach(([y,$])=>{const I=y.replace(/\s+/g,"_").toLowerCase();t[I]=Le($,u)})}if(m!=="calc_only"&&w.length&&u>0){const F=pn(t,u),A=Pt(w.map((_,y)=>({name:String((_==null?void 0:_.name)||`state_${y}`),initExpr:(_==null?void 0:_.initExpr)!=null?a(String(_.initExpr).replace(/\$\{([^}]+)\}/g,($,I)=>{var R;return String(((R=e.params)==null?void 0:R[I])??$)})):void 0,updateExpr:a(String((_==null?void 0:_.updateExpr)??(_==null?void 0:_.expr)??"").replace(/\$\{([^}]+)\}/g,($,I)=>{var R;return String(((R=e.params)==null?void 0:R[I])??$)})),selfMode:_==null?void 0:_.selfMode})),F,e.params,void 0,{autoSort:o,diagnostics:l,loopPlans:e.loopPlans,userFunctions:e.userFunctions});Object.entries(A).forEach(([_,y])=>{const $=_.replace(/\s+/g,"_").toLowerCase();t[$]=Le(y,u)})}const M={id:s,seriesMap:t,lastPrevSource:b,diagnostics:Array.from(f.values())};self.postMessage(M)}catch(u){const t={id:s,seriesMap:{},error:String((u==null?void 0:u.message)||u)};self.postMessage(t)}}})();
