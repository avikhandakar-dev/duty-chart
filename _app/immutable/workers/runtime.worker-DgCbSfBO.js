var ft=Object.defineProperty;var ht=(j,z,D)=>z in j?ft(j,z,{enumerable:!0,configurable:!0,writable:!0,value:D}):j[z]=D;var ie=(j,z,D)=>ht(j,typeof z!="symbol"?z+"":z,D);(function(){"use strict";const j=a=>a>="0"&&a<="9",z=a=>a>="a"&&a<="z"||a>="A"&&a<="Z"||a==="_"||a==="$";class D{constructor(e){ie(this,"pos",0);this.input=e}next(){const e=this.input,c=e.length;for(;this.pos<c&&/\s/.test(e[this.pos]??"");)this.pos++;if(this.pos>=c)return{type:"eof",start:this.pos,end:this.pos};const n=e[this.pos],t=this.pos;if(n==='"'||n==="'"){const u=n;this.pos++;let f="",r=!1;for(;this.pos<c;){const s=e[this.pos];if(this.pos++,r){switch(s){case"n":f+=`
`;break;case"t":f+="	";break;case"r":f+="\r";break;case"\\":case"'":case'"':f+=s;break;default:f+=s;break}r=!1;continue}if(s==="\\"){r=!0;continue}if(s===u)break;f+=s}return{type:"string",value:f,start:t,end:this.pos}}if(j(n)||n==="."&&j(e[this.pos+1]??"")){let u=n===".";for(this.pos++;this.pos<c;){const f=e[this.pos];if(j(f))this.pos++;else if(f==="."&&!u)u=!0,this.pos++;else break}if(e[this.pos]==="e"||e[this.pos]==="E"){let r=this.pos+1;(e[r]==="+"||e[r]==="-")&&r++;const s=r;for(;r<c&&j(e[r]);)r++;r>s&&(this.pos=r)}return{type:"number",value:e.slice(t,this.pos),start:t,end:this.pos}}if(z(n)){for(this.pos++;this.pos<c;){const r=e[this.pos];if(z(r)||j(r))this.pos++;else break}const u=e.slice(t,this.pos),f=u.toLowerCase();return f==="and"?{type:"and",start:t,end:this.pos}:f==="or"?{type:"or",start:t,end:this.pos}:f==="not"?{type:"not",start:t,end:this.pos}:f==="true"||f==="false"?{type:"boolean",value:f,start:t,end:this.pos}:{type:"identifier",value:u,start:t,end:this.pos}}switch(this.pos++,n){case">":return e[this.pos]==="="?(this.pos++,{type:"gte",start:t,end:this.pos}):{type:"gt",start:t,end:this.pos};case"<":return e[this.pos]==="="?(this.pos++,{type:"lte",start:t,end:this.pos}):{type:"lt",start:t,end:this.pos};case"=":if(e[this.pos]==="=")return this.pos++,{type:"eq",start:t,end:this.pos};throw new Error(`Unexpected '=' at position ${t}`);case"!":if(e[this.pos]==="=")return this.pos++,{type:"neq",start:t,end:this.pos};throw new Error(`Unexpected '!' at position ${t}`);case"+":return{type:"plus",start:t,end:this.pos};case"-":return{type:"minus",start:t,end:this.pos};case"*":return{type:"star",start:t,end:this.pos};case"/":return{type:"slash",start:t,end:this.pos};case"%":return{type:"percent",start:t,end:this.pos};case"(":return{type:"lparen",start:t,end:this.pos};case")":return{type:"rparen",start:t,end:this.pos};case",":return{type:"comma",start:t,end:this.pos};case"?":return{type:"qmark",start:t,end:this.pos};case":":return{type:"colon",start:t,end:this.pos};default:throw new Error(`Unexpected character "${n}" at position ${t}`)}}}class T extends Error{constructor(e,c){super(e),this.position=c,this.name="ParseError"}}class ve{constructor(e){ie(this,"current");this.tokenizer=e,this.current=e.next()}eat(e){if(this.current.type!==e)throw new T(`Expected ${e} but found ${this.current.type}`,this.current.start);const c=this.current;return this.current=this.tokenizer.next(),c}match(e){return this.current.type===e?(this.current=this.tokenizer.next(),!0):!1}parseExpression(){return this.parseTernary()}parseTernary(){const e=this.parseOr();if(this.current.type==="qmark"){this.current=this.tokenizer.next();const c=this.parseExpression();this.eat("colon");const n=this.parseExpression();return{kind:"CallExpression",callee:"iff",args:[e,c,n]}}return e}parseOr(){let e=this.parseAnd();for(;this.current.type==="or";){this.current=this.tokenizer.next();const c=this.parseAnd();e={kind:"BinaryExpression",operator:"or",left:e,right:c}}return e}parseAnd(){let e=this.parseComparison();for(;this.current.type==="and";){this.current=this.tokenizer.next();const c=this.parseComparison();e={kind:"BinaryExpression",operator:"and",left:e,right:c}}return e}parseComparison(){let e=this.parseAddSub();for(;this.current.type==="gt"||this.current.type==="lt"||this.current.type==="gte"||this.current.type==="lte"||this.current.type==="eq"||this.current.type==="neq";){const c=this.current;this.current=this.tokenizer.next();const n=this.parseAddSub();let t="==";c.type==="gt"?t=">":c.type==="lt"?t="<":c.type==="gte"?t=">=":c.type==="lte"?t="<=":c.type==="neq"&&(t="!="),e={kind:"BinaryExpression",operator:t,left:e,right:n}}return e}parseAddSub(){let e=this.parseTerm();for(;this.current.type==="plus"||this.current.type==="minus";){const c=this.current;this.current=this.tokenizer.next();const n=this.parseTerm();e={kind:"BinaryExpression",operator:c.type==="plus"?"+":"-",left:e,right:n}}return e}parseTerm(){let e=this.parseFactor();for(;this.current.type==="star"||this.current.type==="slash"||this.current.type==="percent";){const c=this.current;this.current=this.tokenizer.next();const n=this.parseFactor();e={kind:"BinaryExpression",operator:c.type==="star"?"*":c.type==="slash"?"/":"%",left:e,right:n}}return e}parseFactor(){if(this.current.type==="not")return this.current=this.tokenizer.next(),{kind:"UnaryExpression",operator:"not",expr:this.parseFactor()};if(this.current.type==="plus"||this.current.type==="minus"){const e=this.current.type==="minus";this.current=this.tokenizer.next();const c=this.parseFactor();return e?{kind:"BinaryExpression",operator:"*",left:{kind:"NumberLiteral",value:-1},right:c}:c}return this.parsePrimary()}parsePrimary(){const e=this.current;switch(e.type){case"number":{this.current=this.tokenizer.next();const c=Number(e.value);if(!Number.isFinite(c))throw new T("Invalid number literal",e.start);return{kind:"NumberLiteral",value:c}}case"string":return this.current=this.tokenizer.next(),{kind:"StringLiteral",value:String(e.value??"")};case"boolean":return this.current=this.tokenizer.next(),{kind:"NumberLiteral",value:String(e.value||"").toLowerCase()==="true"?1:0};case"identifier":{this.current=this.tokenizer.next();const c=(e.value||"").toString();if(this.current.type==="lparen"){this.eat("lparen");const n=[];if(this.current.type!=="rparen")for(;n.push(this.parseExpression()),!!this.match("comma"););return this.eat("rparen"),{kind:"CallExpression",callee:c,args:n}}return{kind:"Identifier",name:c}}case"lparen":{this.eat("lparen");const c=this.parseExpression();return this.eat("rparen"),c}default:throw new T(`Unexpected token ${e.type}`,e.start)}}}function ne(a){const e=new ve(new D(a)),c=e.parseExpression();if(e.current.type!=="eof")throw new T("Unexpected input after end of expression",e.current.start);return c}function B(a){if(!a)return 0;let e=2166136261;for(let n=0;n<a.length;n++)e^=a.charCodeAt(n),e=Math.imul(e,16777619);const c=e>>>0;return c===0?1:c}function oe(a){return Number.isFinite(a)?a.toFixed(2):""}function ye(a,e){if(!Number.isFinite(a))return"";if(!e)return oe(a);const c=String(e),n=c.includes("%"),t=c.split(".");let u=0;t.length>1&&(u=t[1].replace(/[^0-9#]/g,"").length);const f=n?a*100:a,r=u>0?f.toFixed(u):String(Math.round(f));return n?`${r}%`:r}class F extends Error{constructor(e){super(e),this.name="ExpressionEngineError"}}function ke(a,e){const c=a.length,n=new Float32Array(c);let t=0;for(let u=0;u<c;u++){const f=a[u];if(Number.isFinite(f)&&(t+=f),u>=e){const r=a[u-e];Number.isFinite(r)&&(t-=r)}n[u]=u>=e-1?t:NaN}return n}function Fe(a,e){const c=a.length,n=new Float32Array(c),t=Math.max(1,Math.floor(e));for(let u=0;u<c;u++){const f=u-t,r=a[u],s=f>=0?a[f]:NaN;n[u]=Number.isFinite(r)&&Number.isFinite(s)?r-s:NaN}return n}function Me(a,e){const c=a.length,n=new Float32Array(c),t=Math.max(1,Math.floor(e));for(let u=0;u<c;u++){const f=u-t,r=a[u],s=f>=0?a[f]:NaN;!Number.isFinite(r)||!Number.isFinite(s)||s===0?n[u]=NaN:n[u]=(r-s)/s*100}return n}function _e(a,e){const c=a.length,n=new Float32Array(c),t=Math.max(1,Math.floor(e));for(let u=0;u<c;u++){const f=u-t,r=a[u],s=f>=0?a[f]:NaN;n[u]=Number.isFinite(r)&&Number.isFinite(s)?r-s:NaN}return n}function x(a,e){if(a.kind==="series")return a.value;const c=new Float32Array(e.length);return c.fill(a.value),c}function V(a){if(a.kind==="scalar")return a.value;const e=a.value;return e.length?e[e.length-1]:NaN}function ae(a,e){const c=a.length,n=new Float32Array(c);for(let t=0;t<c;t++)n[t]=e(a[t]);return n}function se(a,e,c){const n=a.length,t=new Float32Array(n);for(let u=0;u<n;u++)t[u]=c(a[u],e[u]);return t}function Se(a,e,c,n){const t=e.kind==="series",u=c.kind==="series",f=o=>Number.isFinite(o)&&o!==0;if(!t&&!u){const o=e.value,h=c.value;switch(a){case"+":return{kind:"scalar",value:o+h};case"-":return{kind:"scalar",value:o-h};case"*":return{kind:"scalar",value:o*h};case"/":return{kind:"scalar",value:h===0?NaN:o/h};case"%":return{kind:"scalar",value:h===0?NaN:o%h};case">":return{kind:"scalar",value:Number.isFinite(o)&&Number.isFinite(h)&&o>h?1:0};case"<":return{kind:"scalar",value:Number.isFinite(o)&&Number.isFinite(h)&&o<h?1:0};case">=":return{kind:"scalar",value:Number.isFinite(o)&&Number.isFinite(h)&&o>=h?1:0};case"<=":return{kind:"scalar",value:Number.isFinite(o)&&Number.isFinite(h)&&o<=h?1:0};case"==":return{kind:"scalar",value:Number.isFinite(o)&&Number.isFinite(h)&&Math.abs(o-h)<1e-9?1:0};case"!=":return{kind:"scalar",value:Number.isFinite(o)&&Number.isFinite(h)&&Math.abs(o-h)>=1e-9?1:0};case"and":return{kind:"scalar",value:f(o)&&f(h)?1:0};case"or":return{kind:"scalar",value:f(o)||f(h)?1:0}}}const r=x(e,n),s=x(c,n),i=n.length,m=new Float32Array(i);for(let o=0;o<i;o++){const h=r[o],l=s[o];switch(a){case"+":m[o]=h+l;break;case"-":m[o]=h-l;break;case"*":m[o]=h*l;break;case"/":m[o]=l===0?NaN:h/l;break;case"%":m[o]=l===0?NaN:h%l;break;case">":m[o]=Number.isFinite(h)&&Number.isFinite(l)&&h>l?1:0;break;case"<":m[o]=Number.isFinite(h)&&Number.isFinite(l)&&h<l?1:0;break;case">=":m[o]=Number.isFinite(h)&&Number.isFinite(l)&&h>=l?1:0;break;case"<=":m[o]=Number.isFinite(h)&&Number.isFinite(l)&&h<=l?1:0;break;case"==":m[o]=Number.isFinite(h)&&Number.isFinite(l)&&Math.abs(h-l)<1e-9?1:0;break;case"!=":m[o]=Number.isFinite(h)&&Number.isFinite(l)&&Math.abs(h-l)>=1e-9?1:0;break;case"and":m[o]=f(h)&&f(l)?1:0;break;case"or":m[o]=f(h)||f(l)?1:0;break}}return{kind:"series",value:m}}function Ae(a,e){const c=a.length,n=new Float32Array(c);let t=0,u=0;for(let f=0;f<c;f++){const r=a[f];if(Number.isFinite(r)&&(t+=r,u+=1),f>=e){const s=a[f-e];Number.isFinite(s)&&(t-=s,u-=1)}f>=e-1?n[f]=u>0?t/u:NaN:n[f]=NaN}return n}function xe(a,e){const c=a.length,n=new Float32Array(c),t=2/(e+1);let u;for(let f=0;f<c;f++){const r=a[f];if(!Number.isFinite(r)){n[f]=u===void 0?NaN:u;continue}if(u===void 0||!Number.isFinite(u)){u=r,n[f]=r;continue}u=r*t+u*(1-t),n[f]=u}return n}function ce(a,e){const c=a.length,n=new Float32Array(c);let t,u=0,f=0;for(let r=0;r<c;r++){const s=a[r];if(t===void 0){if(Number.isFinite(s)&&(u+=s,f+=1),f<e){n[r]=NaN;continue}t=u/e,n[r]=t;continue}Number.isFinite(s)&&(t=(t*(e-1)+s)/e),n[r]=t}return n}function Ee(a,e){const c=a.length,n=new Float32Array(c);let t,u=0,f=0,r=!1;const s=[],i=[];for(let m=0;m<c;m++){const o=a[m];if(!Number.isFinite(o)){n[m]=NaN;continue}if(t===void 0){t=o,n[m]=NaN;continue}if(!Number.isFinite(t)){t=o,n[m]=NaN;continue}const h=o-t;t=o;const l=h>0?h:0,w=h<0?-h:0;if(r)u=(u*(e-1)+l)/e,f=(f*(e-1)+w)/e;else{s.push(l),i.push(w);const b=s.length,d=Math.max(1,Math.min(e,b));u=s.reduce((N,p)=>N+p,0)/d,f=i.reduce((N,p)=>N+p,0)/d,b>=e&&(r=!0)}if(f===0)n[m]=100;else{const b=u/f;n[m]=100-100/(1+b)}}return n}function $e(a,e){const c=a.length,n=new Float32Array(c);for(let t=0;t<c;t++){if(t<e-1){n[t]=NaN;continue}let u=0,f=0;for(let i=t-e+1;i<=t;i++){const m=a[i];Number.isFinite(m)&&(u+=m,f+=1)}if(f<2){n[t]=NaN;continue}const r=u/f;let s=0;for(let i=t-e+1;i<=t;i++){const m=a[i];if(!Number.isFinite(m))continue;const o=m-r;s+=o*o}n[t]=Math.sqrt(s/f)}return n}function Ce(a,e){const c=a.length,n=new Float32Array(c);for(let t=0;t<c;t++){if(t<e-1){n[t]=NaN;continue}let u=0,f=0;for(let r=0;r<e;r++){const s=a[t-r],i=e-r;Number.isFinite(s)&&(u+=s*i,f+=i)}n[t]=f>0?u/f:NaN}return n}function Le(a,e){const c=a.length,n=new Float32Array(c);for(let t=0;t<c;t++){let u=-1/0,f=!1;const r=Math.max(0,t-e+1);for(let s=r;s<=t;s++){const i=a[s];Number.isFinite(i)&&(f=!0,i>u&&(u=i))}n[t]=f?u:NaN}return n}function Ie(a,e){const c=a.length,n=new Float32Array(c);for(let t=0;t<c;t++){let u=1/0,f=!1;const r=Math.max(0,t-e+1);for(let s=r;s<=t;s++){const i=a[s];Number.isFinite(i)&&(f=!0,i<u&&(u=i))}n[t]=f?u:NaN}return n}function Pe(a,e){const c=a.length,n=new Float32Array(c);for(let t=0;t<c;t++){if(t<e-1){n[t]=NaN;continue}let u=-1/0,f=NaN;for(let r=0;r<e;r++){const s=t-r,i=a[s];Number.isFinite(i)&&i>u&&(u=i,f=r)}n[t]=Number.isFinite(f)?f:NaN}return n}function je(a,e){const c=a.length,n=new Float32Array(c);for(let t=0;t<c;t++){if(t<e-1){n[t]=NaN;continue}let u=1/0,f=NaN;for(let r=0;r<e;r++){const s=t-r,i=a[s];Number.isFinite(i)&&i<u&&(u=i,f=r)}n[t]=Number.isFinite(f)?f:NaN}return n}function Ve(a,e){const c=a.length,n=new Float32Array(c);for(let t=0;t<c;t++){if(t<e-1){n[t]=NaN;continue}let u=0,f=0,r=0;const s=t-e+1;for(let o=s;o<=t;o++){const h=a[o];Number.isFinite(h)&&(u+=h,f+=h*h,r+=1)}if(r<2){n[t]=NaN;continue}const i=u/r,m=f/r-i*i;n[t]=Number.isFinite(m)?m:NaN}return n}function ze(a,e,c){const n=a.length,t=new Float32Array(n);for(let u=0;u<n;u++){if(u<c-1){t[u]=NaN;continue}let f=0,r=0,s=0,i=0,m=0,o=0;const h=u-c+1;for(let g=h;g<=u;g++){const v=a[g],y=e[g];!Number.isFinite(v)||!Number.isFinite(y)||(f+=v,r+=y,s+=v*v,i+=y*y,m+=v*y,o+=1)}if(o<2){t[u]=NaN;continue}const l=f/o,w=r/o,b=m/o-l*w,d=s/o-l*l,N=i/o-w*w,p=Math.sqrt(d*N);t[u]=p>0?b/p:NaN}return t}function Be(a,e,c){const n=a.length,t=new Float32Array(n),u=Math.max(1,Math.floor(e)),f=Math.floor(c),r=(u-1)*u/2,s=(u-1)*u*(2*u-1)/6,i=u*s-r*r;for(let m=0;m<n;m++){if(m<u-1||i===0){t[m]=NaN;continue}let o=0,h=0,l=0;for(let N=0;N<u;N++){const p=m-(u-1-N),g=a[p];Number.isFinite(g)&&(o+=g,h+=g*N,l+=1)}if(l<2){t[m]=NaN;continue}const w=(u*h-r*o)/i,b=(o-w*r)/u,d=u-1+f;t[m]=b+w*d}return t}function Oe(a,e){const c=a.callee.toLowerCase(),n=le(c);if(n){if(!e.draw)return{kind:"scalar",value:NaN};const r=a.args[0];let s="";if(r&&r.kind==="Identifier"&&(s=r.name),r&&r.kind==="StringLiteral"&&(s=r.value),!s)return{kind:"scalar",value:NaN};const i=e.length,m=new Float32Array(i);for(let o=0;o<i;o++){const h=e.draw.get(n.kind,n.prop,s,o);typeof h=="string"?m[o]=B(h):typeof h=="number"&&Number.isFinite(h)?m[o]=h:m[o]=NaN}return{kind:"series",value:m}}const t=a.args.map(r=>W(r,e)),u=ue(c);if(u){if(!e.strategy)return{kind:"scalar",value:NaN};if(!t.length)throw new F(`${a.callee} expects (index)`);const r=x(t[0],e),s=e.length,i=new Float32Array(s);for(let m=0;m<s;m++){const o=r[m],h=Number.isFinite(o)?Math.floor(o):NaN;if(!Number.isFinite(h)){i[m]=NaN;continue}i[m]=fe(e,u.kind,u.prop,m,h)}return{kind:"series",value:i}}const f=()=>{if(t.length!==2)throw new F(`${c} expects (series, period)`);const r=x(t[0],e),s=Math.max(1,Math.floor(V(t[1])));return[r,s]};switch(c){case"iff":case"iif":case"if":{if(t.length!==3)throw new F(`${a.callee} expects (cond, a, b)`);const r=t[0],s=t[1],i=t[2],m=r.kind==="series",o=s.kind==="series",h=i.kind==="series";if(!m&&!o&&!h){const p=r.value;return{kind:"scalar",value:Number.isFinite(p)&&p!==0?s.value:i.value}}const l=x(r,e),w=x(s,e),b=x(i,e),d=e.length,N=new Float32Array(d);for(let p=0;p<d;p++){const g=l[p],v=Number.isFinite(g)&&g!==0;N[p]=v?w[p]:b[p]}return{kind:"series",value:N}}case"nz":{if(t.length<1||t.length>2)throw new F("nz expects (series[, fallback])");const r=t[0],s=t[1]??{kind:"scalar",value:0};if(r.kind==="scalar"&&s.kind==="scalar")return{kind:"scalar",value:Number.isFinite(r.value)?r.value:s.value};const i=x(r,e),m=x(s,e),o=e.length,h=new Float32Array(o);for(let l=0;l<o;l++){const w=i[l];h[l]=Number.isFinite(w)?w:m[l]}return{kind:"series",value:h}}case"add":case"sub":case"mul":case"div":{if(t.length!==2)throw new F(`${c} expects 2 arguments`);const r=t[0],s=t[1];if(r.kind==="scalar"&&s.kind==="scalar"){const l=r.value,w=s.value;return c==="add"?{kind:"scalar",value:l+w}:c==="sub"?{kind:"scalar",value:l-w}:c==="mul"?{kind:"scalar",value:l*w}:{kind:"scalar",value:w===0?NaN:l/w}}const i=x(r,e),m=x(s,e),o=e.length,h=new Float32Array(o);for(let l=0;l<o;l++){const w=i[l],b=m[l];c==="add"?h[l]=w+b:c==="sub"?h[l]=w-b:c==="mul"?h[l]=w*b:h[l]=b===0?NaN:w/b}return{kind:"series",value:h}}case"pow":{if(t.length!==2)throw new F("pow expects 2 arguments");const r=t[0],s=t[1];if(r.kind==="scalar"&&s.kind==="scalar")return{kind:"scalar",value:Math.pow(r.value,s.value)};const i=x(r,e),m=x(s,e);return{kind:"series",value:se(i,m,(o,h)=>Math.pow(o,h))}}case"sqrt":case"log":case"ln":case"log10":case"exp":case"floor":case"ceil":case"round":case"sin":case"cos":case"tan":case"asin":case"acos":case"atan":case"sign":{if(t.length!==1)throw new F(`${c} expects 1 argument`);const r=c==="sqrt"?Math.sqrt:c==="log"||c==="ln"?Math.log:c==="log10"?Math.log10:c==="exp"?Math.exp:c==="floor"?Math.floor:c==="ceil"?Math.ceil:c==="round"?Math.round:c==="sin"?Math.sin:c==="cos"?Math.cos:c==="tan"?Math.tan:c==="asin"?Math.asin:c==="acos"?Math.acos:c==="atan"?Math.atan:Math.sign,s=t[0];return s.kind==="scalar"?{kind:"scalar",value:r(s.value)}:{kind:"series",value:ae(x(s,e),r)}}case"todegrees":case"toradians":{if(t.length!==1)throw new F(`${c} expects 1 argument`);const r=t[0],s=c==="todegrees"?180/Math.PI:Math.PI/180;return r.kind==="scalar"?{kind:"scalar",value:r.value*s}:{kind:"series",value:ae(x(r,e),i=>i*s)}}case"atan2":{if(t.length!==2)throw new F("atan2 expects (y, x)");const r=t[0],s=t[1];if(r.kind==="scalar"&&s.kind==="scalar")return{kind:"scalar",value:Math.atan2(r.value,s.value)};const i=x(r,e),m=x(s,e);return{kind:"series",value:se(i,m,(o,h)=>Math.atan2(o,h))}}case"avg":{if(t.length!==2)throw new F("avg expects (a, b)");const r=t[0],s=t[1];if(r.kind==="scalar"&&s.kind==="scalar")return{kind:"scalar",value:(r.value+s.value)/2};const i=x(r,e),m=x(s,e);return{kind:"series",value:se(i,m,(o,h)=>(o+h)/2)}}case"clamp":{if(t.length!==3)throw new F("clamp expects (x, min, max)");const r=t[0],s=t[1],i=t[2],m=(d,N,p)=>Math.min(p,Math.max(N,d));if(r.kind==="scalar"&&s.kind==="scalar"&&i.kind==="scalar")return{kind:"scalar",value:m(r.value,s.value,i.value)};const o=x(r,e),h=x(s,e),l=x(i,e),w=e.length,b=new Float32Array(w);for(let d=0;d<w;d++)b[d]=m(o[d],h[d],l[d]);return{kind:"series",value:b}}case"cum":case"cumsum":{if(t.length!==1)throw new F(`${c} expects 1 argument`);const r=x(t[0],e),s=e.length,i=new Float32Array(s);let m=0;for(let o=0;o<s;o++){const h=r[o];Number.isFinite(h)&&(m+=h),i[o]=m}return{kind:"series",value:i}}case"barssince":{if(t.length!==1)throw new F("barssince expects (condition)");const r=x(t[0],e),s=e.length,i=new Float32Array(s);let m=NaN;for(let o=0;o<s;o++){const h=r[o];Number.isFinite(h)&&h!==0?(m=0,i[o]=0):Number.isFinite(m)?(m+=1,i[o]=m):i[o]=NaN}return{kind:"series",value:i}}case"sma":{const[r,s]=f();return{kind:"series",value:Ae(r,s)}}case"wma":{const[r,s]=f();return{kind:"series",value:Ce(r,s)}}case"ema":{const[r,s]=f();return{kind:"series",value:xe(r,s)}}case"smma":{const[r,s]=f();return{kind:"series",value:ce(r,s)}}case"rsi":{const[r,s]=f();return{kind:"series",value:Ee(r,s)}}case"rma":{const[r,s]=f();return{kind:"series",value:ce(r,s)}}case"linreg":{if(t.length<2||t.length>3)throw new F("linreg expects (series, period[, offset])");const r=x(t[0],e),s=Math.max(1,Math.floor(V(t[1]))),i=t[2]?Math.floor(V(t[2])):0;return{kind:"series",value:Be(r,s,i)}}case"tr":case"trange":case"true_range":{if(t.length!==0&&t.length!==3)throw new F("tr expects () or (high, low, close)");const r=t.length===3?x(t[0],e):e.series.high,s=t.length===3?x(t[1],e):e.series.low,i=t.length===3?x(t[2],e):e.series.close;if(!r||!s||!i)throw new F("tr requires high/low/close series");const m=e.length,o=new Float32Array(m);let h=NaN;for(let l=0;l<m;l++){const w=r[l],b=s[l],d=i[l];let N=Math.max(0,w-b);Number.isFinite(h)&&(N=Math.max(N,Math.abs(w-h),Math.abs(b-h))),o[l]=N,h=d}return{kind:"series",value:o}}case"atr":{if(t.length!==4)throw new F("atr expects (high, low, close, period)");const r=x(t[0],e),s=x(t[1],e),i=x(t[2],e),m=Math.max(1,Math.floor(V(t[3]))),o=e.length,h=new Float32Array(o);let l=NaN;for(let d=0;d<o;d++){const N=r[d],p=s[d],g=i[d];let v=Math.max(0,N-p);Number.isFinite(l)&&(v=Math.max(v,Math.abs(N-l),Math.abs(p-l))),h[d]=v,l=g}const w=new Float32Array(o);let b=0;for(let d=0;d<o;d++)b+=h[d],d===m-1?w[d]=b/m:d>=m?w[d]=(w[d-1]*(m-1)+h[d])/m:w[d]=NaN;return{kind:"series",value:w}}case"stdev":case"stddev":case"dev":{const[r,s]=f();return{kind:"series",value:$e(r,s)}}case"variance":case"var":{const[r,s]=f();return{kind:"series",value:Ve(r,s)}}case"correlation":case"corr":{if(t.length!==3)throw new F(`${a.callee} expects (a, b, period)`);const r=x(t[0],e),s=x(t[1],e),i=Math.max(1,Math.floor(V(t[2])));return{kind:"series",value:ze(r,s,i)}}case"highest":{const[r,s]=f();return{kind:"series",value:Le(r,s)}}case"highestbars":{const[r,s]=f();return{kind:"series",value:Pe(r,s)}}case"lowest":{const[r,s]=f();return{kind:"series",value:Ie(r,s)}}case"lowestbars":{const[r,s]=f();return{kind:"series",value:je(r,s)}}case"sum":{const[r,s]=f();return{kind:"series",value:ke(r,s)}}case"lag":{const[r,s]=f();return{kind:"series",value:me(r,s)}}case"prev":{if(t.length<1||t.length>2)throw new F("prev expects (series[, n])");const r=x(t[0],e),s=Math.max(1,Math.floor(V(t[1]??{kind:"scalar",value:1})));return{kind:"series",value:me(r,s)}}case"change":{if(t.length<1||t.length>2)throw new F("change expects (series[, n])");const r=x(t[0],e),s=Math.max(1,Math.floor(V(t[1]??{kind:"scalar",value:1})));return{kind:"series",value:Fe(r,s)}}case"roc":{if(t.length<1||t.length>2)throw new F("roc expects (series[, n])");const r=x(t[0],e),s=Math.max(1,Math.floor(V(t[1]??{kind:"scalar",value:1})));return{kind:"series",value:Me(r,s)}}case"mom":case"momentum":{if(t.length<1||t.length>2)throw new F("mom expects (series[, n])");const r=x(t[0],e),s=Math.max(1,Math.floor(V(t[1]??{kind:"scalar",value:1})));return{kind:"series",value:_e(r,s)}}case"crossover":case"crossunder":{if(t.length<2||t.length>3)throw new F(`${a.callee} expects (series, series[, tol])`);const r=x(t[0],e),s=t[1],i=s.kind==="series",m=x(s,e),o=t[2]?Math.max(0,V(t[2])):0,h=e.length,l=new Float32Array(h);l[0]=0;for(let w=1;w<h;w++){const b=r[w-1],d=r[w],N=i?m[w-1]:m[0],p=i?m[w]:m[0];if(![b,d,N,p].every(Number.isFinite)){l[w]=0;continue}c==="crossover"?l[w]=b<=N+o&&d>p+o?1:0:l[w]=b>=N-o&&d<p-o?1:0}return{kind:"series",value:l}}case"hl2":{if(t.length!==0)throw new F("hl2 expects no arguments");const r=e.series.high,s=e.series.low;if(!r||!s)throw new F("hl2 requires high/low series");const i=e.length,m=new Float32Array(i);for(let o=0;o<i;o++)m[o]=(r[o]+s[o])/2;return{kind:"series",value:m}}case"hlc3":{if(t.length!==0)throw new F("hlc3 expects no arguments");const r=e.series.high,s=e.series.low,i=e.series.close;if(!r||!s||!i)throw new F("hlc3 requires high/low/close series");const m=e.length,o=new Float32Array(m);for(let h=0;h<m;h++)o[h]=(r[h]+s[h]+i[h])/3;return{kind:"series",value:o}}case"ohlc4":{if(t.length!==0)throw new F("ohlc4 expects no arguments");const r=e.series.open,s=e.series.high,i=e.series.low,m=e.series.close;if(!r||!s||!i||!m)throw new F("ohlc4 requires open/high/low/close series");const o=e.length,h=new Float32Array(o);for(let l=0;l<o;l++)h[l]=(r[l]+s[l]+i[l]+m[l])/4;return{kind:"series",value:h}}case"vwap":{if(t.length!==2)throw new F("vwap expects (close, volume)");const r=x(t[0],e),s=x(t[1],e),i=e.length,m=new Float32Array(i);let o=0,h=0;for(let l=0;l<i;l++){const w=r[l],b=s[l];if(!Number.isFinite(w)||!Number.isFinite(b)){m[l]=NaN;continue}o+=w*b,h+=b,m[l]=h===0?NaN:o/h}return{kind:"series",value:m}}case"vwma":{if(t.length!==3)throw new F("vwma expects (close, volume, period)");const r=x(t[0],e),s=x(t[1],e),i=Math.max(1,Math.floor(V(t[2]))),m=e.length,o=new Float32Array(m);let h=0,l=0;for(let w=0;w<m;w++){const b=r[w],d=s[w];if(Number.isFinite(b)&&Number.isFinite(d)&&(h+=b*d,l+=d),w>=i){const N=r[w-i],p=s[w-i];Number.isFinite(N)&&Number.isFinite(p)&&(h-=N*p,l-=p)}o[w]=w>=i-1&&l!==0?h/l:NaN}return{kind:"series",value:o}}case"min":{if(t.length!==2)throw new F("min expects 2 arguments");const r=t[0],s=t[1];if(r.kind==="scalar"&&s.kind==="scalar")return{kind:"scalar",value:Math.min(r.value,s.value)};const i=x(r,e),m=x(s,e),o=e.length,h=new Float32Array(o);for(let l=0;l<o;l++)h[l]=Math.min(i[l],m[l]);return{kind:"series",value:h}}case"max":{if(t.length!==2)throw new F("max expects 2 arguments");const r=t[0],s=t[1];if(r.kind==="scalar"&&s.kind==="scalar")return{kind:"scalar",value:Math.max(r.value,s.value)};const i=x(r,e),m=x(s,e),o=e.length,h=new Float32Array(o);for(let l=0;l<o;l++)h[l]=Math.max(i[l],m[l]);return{kind:"series",value:h}}case"abs":{if(t.length!==1)throw new F("abs expects 1 argument");const r=t[0];if(r.kind==="scalar")return{kind:"scalar",value:Math.abs(r.value)};const s=r.value,i=e.length,m=new Float32Array(i);for(let o=0;o<i;o++)m[o]=Math.abs(s[o]);return{kind:"series",value:m}}default:throw new F(`Unknown function "${a.callee}"`)}}function W(a,e){var c;switch(a.kind){case"NumberLiteral":return{kind:"scalar",value:a.value};case"StringLiteral":return{kind:"scalar",value:B(a.value)};case"Identifier":{const n=a.name.replace(/\s+/g,"_").toLowerCase();if(n==="na"||n==="nan")return{kind:"scalar",value:NaN};if(n==="pi")return{kind:"scalar",value:Math.PI};if(n==="e")return{kind:"scalar",value:Math.E};const t=e.series[n];if(t)return{kind:"series",value:t};const u=(c=e.scalars)==null?void 0:c[n];if(typeof u=="number"&&Number.isFinite(u))return{kind:"scalar",value:u};throw e.seriesNames.has(n)?new F(`Series "${a.name}" is used before it is defined (circular or forward reference)`):new F(`Unknown identifier "${a.name}"`)}case"UnaryExpression":{const n=W(a.expr,e);if(a.operator==="not"){if(n.kind==="scalar"){const f=n.value;return{kind:"scalar",value:Number.isFinite(f)&&f!==0?0:1}}const t=n.value,u=new Float32Array(t.length);for(let f=0;f<t.length;f++){const r=t[f];u[f]=Number.isFinite(r)&&r!==0?0:1}return{kind:"series",value:u}}throw new F("Unsupported unary operator")}case"BinaryExpression":return Se(a.operator,W(a.left,e),W(a.right,e),e);case"CallExpression":return Oe(a,e);default:throw new F("Unsupported expression node")}}function Y(a,e,c,n){var p;const t=new Set;for(const g of a){const v=g.name.replace(/\s+/g,"_").toLowerCase();t.add(v)}const u=Object.entries(e),f=((p=u[0])==null?void 0:p[1].length)??0;for(const[,g]of u)if(g.length!==f)throw new F("All base series must have the same length");const r=a.map(g=>{try{const v=ne(g.expr);return{name:g.name.replace(/\s+/g,"_").toLowerCase(),expr:g.expr,ast:v}}catch(v){throw v instanceof T?new F(`Syntax error in series "${g.name}" at position ${v.position}: ${v.message}`):v}}),s={length:f,series:{...e},seriesNames:t,scalars:(()=>{if(!c||typeof c!="object")return;const g={};return Object.entries(c).forEach(([v,y])=>{const M=v.replace(/\s+/g,"_").toLowerCase();if(typeof y=="number"&&Number.isFinite(y)){g[M]=y;return}if(typeof y=="string"){const S=Number(y);g[M]=Number.isFinite(S)?S:B(y)}}),Object.keys(g).length?g:void 0})(),strategy:n},i={},m=g=>{const v=new Set,y=M=>{switch(M.kind){case"Identifier":{const S=M.name.replace(/\s+/g,"_").toLowerCase();v.add(S);break}case"BinaryExpression":y(M.left),y(M.right);break;case"UnaryExpression":y(M.expr);break;case"CallExpression":M.args.forEach(S=>y(S));break}};return y(g),v},o=new Set(r.map(g=>g.name)),h={},l={};r.forEach(g=>{h[g.name]=new Set,l[g.name]=new Set}),r.forEach(g=>{m(g.ast).forEach(y=>{o.has(y)&&y!==g.name&&(h[g.name].add(y),l[y].add(g.name))})});const w={};Object.keys(h).forEach(g=>{var v;w[g]=((v=h[g])==null?void 0:v.size)??0});const b=Object.keys(w).filter(g=>(w[g]||0)===0),d=[];for(;b.length;){const g=b.shift();d.push(g);for(const v of l[g]||[])w[v]=(w[v]||0)-1,w[v]===0&&b.push(v)}if(d.length!==r.length){const g=r.map(v=>v.name).filter(v=>!d.includes(v));throw new F(`Circular dependency detected among series: ${g.join(" -> ")}`)}const N={};r.forEach(g=>{N[g.name]=g});for(const g of d){const v=N[g];if(s.series[v.name])throw new F(`Series name "${v.name}" conflicts with an existing base series`);const y=W(v.ast,s),M=x(y,s);s.series[v.name]=M,i[v.name]=M}return i}function Ke(a,e){var u;const c=a.replace(/\s+/g,"_").toLowerCase();if(c==="na"||c==="nan")return NaN;if(c==="pi")return Math.PI;if(c==="e")return Math.E;if(e.selfKey&&e.selfOut&&c===e.selfKey){if(e.selfMode==="current"){const r=e.selfOut[e.index];if(Number.isFinite(r))return r}const f=e.index-1;return f>=0?e.selfOut[f]:NaN}const n=e.series[c];if(n)return n[e.index]??NaN;const t=(u=e.scalars)==null?void 0:u[c];if(typeof t=="number"&&Number.isFinite(t))return t;throw new F(`Unknown identifier "${a}"`)}function le(a){const e=a.match(/^(line|label|box|table)_get_([a-z0-9_]+)$/i);return e?{kind:e[1].toLowerCase(),prop:e[2].toLowerCase()}:null}function ue(a){const e=a.match(/^strategy_(closedtrades|opentrades)_([a-z0-9_]+)$/i);return e?{kind:e[1].toLowerCase(),prop:e[2].toLowerCase()}:null}const qe={profit_pct:"profit_percent",pnl:"profit",max_profit:"max_runup",max_profit_pct:"max_runup_percent",max_profit_percent:"max_runup_percent",max_runup_pct:"max_runup_percent",max_drawdown_pct:"max_drawdown_percent",max_loss:"max_drawdown",max_loss_pct:"max_drawdown_percent",max_loss_percent:"max_drawdown_percent"};function Ue(a){const e=a.toLowerCase();return qe[e]??e}function fe(a,e,c,n,t){const u=Ue(c),f=a.strategy;if(!f)return NaN;if(t<0)return NaN;if(e==="closedtrades"){const S=f.closedTrades||[];if(!S.length)return 0;const E=a.series.strategy_closedtrades,$=E?E[n]:NaN,_=(typeof $=="number"&&Number.isFinite($)?Math.floor($):0)-1-t;if(_<0||_>=S.length)return 0;const k=S[_];switch(u){case"entry_price":return k.entryPrice;case"entry_time":return k.entryTimestamp;case"entry_bar_index":return k.entryIndex;case"exit_price":return k.exitPrice;case"exit_time":return k.exitTimestamp;case"exit_bar_index":return k.exitIndex;case"size":return k.qty;case"profit":return Number.isFinite(k.pnl)?k.pnl:0;case"profit_percent":return Number.isFinite(k.pnlPct)?k.pnlPct:0;case"max_runup":return typeof k.mfePct!="number"||!Number.isFinite(k.mfePct)?0:k.mfePct/100*k.entryPrice*k.qty;case"max_runup_percent":return typeof k.mfePct=="number"&&Number.isFinite(k.mfePct)?k.mfePct:0;case"max_drawdown":return typeof k.maePct!="number"||!Number.isFinite(k.maePct)?0:k.maePct/100*k.entryPrice*k.qty;case"max_drawdown_percent":return typeof k.maePct=="number"&&Number.isFinite(k.maePct)?k.maePct:0;case"is_long":return k.side==="long"?1:0;case"is_short":return k.side==="short"?1:0;case"entry_id":return B(String(k.entryOrderId??k.entrySignalId??""));case"exit_id":return B(String(k.exitOrderId??k.exitSignalId??""));default:return 0}}const r=f.openTradesByBar||[];if(n<0||n>=r.length)return 0;const s=r[n]||[];if(t>=s.length)return 0;const i=s[t],m=a.series.close,o=m&&Number.isFinite(m[n])?m[n]:NaN,h=i.qty,l=i.entryPrice,w=l>0&&h>0?l*h:NaN,b=Number.isFinite(o)&&Number.isFinite(l)?i.side==="long"?(o-l)*h:(l-o)*h:NaN,d=Number.isFinite(w)&&w!==0?b/w*100:NaN,N=i.maxFav,p=i.maxAdv,g=Number.isFinite(l)&&Number.isFinite(h)&&Number.isFinite(N)?i.side==="long"?(N-l)*h:(l-N)*h:NaN,v=Number.isFinite(l)&&l>0&&Number.isFinite(N)?i.side==="long"?(N-l)/l*100:(l-N)/l*100:NaN,y=Number.isFinite(l)&&Number.isFinite(h)&&Number.isFinite(p)?i.side==="long"?(p-l)*h:(l-p)*h:NaN,M=Number.isFinite(l)&&l>0&&Number.isFinite(p)?i.side==="long"?(p-l)/l*100:(l-p)/l*100:NaN;switch(u){case"entry_price":return l;case"entry_time":return i.entryTimestamp;case"entry_bar_index":return i.entryIndex;case"size":return h;case"profit":return Number.isFinite(b)?b:0;case"profit_percent":return Number.isFinite(d)?d:0;case"max_runup":return Number.isFinite(g)?g:0;case"max_runup_percent":return Number.isFinite(v)?v:0;case"max_drawdown":return Number.isFinite(y)?y:0;case"max_drawdown_percent":return Number.isFinite(M)?M:0;case"is_long":return i.side==="long"?1:0;case"is_short":return i.side==="short"?1:0;case"entry_id":return B(String(i.entryOrderId??i.entrySignalId??""));default:return 0}}function I(a,e){var c;switch(a.kind){case"NumberLiteral":return a.value;case"StringLiteral":return B(a.value);case"Identifier":return Ke(a.name,e);case"UnaryExpression":{if(a.operator==="not"){const n=I(a.expr,e);return Number.isFinite(n)&&n!==0?0:1}return NaN}case"BinaryExpression":{const n=I(a.left,e),t=I(a.right,e);switch(a.operator){case"+":return n+t;case"-":return n-t;case"*":return n*t;case"/":return t===0?NaN:n/t;case"%":return t===0?NaN:n%t;case">":return Number.isFinite(n)&&Number.isFinite(t)&&n>t?1:0;case"<":return Number.isFinite(n)&&Number.isFinite(t)&&n<t?1:0;case">=":return Number.isFinite(n)&&Number.isFinite(t)&&n>=t?1:0;case"<=":return Number.isFinite(n)&&Number.isFinite(t)&&n<=t?1:0;case"==":return Number.isFinite(n)&&Number.isFinite(t)&&Math.abs(n-t)<1e-9?1:0;case"!=":return Number.isFinite(n)&&Number.isFinite(t)&&Math.abs(n-t)>=1e-9?1:0;case"and":return Number.isFinite(n)&&n!==0&&Number.isFinite(t)&&t!==0?1:0;case"or":return Number.isFinite(n)&&n!==0||Number.isFinite(t)&&t!==0?1:0;default:return NaN}}case"CallExpression":{const n=a.callee.toLowerCase(),t=le(n);if(t&&e.draw){const s=a.args[0];let i="";if(s&&s.kind==="Identifier"&&(i=s.name),s&&s.kind==="StringLiteral"&&(i=s.value),!i)return NaN;const m=e.draw.get(t.kind,t.prop,i,e.index);return typeof m=="string"?B(m):typeof m=="number"&&Number.isFinite(m)?m:NaN}const u=ue(n);if(u){if(!e.strategy)return NaN;if(!a.args.length)throw new F(`${a.callee} expects (index)`);const s=I(a.args[0],e),i=Number.isFinite(s)?Math.floor(s):NaN;return Number.isFinite(i)?fe(e,u.kind,u.prop,e.index,i):NaN}const f=a.args[0],r=a.args[1];if(n==="nz"){if(a.args.length<1||a.args.length>2)throw new F("nz expects (x[, fallback])");const s=I(f,e);return Number.isFinite(s)?s:a.args.length===2?I(r,e):0}if(n==="iff"||n==="iif"||n==="if"){if(a.args.length!==3)throw new F(`${a.callee} expects (cond, a, b)`);const s=I(f,e),i=Number.isFinite(s)&&s!==0,m=I(a.args[1],e),o=I(a.args[2],e);return i?m:o}if(n==="tostring"||n==="format"||n==="upper"||n==="lower"||n==="trim"||n==="replace"||n==="replace_all"||n==="contains"||n==="startswith"||n==="endswith"||n==="length"||n==="substring"||n==="repeat"){const s=o=>Number.isFinite(o)?String(o):"",i=o=>B(o),m=o=>{var w;const h=a.args[o];if(!h)return"";if(h.kind==="StringLiteral")return h.value;if(h.kind==="Identifier"){const b=h.name.replace(/\s+/g,"_").toLowerCase(),d=(w=e.strings)==null?void 0:w[b];if(typeof d=="string")return d}const l=I(h,e);return s(l)};if(n==="tostring"){if(a.args.length<1||a.args.length>2)throw new F("tostring expects (x[, format])");const o=I(a.args[0],e),h=a.args[1];let l="";if(h){if(h.kind==="StringLiteral")l=h.value;else if(h.kind==="Identifier"){const b=h.name.replace(/\s+/g,"_").toLowerCase(),d=(c=e.strings)==null?void 0:c[b];typeof d=="string"&&(l=d)}}const w=ye(o,l||void 0);return i(w)}if(n==="format"){if(a.args.length<1)throw new F("format expects (fmt, ...)");const o=m(0),h=a.args.slice(1).map(w=>oe(I(w,e))),l=o.replace(/\{(\d+)\}/g,(w,b)=>h[Number(b)]??"");return i(l.replace(/{{/g,"{").replace(/}}/g,"}"))}if(n==="upper")return i(m(0).toUpperCase());if(n==="lower")return i(m(0).toLowerCase());if(n==="trim")return i(m(0).trim());if(n==="replace"||n==="replace_all"){if(a.args.length<3)throw new F("replace expects (s, from, to)");const o=m(0),h=m(1),l=m(2);return i(o.split(h).join(l))}if(n==="contains"){if(a.args.length<2)throw new F("contains expects (s, sub)");const o=m(0),h=m(1);return o.includes(h)?1:0}if(n==="startswith"){if(a.args.length<2)throw new F("startswith expects (s, sub)");const o=m(0),h=m(1);return o.startsWith(h)?1:0}if(n==="endswith"){if(a.args.length<2)throw new F("endswith expects (s, sub)");const o=m(0),h=m(1);return o.endsWith(h)?1:0}if(n==="length"){if(a.args.length!==1)throw new F("length expects (s)");return m(0).length}if(n==="substring"){if(a.args.length<2)throw new F("substring expects (s, from[, to])");const o=m(0),h=I(a.args[1],e),l=a.args.length>2?I(a.args[2],e):NaN,w=Math.max(0,Math.floor(h)),b=Number.isFinite(l)?Math.max(w,Math.floor(l)):void 0;return i(b==null?o.slice(w):o.slice(w,b))}if(n==="repeat"){if(a.args.length<2)throw new F("repeat expects (s, count)");const o=m(0),h=Math.max(0,Math.floor(I(a.args[1],e)));return i(o.repeat(h))}}if(n==="add"||n==="sub"||n==="mul"||n==="div"){if(a.args.length!==2)throw new F(`${a.callee} expects 2 arguments`);const s=I(f,e),i=I(r,e);return n==="add"?s+i:n==="sub"?s-i:n==="mul"?s*i:i===0?NaN:s/i}if(n==="min"||n==="max"){if(a.args.length!==2)throw new F(`${a.callee} expects 2 arguments`);const s=I(f,e),i=I(r,e);return n==="min"?Math.min(s,i):Math.max(s,i)}if(n==="abs"){if(a.args.length!==1)throw new F("abs expects 1 argument");return Math.abs(I(f,e))}if(n==="pow"){if(a.args.length!==2)throw new F("pow expects 2 arguments");const s=I(f,e),i=I(r,e);return Math.pow(s,i)}if(n==="sqrt"||n==="log"||n==="log10"||n==="exp"||n==="floor"||n==="ceil"||n==="round"||n==="sin"||n==="cos"||n==="tan"||n==="asin"||n==="acos"||n==="atan"||n==="sign"){if(a.args.length!==1)throw new F(`${a.callee} expects 1 argument`);const s=I(f,e);switch(n){case"sqrt":return Math.sqrt(s);case"log":return Math.log(s);case"log10":return Math.log10(s);case"exp":return Math.exp(s);case"floor":return Math.floor(s);case"ceil":return Math.ceil(s);case"round":return Math.round(s);case"sin":return Math.sin(s);case"cos":return Math.cos(s);case"tan":return Math.tan(s);case"asin":return Math.asin(s);case"acos":return Math.acos(s);case"atan":return Math.atan(s);default:return Math.sign(s)}}if(n==="cum"||n==="cumsum"){if(a.args.length!==1)throw new F(`${a.callee} expects 1 argument`);const s=f;if(s.kind!=="Identifier")throw new F(`${a.callee} expects a series identifier`);const i=s.name.replace(/\s+/g,"_").toLowerCase(),m=e.series[i];if(!m)throw new F(`Unknown identifier "${s.name}"`);let o=0;for(let h=0;h<=e.index;h++){const l=m[h];Number.isFinite(l)&&(o+=l)}return o}if(n==="barssince"){if(a.args.length!==1)throw new F("barssince expects (condition)");const s=f;if(s.kind!=="Identifier")throw new F("barssince expects a series identifier");const i=s.name.replace(/\s+/g,"_").toLowerCase(),m=e.series[i];if(!m)throw new F(`Unknown identifier "${s.name}"`);for(let o=e.index;o>=0;o--){const h=m[o];if(Number.isFinite(h)&&h!==0)return e.index-o}return NaN}if(n==="tr"){if(a.args.length!==0&&a.args.length!==3)throw new F("tr expects () or (high, low, close)");const s=(d,N)=>{if(!d){const v=e.series[N];if(!v)throw new F(`Unknown identifier "${N}"`);return v}if(d.kind!=="Identifier")throw new F("tr expects series identifiers");const p=d.name.replace(/\s+/g,"_").toLowerCase(),g=e.series[p];if(!g)throw new F(`Unknown identifier "${d.name}"`);return g},i=s(a.args[0],"high"),m=s(a.args[1],"low"),o=s(a.args[2],"close"),h=i[e.index],l=m[e.index],w=e.index>0?o[e.index-1]:NaN;let b=Math.max(0,h-l);return Number.isFinite(w)&&(b=Math.max(b,Math.abs(h-w),Math.abs(l-w))),b}if(n==="prev"||n==="lag"||n==="change"){if(a.args.length!==2)throw new F(`${a.callee} expects (series, n)`);const s=f;if(s.kind!=="Identifier")throw new F(`${a.callee} expects first argument to be a series identifier`);const i=s.name.replace(/\s+/g,"_").toLowerCase(),m=I(r,e),o=Math.max(1,Math.floor(m)),h=e.index-o,l=d=>{if(d<0)return NaN;if(e.selfKey&&e.selfOut&&i===e.selfKey)return e.selfOut[d]??NaN;const N=e.series[i];if(!N)throw new F(`Unknown identifier "${s.name}"`);return N[d]??NaN};if(n==="prev"||n==="lag")return l(h);const w=l(e.index),b=l(h);return Number.isFinite(w)&&Number.isFinite(b)?w-b:NaN}if(n==="crossover"||n==="crossunder"){if(a.args.length<2||a.args.length>3)throw new F(`${a.callee} expects (series, series[, tol])`);const s=f;if(s.kind!=="Identifier")throw new F(`${a.callee} expects first argument to be a series identifier`);const i=s.name.replace(/\s+/g,"_").toLowerCase(),m=e.series[i];if(!m)throw new F(`Unknown identifier "${s.name}"`);const o=a.args[1];let h=null,l=NaN;if(o.kind==="Identifier"){const g=o.name.replace(/\s+/g,"_").toLowerCase();if(h=e.series[g]||null,!h){const v=Number(o.name);l=Number.isFinite(v)?v:NaN}}else l=I(o,e);const w=a.args[2]?Math.max(0,I(a.args[2],e)):0;if(e.index<=0)return 0;const b=m[e.index-1],d=m[e.index],N=h?h[e.index-1]:l,p=h?h[e.index]:l;return[b,d,N,p].every(Number.isFinite)?n==="crossover"?b<=N+w&&d>p+w?1:0:b>=N-w&&d<p-w?1:0:0}throw new F(`Unknown function "${a.callee}"`)}default:return NaN}}function he(a,e,c,n,t){var w;const u=Object.entries(e),f=((w=u[0])==null?void 0:w[1].length)??0;for(const[,b]of u)if(b.length!==f)throw new F("All base series must have the same length");const r=(()=>{if(!c||typeof c!="object")return;const b={};return Object.entries(c).forEach(([d,N])=>{const p=d.replace(/\s+/g,"_").toLowerCase();if(typeof N=="number"&&Number.isFinite(N)){b[p]=N;return}if(typeof N=="string"){const g=Number(N);b[p]=Number.isFinite(g)?g:B(N)}}),Object.keys(b).length?b:void 0})(),s=(()=>{if(!c||typeof c!="object")return;const b={};return Object.entries(c).forEach(([d,N])=>{typeof N=="string"&&(b[d.replace(/\s+/g,"_").toLowerCase()]=N)}),Object.keys(b).length?b:void 0})(),i=a.map(b=>{const d=b.name.replace(/\s+/g,"_").toLowerCase();try{const N=b.initExpr?ne(b.initExpr):null,p=ne(b.updateExpr);return{name:d,initAst:N,updateAst:p,initExpr:b.initExpr,updateExpr:b.updateExpr,selfMode:b.selfMode}}catch(N){throw N instanceof T?new F(`Syntax error in series "${b.name}" at position ${N.position}: ${N.message}`):N}}),m=(()=>{if(!(t!=null&&t.autoSort)||i.length<=1)return i;const b=new Set(i.map(_=>_.name)),d={},N={},p=new Map;i.forEach((_,k)=>{d[_.name]=new Set,N[_.name]=new Set,p.set(_.name,k)});const g=_=>_.replace(/\s+/g,"_").toLowerCase(),v=_=>{const k=new Set,L=(C,P)=>{switch(C.kind){case"Identifier":{const H=g(C.name);P||k.add(H);break}case"BinaryExpression":L(C.left,P),L(C.right,P);break;case"UnaryExpression":L(C.expr,P);break;case"CallExpression":{const H=String(C.callee||"").toLowerCase(),K=H==="prev"||H==="lag";C.args.forEach((ee,te)=>{L(ee,P||K&&te===0)});break}}};return _&&L(_,!1),{direct:k}},y=(_,k)=>{if(!k)return;const{direct:L}=v(k);L.forEach(C=>{!b.has(C)||C===_||(d[_].add(C),N[C].add(_))})};i.forEach(_=>{y(_.name,_.updateAst),y(_.name,_.initAst)});const M={};Object.keys(d).forEach(_=>{var k;M[_]=((k=d[_])==null?void 0:k.size)??0});const S=Object.keys(M).filter(_=>(M[_]||0)===0);S.sort((_,k)=>(p.get(_)??0)-(p.get(k)??0));const E=[],$=_=>{const k=S.findIndex(L=>(p.get(L)??0)>(p.get(_)??0));k===-1?S.push(_):S.splice(k,0,_)};for(;S.length;){const _=S.shift();E.push(_);const k=Array.from(N[_]||[]).sort((L,C)=>(p.get(L)??0)-(p.get(C)??0));for(const L of k)M[L]=(M[L]||0)-1,M[L]===0&&$(L)}if(E.length!==i.length){const _=i.map(k=>k.name).filter(k=>!E.includes(k));throw new F(`Circular dependency detected among state series: ${_.join(" -> ")}`)}const A={};return i.forEach(_=>{A[_.name]=_}),E.map(_=>A[_])})(),o={},h={...e},l=new Set(Object.keys(e));for(const b of i){if(l.has(b.name))throw new F(`Series name "${b.name}" conflicts with an existing base series`);if(h[b.name])o[b.name]||(o[b.name]=h[b.name]);else{const d=new Float32Array(f);d.fill(NaN),h[b.name]=d,o[b.name]=d}}for(let b=0;b<f;b++)for(const d of m){const N=o[d.name],p={series:h,scalars:r,strings:s,length:f,index:b,selfKey:d.name,selfOut:N,selfMode:d.selfMode,strategy:n},g=b===0&&d.initAst?d.initAst:d.updateAst,v=I(g,p);N[b]=v}return o}function me(a,e){const c=a.length,n=new Float32Array(c);for(let t=0;t<c;t++){const u=t-e;n[t]=u>=0?a[u]:NaN}return n}function J(a){return typeof a=="number"&&Number.isFinite(a)}function G(a,e,c){const n=a[c];if(J(n))return n;const t=e[c];return J(t)?t:NaN}function Z(a,e,c){const n=a[c];if(J(n))return n;const t=e[c];return J(t)?t:NaN}function de(a,e,c,n){let t=-1,u=-1/0;for(let f=c;f<=n;f++){const r=G(a,e,f);Number.isFinite(r)&&r>u&&(u=r,t=f)}return t}function pe(a,e,c,n){let t=-1,u=1/0;for(let f=c;f<=n;f++){const r=Z(a,e,f);Number.isFinite(r)&&r<u&&(u=r,t=f)}return t}function De(a,e,c,n,t){const u=Math.min(a.length,e.length,c.length);if(u<=1)return null;const f=Math.min(u-1,Math.max(0,Math.trunc(n))),r=Math.max(2,Math.trunc(t.lookback||200)),s=Math.max(0,f-r+1),i=t.direction==="down"?"down":"up";if((t.method==="pivots"?"pivots":"extremes")==="pivots"){const b=Math.max(1,Math.floor(Number(t.pivotLeft??3))),d=Math.max(1,Math.floor(Number(t.pivotRight??3))),N=f;if(N<d)return null;const p=[],g=[],v=A=>{const _=G(a,c,A);if(!Number.isFinite(_))return null;const k=Math.max(0,A-b),L=Math.min(N,A+d);if(L<A+d)return null;for(let C=k;C<=L;C++){if(C===A)continue;const P=G(a,c,C);if(!Number.isFinite(P)||P>=_)return null}return _},y=A=>{const _=Z(e,c,A);if(!Number.isFinite(_))return null;const k=Math.max(0,A-b),L=Math.min(N,A+d);if(L<A+d)return null;for(let C=k;C<=L;C++){if(C===A)continue;const P=Z(e,c,C);if(!Number.isFinite(P)||P<=_)return null}return _},M=Math.max(s,0),S=Math.min(f-d,f);for(let A=M;A<=S;A++){const _=v(A);_!=null&&p.push({index:A,value:_});const k=y(A);k!=null&&g.push({index:A,value:k})}const E=p.length?p[p.length-1]:null,$=g.length?g[g.length-1]:null;if(!(!E||!$))if(i==="up"){let A=null;for(let _=g.length-1;_>=0;_--)if(g[_].index<E.index){A=g[_];break}if(A)return{fromIndex:A.index,toIndex:E.index,fromValue:A.value,toValue:E.value}}else{let A=null;for(let _=p.length-1;_>=0;_--)if(p[_].index<$.index){A=p[_];break}if(A)return{fromIndex:A.index,toIndex:$.index,fromValue:A.value,toValue:$.value}}}if(i==="up"){const b=de(a,c,s,f);if(b<0)return null;const d=pe(e,c,s,b);if(d<0)return null;const N=Z(e,c,d),p=G(a,c,b);return[N,p].every(Number.isFinite)?{fromIndex:d,toIndex:b,fromValue:N,toValue:p}:null}const o=pe(e,c,s,f);if(o<0)return null;const h=de(a,c,s,o);if(h<0)return null;const l=Z(e,c,o),w=G(a,c,h);return[l,w].every(Number.isFinite)?{fromIndex:h,toIndex:o,fromValue:w,toValue:l}:null}function Te(a,e,c,n){const t=Math.min(a.length,e.length,c.length),u=new Array(t),f=new Array(t),r=new Array(t),s=new Array(t),i=new Array(t),m=new Array(t),o=new Array(t);for(let h=0;h<t;h++){const l=De(a,e,c,h,n);if(!l){u[h]=void 0,f[h]=void 0,r[h]=void 0,s[h]=void 0,i[h]=void 0,m[h]=void 0,o[h]=void 0;continue}u[h]=l.fromValue,f[h]=l.toValue,r[h]=l.fromIndex,s[h]=l.toIndex,i[h]=l.fromValue,o[h]=l.toValue,m[h]=l.fromValue+(l.toValue-l.fromValue)*.5}return{from:u,to:f,fromIndex:r,toIndex:s,lvl0:i,lvl50:m,lvl100:o}}function R(a,e){const c=[];let n=0;for(let t=0;t<a.length;t++){const u=a[t];n+=u??0,t>=e&&(n-=a[t-e]??0),c.push(t>=e-1?n/e:void 0)}return c}function Re(a,e){const c=[],n=e*(e+1)/2;for(let t=0;t<a.length;t++){if(t<e-1){c.push(void 0);continue}let u=0;for(let f=0;f<e;f++)u+=(a[t-f]??0)*(e-f);c.push(u/n)}return c}function He(a,e){const c=[];let n,t=0;for(let u=0;u<a.length;u++){const f=a[u];if(f==null){c.push(void 0);continue}if(n===void 0){if(t+=f,u<e-1){c.push(void 0);continue}n=t/e,c.push(n);continue}n=(n*(e-1)+f)/e,c.push(n)}return c}function O(a,e){const c=[],n=2/(e+1);let t;for(let u=0;u<a.length;u++){const f=a[u];if(f==null){c.push(void 0);continue}t=t===void 0?f:f*n+t*(1-n),c.push(t)}return c}function We(a,e){const c=[];let n,t=0,u=0,f=!1;const r=[],s=[];for(let i=0;i<a.length;i++){const m=a[i];if(m==null){c.push(void 0);continue}if(n===void 0){n=m,c.push(void 0);continue}const o=m-n;n=m;const h=o>0?o:0,l=o<0?-o:0;if(f)t=(t*(e-1)+h)/e,u=(u*(e-1)+l)/e;else{if(r.push(h),s.push(l),r.length<e){c.push(void 0);continue}t=r.reduce((w,b)=>w+b,0)/e,u=s.reduce((w,b)=>w+b,0)/e,f=!0}if(u===0)c.push(100);else{const w=t/u;c.push(100-100/(1+w))}}return c}function Q(a,e,c,n){const t=c.length,u=new Array(t).fill(0);let f;for(let i=0;i<t;i++){const m=a[i]??c[i]??NaN,o=e[i]??c[i]??NaN,h=c[i]??NaN;let l=Math.max(0,m-o);f!==void 0&&(l=Math.max(l,Math.abs(m-f),Math.abs(o-f))),u[i]=l,f=h}const r=new Array(t);let s=0;for(let i=0;i<t;i++)s+=u[i],i===n-1?r[i]=s/n:i>=n?r[i]=(r[i-1]*(n-1)+u[i])/n:r[i]=void 0;return r}function Ge(a,e){const c=new Array(a.length);let n=0,t;for(let u=0;u<a.length;u++){const f=a[u],r=e[u]??0;if(t===void 0||f===void 0){c[u]=void 0,t=f;continue}f>t?n+=r:f<t&&(n-=r),c[u]=n,t=f}return c}function Ze(a,e,c,n){const t=c.length,u=new Array(t);for(let s=0;s<t;s++)u[s]=((a[s]??c[s]??0)+(e[s]??c[s]??0)+(c[s]??0))/3;const f=R(u.map(s=>s),n).map(s=>s),r=new Array(t);for(let s=0;s<t;s++){if(s<n-1){r[s]=void 0;continue}let i=0;for(let o=s-n+1;o<=s;o++)i+=Math.abs(u[o]-f[s]);i=i/n;const m=.015*i;r[s]=m===0?void 0:(u[s]-f[s])/m}return r}function Xe(a,e,c,n,t){const u=c.length,f=new Array(u),r=new Array(u);for(let i=0;i<u;i++)r[i]=((a[i]??c[i]??0)+(e[i]??c[i]??0)+(c[i]??0))/3;const s=new Array(u);for(let i=0;i<u;i++)s[i]=r[i]*(n[i]??0);for(let i=0;i<u;i++){if(i<t){f[i]=void 0;continue}let m=0,o=0;for(let l=i-t+1;l<=i;l++)r[l]>=r[l-1]?m+=s[l]:o+=s[l];const h=o===0?1/0:m/o;f[i]=100-100/(1+h)}return f}function Ye(a,e){const c=a.map((f,r)=>((f??0)+(e[r]??0))/2),n=R(c,5),t=R(c,34),u=new Array(c.length);for(let f=0;f<c.length;f++){const r=n[f],s=t[f];u[f]=r===void 0||s===void 0?void 0:r-s}return u}function Je(a,e){const c=O(a,e).map(f=>f??NaN),n=O(c,e).map(f=>f??NaN),t=O(n,e).map(f=>f??NaN),u=new Array(a.length);for(let f=1;f<a.length;f++){const r=t[f-1],s=t[f];u[f]=r===void 0||s===void 0||r===0?void 0:(s/r-1)*100}return u[0]=void 0,u}function ge(a,e){const c=new Array(a.length);let n=0,t=0;for(let u=0;u<a.length;u++){const f=a[u],r=e[u]??0;if(f===void 0){c[u]=void 0;continue}n+=f*r,t+=r,c[u]=t===0?void 0:n/t}return c}function Qe(a,e,c){const n=new Array(a.length);let t=0,u=0;for(let f=0;f<a.length;f++){const r=a[f],s=e[f]??0;if(r!==void 0&&(t+=r*s,u+=s),f>=c){const i=a[f-c],m=e[f-c]??0;i!==void 0&&(t-=i*m,u-=m)}n[f]=f>=c-1&&u!==0?t/u:void 0}return n}function we(a,e,c){const n=a.map(s=>s??NaN),t=R(n,e),u=[];for(let s=0;s<n.length;s++){if(s<e-1){u.push(void 0);continue}let i=0;for(let h=s-e+1;h<=s;h++)i+=n[h];const m=i/e;let o=0;for(let h=s-e+1;h<=s;h++){const l=n[h]-m;o+=l*l}u.push(Math.sqrt(o/e))}const f=new Array(n.length),r=new Array(n.length);for(let s=0;s<n.length;s++){const i=t[s],m=u[s];f[s]=i===void 0||m===void 0?void 0:i+c*m,r[s]=i===void 0||m===void 0?void 0:i-c*m}return{mid:t,upper:f,lower:r}}function et(a,e,c,n,t){const u=c.length,f=Q(a,e,c,n).map(l=>l??NaN),r=new Array(u),s=new Array(u);for(let l=0;l<u;l++){const w=((a[l]??c[l]??0)+(e[l]??c[l]??0))/2,b=f[l];r[l]=w+t*b,s[l]=w-t*b}const i=new Array(u);let m=NaN,o=NaN,h=!0;for(let l=0;l<u;l++){m=Number.isFinite(m)?Math.min(r[l],m):r[l],o=Number.isFinite(o)?Math.max(s[l],o):s[l];const w=c[l]??NaN;if(!Number.isFinite(w)){i[l]=void 0;continue}h?(w<o&&(h=!1,m=r[l]),i[l]=o):(w>m&&(h=!0,o=s[l]),i[l]=m)}return i}function tt(a,e,c,n,t){const u=O(c,n).map(m=>m??NaN),f=Q(a,e,c,n).map(m=>m??NaN),r=c.length,s=new Array(r),i=new Array(r);for(let m=0;m<r;m++){const o=u[m],h=f[m];s[m]=Number.isFinite(o)&&Number.isFinite(h)?o+t*h:void 0,i[m]=Number.isFinite(o)&&Number.isFinite(h)?o-t*h:void 0}return{mid:u,upper:s,lower:i}}function nt(a,e,c){const n=a.length,t=new Array(n),u=new Array(n),f=new Array(n);for(let r=0;r<n;r++){if(r<c-1){t[r]=void 0,u[r]=void 0,f[r]=void 0;continue}let s=-1/0,i=1/0;for(let m=r-c+1;m<=r;m++){const o=a[m]??e[m]??NaN,h=e[m]??a[m]??NaN;Number.isFinite(o)&&o>s&&(s=o),Number.isFinite(h)&&h<i&&(i=h)}t[r]=s,u[r]=i,f[r]=Number.isFinite(s)&&Number.isFinite(i)?(s+i)/2:void 0}return{upper:t,lower:u,mid:f}}function Ne(a,e){const c=a.length,n=new Array(c);for(let t=0;t<c;t++){if(t<e-1){n[t]=void 0;continue}let u=0;for(let m=t-e+1;m<=t;m++)u+=a[m]??0;const f=u/e;let r=0;for(let m=t-e+1;m<=t;m++){const o=(a[m]??0)-f;r+=o*o}const s=Math.sqrt(r/e),i=a[t]??NaN;n[t]=Number.isFinite(s)&&s!==0?(i-f)/s:void 0}return n}function be(a,e){const c=a.length,n=new Array(c);let t=a[0];for(let u=0;u<c;u++){const f=a[u],r=e[u]??0;if(f==null){n[u]=void 0;continue}const s=f>=(t??f)?1:-1;n[u]=s*r,t=f}return n}function st(a){const e=a.length,c=new Array(e);let n=0;for(let t=0;t<e;t++){const u=a[t];if(u==null){c[t]=void 0;continue}n+=u,c[t]=n}return c}function rt(a,e){const c=a.length,n=new Array(c),t=new Array(c),u=new Array(c);for(let f=0;f<c;f++){if(f<e-1){n[f]=void 0,t[f]=void 0,u[f]=void 0;continue}let r=0,s=0,i=0,m=0,o=0;for(let g=f-e+1;g<=f;g++){const v=g-(f-e+1),y=a[g]??NaN;Number.isFinite(y)&&(r+=v,s+=y,i+=v*v,m+=v*y,o++)}const h=o*i-r*r;if(h===0||o===0){n[f]=void 0,t[f]=void 0,u[f]=void 0;continue}const l=(o*m-r*s)/h,w=(s-l*r)/o,b=e-1,d=l*b+w;n[f]=d;const N=Ne(a.slice(f-e+1,f+1).map(g=>g??NaN),e).pop(),p=Number(N)*(a[f]??0?1:0);t[f]=Number.isFinite(d)?d+Math.abs(p||0):void 0,u[f]=Number.isFinite(d)?d-Math.abs(p||0):void 0}return{mid:n,upper:t,lower:u}}function it(a,e,c){const n=a.length,t=new Array(n);let u=0;for(let f=0;f<n;f++){const r=a[f],s=e[f]??0;if(r==null){t[f]=void 0;continue}const i=s/Math.max(1,e[f-1]??s);u=(u*(c-1)+r*i)/c,t[f]=u}return t}function ot(a){const{seriesMap:e,calcDefs:c,len:n,params:t,lastPrevSource:u,resolveNum:f,onError:r}=a,s=t||{};for(const i of c){const m=i.name||i.type;if(!m)continue;const o=String(m).replace(/\s+/g,"_").toLowerCase(),h=String(i.type||"").toLowerCase();if(h!=="security"){if(h==="sma"){const l=i.source||"close";e[o]=R(e[l]||e.close,Math.max(1,f(i.period,`${o}_period`,14)))}else if(h==="smma"){const l=i.source||"close";e[o]=He(e[l]||e.close,Math.max(1,f(i.period,`${o}_period`,13)))}else if(h==="ema"){const l=i.source||"close";e[o]=O(e[l]||e.close,Math.max(1,f(i.period,`${o}_period`,14)))}else if(h==="wma"){const l=i.source||"close";e[o]=Re(e[l]||e.close,Math.max(1,f(i.period,`${o}_period`,14)))}else if(h==="rsi"){const l=i.source||"close";e[o]=We(e[l]||e.close,Math.max(1,f(i.period,`${o}_period`,14)))}else if(h==="bbands"||h==="bollinger"||h==="bollinger_bands"){const l=i.source||"close",w=Math.max(1,f(i.period,`${o}_period`,20)),b=Math.max(.1,f(i.std,`${o}_std`,f(i.deviation,`${o}_deviation`,2))),{mid:d,upper:N,lower:p}=we(e[l]||e.close,w,b);e[o+"_mid"]=d,e[o+"_upper"]=N,e[o+"_lower"]=p}else if(h==="atr"){const l=Math.max(1,f(i.period,`${o}_period`,14));e[o]=Q(e.high,e.low,e.close,l)}else if(h==="obv")e[o]=Ge(e.close,e.volume);else if(h==="cci"){const l=Math.max(1,f(i.period,`${o}_period`,20));e[o]=Ze(e.high,e.low,e.close,l)}else if(h==="mfi"){const l=Math.max(1,f(i.period,`${o}_period`,14));e[o]=Xe(e.high,e.low,e.close,e.volume,l)}else if(h==="ao")e[o]=Ye(e.high,e.low);else if(h==="trix"){const l=Math.max(1,f(i.period,`${o}_period`,12));e[o]=Je(e.close,l)}else if(h==="vwap")e[o]=ge(e.close,e.volume);else if(h==="vwma"){const l=Math.max(1,f(i.period,`${o}_period`,20));e[o]=Qe(e.close,e.volume,l)}else if(h==="macd"){const l=(i.source||"close").replace(/\s+/g,"_").toLowerCase(),w=Math.max(1,Number(i.fast)||12),b=Math.max(1,Number(i.slow)||26),d=Math.max(1,Number(i.signal)||9),N=e[l]||e.close,p=O(N,w),g=O(N,b),v=new Array(n);for(let E=0;E<n;E++)v[E]=p[E]===void 0||g[E]===void 0?void 0:p[E]-g[E];const y=O(v,d),M=new Array(n),S=new Array(n);for(let E=0;E<n;E++){const $=v[E],A=y[E];M[E]=typeof A=="number"&&Number.isFinite(A)?A:void 0,S[E]=$!==void 0&&A!==void 0?$-A:void 0}e.macd_line=v,e.macd_signal=M,e.macd_hist=S}else if(h==="supertrend"){const l=Math.max(1,Number(i.period)||10),w=Math.max(.1,Number(i.factor)||3);e[o]=et(e.high,e.low,e.close,l,w)}else if(h==="kc"||h==="keltner"){const l=Math.max(1,Number(i.period)||20),w=Math.max(.1,Number(i.mult)||2),b=tt(e.high,e.low,e.close,l,w);e[o+"_mid"]=b.mid,e[o+"_upper"]=b.upper,e[o+"_lower"]=b.lower}else if(h==="donchian"){const l=Math.max(1,Number(i.period)||20),w=nt(e.high,e.low,l);e[o+"_mid"]=w.mid,e[o+"_upper"]=w.upper,e[o+"_lower"]=w.lower}else if(h==="atr_bands"){const l=Math.max(1,Number(i.period)||14),w=Math.max(.1,Number(i.mult)||2),b=Q(e.high,e.low,e.close,l),d=new Array(n),N=new Array(n);for(let p=0;p<n;p++){const g=b[p],v=e.close[p];d[p]=g!=null&&v!=null?v+w*g:void 0,N[p]=g!=null&&v!=null?v-w*g:void 0}e[o+"_upper"]=d,e[o+"_lower"]=N}else if(h==="zscore"){const l=Math.max(1,Number(i.period)||20),w=i.source||"close";e[o]=Ne(e[w]||e.close,l)}else if(h==="volume_delta")e[o]=be(e.close,e.volume);else if(h==="cum_delta"){const l=be(e.close,e.volume);e[o]=st(l)}else if(h==="vwap_bands"){const l=Math.max(1,Number(i.period)||20),w=ge(e.close,e.volume),{upper:b,lower:d}=we(Array.from(w).map(N=>N),l,Math.max(.1,Number(i.std)||2));e[o+"_mid"]=Array.from(w),e[o+"_upper"]=b,e[o+"_lower"]=d}else if(h==="linreg_channel"){const l=Math.max(1,Number(i.period)||20),w=i.source||"close",b=rt(e[w]||e.close,l);e[o+"_mid"]=b.mid,e[o+"_upper"]=b.upper,e[o+"_lower"]=b.lower}else if(h==="evwma"){const l=Math.max(1,Number(i.period)||20);e[o]=it(e.close,e.volume,l)}else if(h==="sar"){const l=Math.max(.001,Number(i.step)||.02),w=Math.max(l,Number(i.max)||.2),b=e.high,d=e.low,N=new Array(n);let p=l,g=b[0],v=d[0],y=!0;for(let M=1;M<n;M++){const S=b[M]??NaN,E=d[M]??NaN;if(!Number.isFinite(S)||!Number.isFinite(E)){N[M]=void 0;continue}let $=v;y?($=v+p*(g-v),S>g&&(g=S,p=Math.min(w,p+l)),$>E&&(y=!1,$=g,g=E,p=l)):($=v-p*(v-g),E<g&&(g=E,p=Math.min(w,p+l)),$<S&&(y=!0,$=g,g=S,p=l)),N[M]=$,v=$}N[0]=v,e.sar=N}else if(h==="stoch"){const l=Number(i.kPeriod)||14,w=Number(i.dPeriod)||3,b=[],d=[];for(let p=0;p<n;p++){const g=Math.max(0,p-l+1);let v=-1/0,y=1/0;for(let $=g;$<=p;$++){const A=e.high[$]??e.close[$]??NaN,_=e.low[$]??e.close[$]??NaN;A>v&&(v=A),_<y&&(y=_)}const M=e.close[p]??NaN,S=v-y,E=S===0?void 0:100*((M-y)/S);b.push(E)}const N=R(b.map(p=>p??NaN),w);for(let p=0;p<n;p++)d.push(isNaN(N[p])?void 0:N[p]);e[o+"_k"]=b,e[o+"_d"]=d}else if(h==="roc"){const l=i.source||"close",w=e[l]||e.close,b=Math.max(1,Number(i.period)||10),d=new Array(n);for(let N=0;N<n;N++){const p=w[N],g=w[N-b];p===void 0||g===void 0||g===0?d[N]=void 0:d[N]=(p/g-1)*100}e[o]=d}else if(h==="ichimoku"){const l=Math.max(1,Number(i.tenkan)||9),w=Math.max(1,Number(i.kijun)||26),b=Math.max(1,Number(i.senkouB)||52),d=w,N=new Array(n),p=new Array(n),g=new Array(n),v=new Array(n),y=new Array(n),M=new Array(n),S=new Array(n),E=e.high,$=e.low,A=e.close,_=(k,L)=>{let C=-1/0,P=1/0;const H=Math.max(0,k-L+1);for(let K=H;K<=k;K++){const ee=E[K]??A[K]??NaN,te=$[K]??A[K]??NaN;ee>C&&(C=ee),te<P&&(P=te)}return{hi:C,lo:P}};for(let k=0;k<n;k++){if(k>=l-1){const{hi:L,lo:C}=_(k,l);N[k]=(L+C)/2}if(k>=w-1){const{hi:L,lo:C}=_(k,w);p[k]=(L+C)/2}if(N[k]!==void 0&&p[k]!==void 0&&(g[k]=(N[k]+p[k])/2),k>=b-1){const{hi:L,lo:C}=_(k,b);v[k]=(L+C)/2}S[k]=k+d<n?A[k+d]:void 0}for(let k=0;k<n;k++)y[k]=k>=d?g[k-d]:void 0,M[k]=k>=d?v[k-d]:void 0;e.tenkan=N,e.kijun=p,e.spana=y,e.spanb=M,e.chikou=S}else if(h==="pivot_high"){const l=Math.max(0,Number(i.left)||3),w=Math.max(0,Number(i.right)||3),b=new Array(n);for(let d=0;d<n;d++){const N=e.high[d]??e.close[d]??NaN;if(!Number.isFinite(N)){b[d]=void 0;continue}let p=!0;const g=Math.max(0,d-l),v=Math.min(n-1,d+w);for(let y=g;y<=v;y++){if(y===d)continue;const M=e.high[y]??e.close[y]??NaN;if(!Number.isFinite(M)){p=!1;break}if(M>=N){p=!1;break}}b[d]=p?N:void 0}e[o]=b}else if(h==="pivot_low"){const l=Math.max(0,Number(i.left)||3),w=Math.max(0,Number(i.right)||3),b=new Array(n);for(let d=0;d<n;d++){const N=e.low[d]??e.close[d]??NaN;if(!Number.isFinite(N)){b[d]=void 0;continue}let p=!0;const g=Math.max(0,d-l),v=Math.min(n-1,d+w);for(let y=g;y<=v;y++){if(y===d)continue;const M=e.low[y]??e.close[y]??NaN;if(!Number.isFinite(M)){p=!1;break}if(M<=N){p=!1;break}}b[d]=p?N:void 0}e[o]=b}else if(h==="auto_fib"||h==="autofib"){const l=Math.max(2,Math.floor(f(i.lookback,`${o}_lookback`,200))),b=String(i.direction||"up").trim().toLowerCase()==="down"?"down":"up",d=String(i.method||i.mode||"extremes").trim().toLowerCase(),N=d==="pivots"||d==="pivot"||d==="swing"?"pivots":"extremes",p=Math.max(1,Math.floor(Number(i.pivotLeft??i.left??3))),g=Math.max(1,Math.floor(Number(i.pivotRight??i.right??3))),v=Te(e.high,e.low,e.close,{lookback:l,direction:b,method:N,pivotLeft:p,pivotRight:g});e[`${o}_from`]=v.from,e[`${o}_to`]=v.to,e[`${o}_from_idx`]=v.fromIndex,e[`${o}_to_idx`]=v.toIndex,e[`${o}_0`]=v.lvl0,e[`${o}_50`]=v.lvl50,e[`${o}_100`]=v.lvl100}else if(h==="last_value"){const l=String(i.source||"close").replace(/\s+/g,"_").toLowerCase(),w=e[l]||e.close,b=new Array(n);let d;for(let N=0;N<n;N++){const p=w[N];p!=null&&Number.isFinite(p)&&(d=p),b[N]=d}e[o]=b,u[o]=l}else if(h==="prev_value"){const l=String(i.source||"close").replace(/\s+/g,"_").toLowerCase(),w=e[l]||e.close,b=new Array(n);let d,N;for(let p=0;p<n;p++){const g=w[p];if(g!=null&&Number.isFinite(g)){const v=g;(d===void 0||v!==d)&&(N=d,d=v)}b[p]=N}e[o]=b,u[o]=l}else if(h==="line_value"){const l=String(i.startValue||"").replace(/\s+/g,"_").toLowerCase(),w=String(i.endValue||"").replace(/\s+/g,"_").toLowerCase();let d=u[l]||u[w]||"";d||(/pl|low/i.test(l)||/pl|low/i.test(w)?d="pl":(/ph|high/i.test(l)||/ph|high/i.test(w))&&(d="ph"));const N=e[d],p=new Array(n);if(N){const g=[];for(let v=n-1;v>=0&&g.length<2;v--){const y=N[v];y!=null&&Number.isFinite(y)&&g.push(v)}if(g.reverse(),g.length===2){const v=g[0],y=g[1],M=N[v],S=N[y];if(Number.isFinite(M)&&Number.isFinite(S)&&y!==v){const E=(S-M)/(y-v),$=M-E*v,A=Math.max(1,Number(i.lookback)||n),_=Math.max(0,y-A);for(let k=0;k<n;k++)p[k]=k>=_?E*k+$:void 0}}}e[o]=p}else if(h==="compare"){const l=String(i.left??"").trim(),w=String(i.right??"").trim(),b=String(i.op||">"),d=/^[-+]?\d+(?:\.\d+)?$/.test(l),N=/^[-+]?\d+(?:\.\d+)?$/.test(w),p=l.replace(/\s+/g,"_").toLowerCase(),g=w.replace(/\s+/g,"_").toLowerCase(),v=d?null:e[p]||e.close,y=N?null:e[g]||e.close,M=d?Number(l):NaN,S=N?Number(w):NaN,E=new Array(n);for(let $=0;$<n;$++){const A=d?M:(v==null?void 0:v[$])??NaN,_=N?S:(y==null?void 0:y[$])??NaN;if(!Number.isFinite(A)||!Number.isFinite(_)){E[$]=0;continue}let k=!1;switch(b){case">":k=A>_;break;case"<":k=A<_;break;case">=":k=A>=_;break;case"<=":k=A<=_;break;case"==":k=Math.abs(A-_)<1e-9;break;default:k=A>_;break}E[$]=k?1:0}e[o]=E}else if(typeof i.expr=="string"&&String(i.expr).trim().length)try{const l={};Object.entries(e).forEach(([N,p])=>{const g=new Float32Array(n);for(let v=0;v<n;v++)g[v]=p[v]??NaN;l[N.replace(/\s+/g,"_").toLowerCase()]=g});const w=Y([{name:o,expr:String(i.expr).replace(/\$\{([^}]+)\}/g,(N,p)=>String(s[p]??N))}],l,s),b=new Array(n),d=w[o];for(let N=0;N<n;N++){const p=d==null?void 0:d[N];b[N]=Number.isFinite(p)?p:void 0}e[o]=b}catch(l){if(r){const w=(l==null?void 0:l.message)!=null?String(l.message):String(l);r(`Expression error: ${w}`,l)}}}}}function at(a){const e=String(a||"");let c="",n=null,t=0;const u=r=>/[A-Za-z_$]/.test(r),f=r=>/[A-Za-z0-9_$]/.test(r);for(;t<e.length;){const r=e[t];if(n){c+=r,r===n&&e[t-1]!=="\\"&&(n=null),t+=1;continue}if(r==="'"||r==='"'){n=r,c+=r,t+=1;continue}if(u(r)){let s=t+1;for(;s<e.length&&f(e[s]);)s+=1;const i=e.slice(t,s);let m=s;for(;m<e.length&&/\s/.test(e[m]);)m+=1;if(e[m]==="["){let o=m+1;for(;o<e.length&&/\s/.test(e[o]);)o+=1;let h=1;e[o]==="-"&&(h=-1,o+=1);let l=o;for(;l<e.length&&/[0-9]/.test(e[l]);)l+=1;const w=e.slice(o,l);for(;l<e.length&&/\s/.test(e[l]);)l+=1;if(w&&e[l]==="]"){const b=h*Number(w);if(Number.isFinite(b)&&b>=1){c+=`prev(${i}, ${Math.floor(b)})`,t=l+1;continue}if(Number.isFinite(b)&&b===0){c+=i,t=l+1;continue}}}c+=i,t=s;continue}c+=r,t+=1}return c}function ct(a){if(!a)return 0;let e=2166136261;for(let n=0;n<a.length;n++)e^=a.charCodeAt(n),e=Math.imul(e,16777619);const c=e>>>0;return c===0?1:c}function lt(a){const e=String(a||"");let c="",n=0;for(;n<e.length;){const t=e[n];if(t==='"'||t==="'"){const u=t;n+=1;let f="",r=!1;for(;n<e.length;){const s=e[n];if(r){f+=s,r=!1,n+=1;continue}if(s==="\\"){r=!0,n+=1;continue}if(s===u){n+=1;break}f+=s,n+=1}c+=String(ct(f));continue}c+=t,n+=1}return c}function q(a){let e=String(a||"").replace(/\bta\./g,"").replace(/\bmath\./g,"").replace(/\b(barstate|timeframe|syminfo|strategy)\.([A-Za-z0-9_]+)/gi,(c,n,t)=>`${String(n).toLowerCase()}_${t}`);return e=lt(e),at(e)}function U(a,e){const c=new Array(e);if(!a)return c.fill(void 0);for(let n=0;n<e;n++)c[n]=a[n];return c}function re(a,e){const c={};return Object.entries(a).forEach(([n,t])=>{const u=n.replace(/\s+/g,"_").toLowerCase(),f=new Float32Array(e);for(let r=0;r<e;r++)f[r]=t[r]??NaN;c[u]=f}),c}function X(a,e){const c=new Array(e);if(!a)return c;for(let n=0;n<e;n++){const t=a[n];c[n]=Number.isFinite(t)?t:void 0}return c}function ut(a,e,c,n){if(typeof e=="number"&&Number.isFinite(e))return e;if(typeof e=="string"){const t=Number(e);if(Number.isFinite(t))return t;const u=e.match(/^\$\{([^}]+)\}$/),f=u?u[1]:e,r=a[f],s=typeof r=="number"?r:Number(r);if(Number.isFinite(s))return s}if(c&&a[c]!=null){const t=a[c],u=typeof t=="number"?t:Number(t);if(Number.isFinite(u))return u}return n??0}self.onmessage=a=>{var n;const e=a.data,c=(e==null?void 0:e.id)||"unknown";try{if(!(e!=null&&e.base)||!(e!=null&&e.calc)||!(e!=null&&e.series)||!(e!=null&&e.stateSeries)){const d={id:c,seriesMap:{},error:"Invalid request"};self.postMessage(d);return}const t=((n=e.base.close)==null?void 0:n.length)??0,u={};u.open=U(e.base.open,t),u.high=U(e.base.high,t),u.low=U(e.base.low,t),u.close=U(e.base.close,t),u.volume=U(e.base.volume,t),u.time=U(e.base.time,t);const f=new Array(t);for(let d=0;d<t;d++)f[d]=d;if(u.bar_index=f,e.extraSeries&&Object.entries(e.extraSeries).forEach(([d,N])=>{u[d.replace(/\s+/g,"_").toLowerCase()]=U(N,t)}),e.params&&typeof e.params=="object"){const d=N=>{if(!u[N]){if(N==="hl2"){const p=new Array(t);for(let g=0;g<t;g++){const v=u.high[g],y=u.low[g];p[g]=v==null||y==null||!Number.isFinite(v)||!Number.isFinite(y)?void 0:(v+y)/2}u[N]=p}else if(N==="hlc3"){const p=new Array(t);for(let g=0;g<t;g++){const v=u.high[g],y=u.low[g],M=u.close[g];p[g]=v==null||y==null||M==null?void 0:(v+y+M)/3}u[N]=p}else if(N==="ohlc4"){const p=new Array(t);for(let g=0;g<t;g++){const v=u.open[g],y=u.high[g],M=u.low[g],S=u.close[g];p[g]=v==null||y==null||M==null||S==null?void 0:(v+y+M+S)/4}u[N]=p}}};Object.entries(e.params).forEach(([N,p])=>{if(typeof p!="string")return;const g=N.replace(/\s+/g,"_").toLowerCase(),v=String(p).replace(/\s+/g,"_").toLowerCase();d(v),u[v]&&(u[g]=u[v])})}const r=e.stage||"full",s=!!e.autoSortStateSeries,i=d=>{const N=[],p=[];return d.forEach(g=>{const v=String((g==null?void 0:g.expr)??"");/\b__arr_/i.test(v)?p.push(g):N.push(g)}),{primary:N,arrayDependent:p}},{primary:m,arrayDependent:o}=i(e.series||[]),h=(e.stateSeries||[]).filter(d=>/^__arr_/i.test(String((d==null?void 0:d.name)||""))),l=(e.stateSeries||[]).filter(d=>!/^__arr_/i.test(String((d==null?void 0:d.name)||"")));if(m.length&&t>0){const d=re(u,t),N=Y(m.map((p,g)=>({name:String(p.name||`series_${g}`),expr:q(String(p.expr||"").replace(/\$\{([^}]+)\}/g,(v,y)=>{var M;return String(((M=e.params)==null?void 0:M[y])??v)}))})),d,e.params);Object.entries(N).forEach(([p,g])=>{const v=p.replace(/\s+/g,"_").toLowerCase();u[v]=X(g,t)})}const w={};if(ot({seriesMap:u,calcDefs:e.calc,len:t,params:e.params,lastPrevSource:w,resolveNum:(d,N,p)=>ut(e.params||{},d,N,p)}),r!=="calc_only"&&m.length&&t>0){const d=new Set(m.map((g,v)=>String(g.name||`series_${v}`)).map(g=>g.replace(/\s+/g,"_").toLowerCase()).filter(Boolean)),N={};Object.entries(u).forEach(([g,v])=>{const y=String(g||"").replace(/\s+/g,"_").toLowerCase();if(d.has(y))return;const M=new Float32Array(t);for(let S=0;S<t;S++)M[S]=v[S]??NaN;N[y]=M});const p=Y(m.map((g,v)=>({name:String(g.name||`series_${v}`),expr:q(String(g.expr||"").replace(/\$\{([^}]+)\}/g,(y,M)=>{var S;return String(((S=e.params)==null?void 0:S[M])??y)}))})),N,e.params);Object.entries(p).forEach(([g,v])=>{const y=g.replace(/\s+/g,"_").toLowerCase();u[y]=X(v,t)})}if(r!=="calc_only"&&h.length&&t>0){const d=re(u,t),N=he(h.map((p,g)=>({name:String((p==null?void 0:p.name)||`state_${g}`),initExpr:(p==null?void 0:p.initExpr)!=null?q(String(p.initExpr).replace(/\$\{([^}]+)\}/g,(v,y)=>{var M;return String(((M=e.params)==null?void 0:M[y])??v)})):void 0,updateExpr:q(String((p==null?void 0:p.updateExpr)??(p==null?void 0:p.expr)??"").replace(/\$\{([^}]+)\}/g,(v,y)=>{var M;return String(((M=e.params)==null?void 0:M[y])??v)})),selfMode:p==null?void 0:p.selfMode})),d,e.params,void 0,{autoSort:s});Object.entries(N).forEach(([p,g])=>{const v=p.replace(/\s+/g,"_").toLowerCase();u[v]=X(g,t)})}if(r!=="calc_only"&&o.length&&t>0){const d=new Set(o.map((g,v)=>String(g.name||`series_${v}`)).map(g=>g.replace(/\s+/g,"_").toLowerCase()).filter(Boolean)),N={};Object.entries(u).forEach(([g,v])=>{const y=String(g||"").replace(/\s+/g,"_").toLowerCase();if(d.has(y))return;const M=new Float32Array(t);for(let S=0;S<t;S++)M[S]=v[S]??NaN;N[y]=M});const p=Y(o.map((g,v)=>({name:String(g.name||`series_${v}`),expr:q(String(g.expr||"").replace(/\$\{([^}]+)\}/g,(y,M)=>{var S;return String(((S=e.params)==null?void 0:S[M])??y)}))})),N,e.params);Object.entries(p).forEach(([g,v])=>{const y=g.replace(/\s+/g,"_").toLowerCase();u[y]=X(v,t)})}if(r!=="calc_only"&&l.length&&t>0){const d=re(u,t),N=he(l.map((p,g)=>({name:String((p==null?void 0:p.name)||`state_${g}`),initExpr:(p==null?void 0:p.initExpr)!=null?q(String(p.initExpr).replace(/\$\{([^}]+)\}/g,(v,y)=>{var M;return String(((M=e.params)==null?void 0:M[y])??v)})):void 0,updateExpr:q(String((p==null?void 0:p.updateExpr)??(p==null?void 0:p.expr)??"").replace(/\$\{([^}]+)\}/g,(v,y)=>{var M;return String(((M=e.params)==null?void 0:M[y])??v)})),selfMode:p==null?void 0:p.selfMode})),d,e.params,void 0,{autoSort:s});Object.entries(N).forEach(([p,g])=>{const v=p.replace(/\s+/g,"_").toLowerCase();u[v]=X(g,t)})}const b={id:c,seriesMap:u,lastPrevSource:w};self.postMessage(b)}catch(t){const u={id:c,seriesMap:{},error:String((t==null?void 0:t.message)||t)};self.postMessage(u)}}})();
