var Xe=Object.defineProperty;var Je=(j,V,U)=>V in j?Xe(j,V,{enumerable:!0,configurable:!0,writable:!0,value:U}):j[V]=U;var ee=(j,V,U)=>Je(j,typeof V!="symbol"?V+"":V,U);(function(){"use strict";const j=c=>c>="0"&&c<="9",V=c=>c>="a"&&c<="z"||c>="A"&&c<="Z"||c==="_"||c==="$";class U{constructor(e){ee(this,"pos",0);this.input=e}next(){const e=this.input,r=e.length;for(;this.pos<r&&/\s/.test(e[this.pos]??"");)this.pos++;if(this.pos>=r)return{type:"eof",start:this.pos,end:this.pos};const t=e[this.pos],i=this.pos;if(j(t)||t==="."&&j(e[this.pos+1]??"")){let n=t===".";for(this.pos++;this.pos<r;){const s=e[this.pos];if(j(s))this.pos++;else if(s==="."&&!n)n=!0,this.pos++;else break}return{type:"number",value:e.slice(i,this.pos),start:i,end:this.pos}}if(V(t)){for(this.pos++;this.pos<r;){const l=e[this.pos];if(V(l)||j(l))this.pos++;else break}const n=e.slice(i,this.pos),s=n.toLowerCase();return s==="and"?{type:"and",start:i,end:this.pos}:s==="or"?{type:"or",start:i,end:this.pos}:s==="not"?{type:"not",start:i,end:this.pos}:{type:"identifier",value:n,start:i,end:this.pos}}switch(this.pos++,t){case">":return e[this.pos]==="="?(this.pos++,{type:"gte",start:i,end:this.pos}):{type:"gt",start:i,end:this.pos};case"<":return e[this.pos]==="="?(this.pos++,{type:"lte",start:i,end:this.pos}):{type:"lt",start:i,end:this.pos};case"=":if(e[this.pos]==="=")return this.pos++,{type:"eq",start:i,end:this.pos};throw new Error(`Unexpected '=' at position ${i}`);case"!":if(e[this.pos]==="=")return this.pos++,{type:"neq",start:i,end:this.pos};throw new Error(`Unexpected '!' at position ${i}`);case"+":return{type:"plus",start:i,end:this.pos};case"-":return{type:"minus",start:i,end:this.pos};case"*":return{type:"star",start:i,end:this.pos};case"/":return{type:"slash",start:i,end:this.pos};case"%":return{type:"percent",start:i,end:this.pos};case"(":return{type:"lparen",start:i,end:this.pos};case")":return{type:"rparen",start:i,end:this.pos};case",":return{type:"comma",start:i,end:this.pos};case"?":return{type:"qmark",start:i,end:this.pos};case":":return{type:"colon",start:i,end:this.pos};default:throw new Error(`Unexpected character "${t}" at position ${i}`)}}}class B extends Error{constructor(e,r){super(e),this.position=r,this.name="ParseError"}}class he{constructor(e){ee(this,"current");this.tokenizer=e,this.current=e.next()}eat(e){if(this.current.type!==e)throw new B(`Expected ${e} but found ${this.current.type}`,this.current.start);const r=this.current;return this.current=this.tokenizer.next(),r}match(e){return this.current.type===e?(this.current=this.tokenizer.next(),!0):!1}parseExpression(){return this.parseTernary()}parseTernary(){const e=this.parseOr();if(this.current.type==="qmark"){this.current=this.tokenizer.next();const r=this.parseExpression();this.eat("colon");const t=this.parseExpression();return{kind:"CallExpression",callee:"iff",args:[e,r,t]}}return e}parseOr(){let e=this.parseAnd();for(;this.current.type==="or";){this.current=this.tokenizer.next();const r=this.parseAnd();e={kind:"BinaryExpression",operator:"or",left:e,right:r}}return e}parseAnd(){let e=this.parseComparison();for(;this.current.type==="and";){this.current=this.tokenizer.next();const r=this.parseComparison();e={kind:"BinaryExpression",operator:"and",left:e,right:r}}return e}parseComparison(){let e=this.parseAddSub();for(;this.current.type==="gt"||this.current.type==="lt"||this.current.type==="gte"||this.current.type==="lte"||this.current.type==="eq"||this.current.type==="neq";){const r=this.current;this.current=this.tokenizer.next();const t=this.parseAddSub();let i="==";r.type==="gt"?i=">":r.type==="lt"?i="<":r.type==="gte"?i=">=":r.type==="lte"?i="<=":r.type==="neq"&&(i="!="),e={kind:"BinaryExpression",operator:i,left:e,right:t}}return e}parseAddSub(){let e=this.parseTerm();for(;this.current.type==="plus"||this.current.type==="minus";){const r=this.current;this.current=this.tokenizer.next();const t=this.parseTerm();e={kind:"BinaryExpression",operator:r.type==="plus"?"+":"-",left:e,right:t}}return e}parseTerm(){let e=this.parseFactor();for(;this.current.type==="star"||this.current.type==="slash"||this.current.type==="percent";){const r=this.current;this.current=this.tokenizer.next();const t=this.parseFactor();e={kind:"BinaryExpression",operator:r.type==="star"?"*":r.type==="slash"?"/":"%",left:e,right:t}}return e}parseFactor(){if(this.current.type==="not")return this.current=this.tokenizer.next(),{kind:"UnaryExpression",operator:"not",expr:this.parseFactor()};if(this.current.type==="plus"||this.current.type==="minus"){const e=this.current.type==="minus";this.current=this.tokenizer.next();const r=this.parseFactor();return e?{kind:"BinaryExpression",operator:"*",left:{kind:"NumberLiteral",value:-1},right:r}:r}return this.parsePrimary()}parsePrimary(){const e=this.current;switch(e.type){case"number":{this.current=this.tokenizer.next();const r=Number(e.value);if(!Number.isFinite(r))throw new B("Invalid number literal",e.start);return{kind:"NumberLiteral",value:r}}case"identifier":{this.current=this.tokenizer.next();const r=(e.value||"").toString();if(this.current.type==="lparen"){this.eat("lparen");const t=[];if(this.current.type!=="rparen")for(;t.push(this.parseExpression()),!!this.match("comma"););return this.eat("rparen"),{kind:"CallExpression",callee:r,args:t}}return{kind:"Identifier",name:r}}case"lparen":{this.eat("lparen");const r=this.parseExpression();return this.eat("rparen"),r}default:throw new B(`Unexpected token ${e.type}`,e.start)}}}function Q(c){const e=new he(new U(c)),r=e.parseExpression();if(e.current.type!=="eof")throw new B("Unexpected input after end of expression",e.current.start);return r}class k extends Error{constructor(e){super(e),this.name="ExpressionEngineError"}}function me(c,e){const r=c.length,t=new Float32Array(r);let i=0;for(let n=0;n<r;n++){const s=c[n];if(Number.isFinite(s)&&(i+=s),n>=e){const l=c[n-e];Number.isFinite(l)&&(i-=l)}t[n]=n>=e-1?i:NaN}return t}function pe(c,e){const r=c.length,t=new Float32Array(r),i=Math.max(1,Math.floor(e));for(let n=0;n<r;n++){const s=n-i,l=c[n],f=s>=0?c[s]:NaN;t[n]=Number.isFinite(l)&&Number.isFinite(f)?l-f:NaN}return t}function _(c,e){if(c.kind==="series")return c.value;const r=new Float32Array(e.length);return r.fill(c.value),r}function q(c){if(c.kind==="scalar")return c.value;const e=c.value;return e.length?e[e.length-1]:NaN}function de(c,e){const r=c.length,t=new Float32Array(r);for(let i=0;i<r;i++)t[i]=e(c[i]);return t}function ge(c,e,r){const t=c.length,i=new Float32Array(t);for(let n=0;n<t;n++)i[n]=r(c[n],e[n]);return i}function we(c,e,r,t){const i=e.kind==="series",n=r.kind==="series",s=o=>Number.isFinite(o)&&o!==0;if(!i&&!n){const o=e.value,h=r.value;switch(c){case"+":return{kind:"scalar",value:o+h};case"-":return{kind:"scalar",value:o-h};case"*":return{kind:"scalar",value:o*h};case"/":return{kind:"scalar",value:h===0?NaN:o/h};case"%":return{kind:"scalar",value:h===0?NaN:o%h};case">":return{kind:"scalar",value:Number.isFinite(o)&&Number.isFinite(h)&&o>h?1:0};case"<":return{kind:"scalar",value:Number.isFinite(o)&&Number.isFinite(h)&&o<h?1:0};case">=":return{kind:"scalar",value:Number.isFinite(o)&&Number.isFinite(h)&&o>=h?1:0};case"<=":return{kind:"scalar",value:Number.isFinite(o)&&Number.isFinite(h)&&o<=h?1:0};case"==":return{kind:"scalar",value:Number.isFinite(o)&&Number.isFinite(h)&&Math.abs(o-h)<1e-9?1:0};case"!=":return{kind:"scalar",value:Number.isFinite(o)&&Number.isFinite(h)&&Math.abs(o-h)>=1e-9?1:0};case"and":return{kind:"scalar",value:s(o)&&s(h)?1:0};case"or":return{kind:"scalar",value:s(o)||s(h)?1:0}}}const l=_(e,t),f=_(r,t),a=t.length,m=new Float32Array(a);for(let o=0;o<a;o++){const h=l[o],u=f[o];switch(c){case"+":m[o]=h+u;break;case"-":m[o]=h-u;break;case"*":m[o]=h*u;break;case"/":m[o]=u===0?NaN:h/u;break;case"%":m[o]=u===0?NaN:h%u;break;case">":m[o]=Number.isFinite(h)&&Number.isFinite(u)&&h>u?1:0;break;case"<":m[o]=Number.isFinite(h)&&Number.isFinite(u)&&h<u?1:0;break;case">=":m[o]=Number.isFinite(h)&&Number.isFinite(u)&&h>=u?1:0;break;case"<=":m[o]=Number.isFinite(h)&&Number.isFinite(u)&&h<=u?1:0;break;case"==":m[o]=Number.isFinite(h)&&Number.isFinite(u)&&Math.abs(h-u)<1e-9?1:0;break;case"!=":m[o]=Number.isFinite(h)&&Number.isFinite(u)&&Math.abs(h-u)>=1e-9?1:0;break;case"and":m[o]=s(h)&&s(u)?1:0;break;case"or":m[o]=s(h)||s(u)?1:0;break}}return{kind:"series",value:m}}function be(c,e){const r=c.length,t=new Float32Array(r);let i=0,n=0;for(let s=0;s<r;s++){const l=c[s];if(Number.isFinite(l)&&(i+=l,n+=1),s>=e){const f=c[s-e];Number.isFinite(f)&&(i-=f,n-=1)}s>=e-1?t[s]=n>0?i/n:NaN:t[s]=NaN}return t}function Ne(c,e){const r=c.length,t=new Float32Array(r),i=2/(e+1);let n;for(let s=0;s<r;s++){const l=c[s];if(!Number.isFinite(l)){t[s]=n===void 0?NaN:n;continue}if(n===void 0||!Number.isFinite(n)){n=l,t[s]=l;continue}n=l*i+n*(1-i),t[s]=n}return t}function te(c,e){const r=c.length,t=new Float32Array(r);let i,n=0,s=0;for(let l=0;l<r;l++){const f=c[l];if(i===void 0){if(Number.isFinite(f)&&(n+=f,s+=1),s<e){t[l]=NaN;continue}i=n/e,t[l]=i;continue}Number.isFinite(f)&&(i=(i*(e-1)+f)/e),t[l]=i}return t}function ve(c,e){const r=c.length,t=new Float32Array(r);let i,n=0,s=0,l=!1;const f=[],a=[];for(let m=0;m<r;m++){const o=c[m];if(!Number.isFinite(o)){t[m]=NaN;continue}if(i===void 0){i=o,t[m]=NaN;continue}if(!Number.isFinite(i)){i=o,t[m]=NaN;continue}const h=o-i;i=o;const u=h>0?h:0,b=h<0?-h:0;if(l)n=(n*(e-1)+u)/e,s=(s*(e-1)+b)/e;else{f.push(u),a.push(b);const g=f.length,w=Math.max(1,Math.min(e,g));n=f.reduce((d,p)=>d+p,0)/w,s=a.reduce((d,p)=>d+p,0)/w,g>=e&&(l=!0)}if(s===0)t[m]=100;else{const g=n/s;t[m]=100-100/(1+g)}}return t}function ye(c,e){const r=c.length,t=new Float32Array(r);for(let i=0;i<r;i++){if(i<e-1){t[i]=NaN;continue}let n=0,s=0;for(let a=i-e+1;a<=i;a++){const m=c[a];Number.isFinite(m)&&(n+=m,s+=1)}if(s<2){t[i]=NaN;continue}const l=n/s;let f=0;for(let a=i-e+1;a<=i;a++){const m=c[a];if(!Number.isFinite(m))continue;const o=m-l;f+=o*o}t[i]=Math.sqrt(f/s)}return t}function ke(c,e){const r=c.length,t=new Float32Array(r);for(let i=0;i<r;i++){if(i<e-1){t[i]=NaN;continue}let n=0,s=0;for(let l=0;l<e;l++){const f=c[i-l],a=e-l;Number.isFinite(f)&&(n+=f*a,s+=a)}t[i]=s>0?n/s:NaN}return t}function Me(c,e){const r=c.length,t=new Float32Array(r);for(let i=0;i<r;i++){let n=-1/0,s=!1;const l=Math.max(0,i-e+1);for(let f=l;f<=i;f++){const a=c[f];Number.isFinite(a)&&(s=!0,a>n&&(n=a))}t[i]=s?n:NaN}return t}function Fe(c,e){const r=c.length,t=new Float32Array(r);for(let i=0;i<r;i++){let n=1/0,s=!1;const l=Math.max(0,i-e+1);for(let f=l;f<=i;f++){const a=c[f];Number.isFinite(a)&&(s=!0,a<n&&(n=a))}t[i]=s?n:NaN}return t}function Ae(c,e){const r=c.callee.toLowerCase(),t=c.args.map(n=>T(n,e)),i=()=>{if(t.length!==2)throw new k(`${r} expects (series, period)`);const n=_(t[0],e),s=Math.max(1,Math.floor(q(t[1])));return[n,s]};switch(r){case"iff":case"iif":case"if":{if(t.length!==3)throw new k(`${c.callee} expects (cond, a, b)`);const n=t[0],s=t[1],l=t[2],f=n.kind==="series",a=s.kind==="series",m=l.kind==="series";if(!f&&!a&&!m){const w=n.value;return{kind:"scalar",value:Number.isFinite(w)&&w!==0?s.value:l.value}}const o=_(n,e),h=_(s,e),u=_(l,e),b=e.length,g=new Float32Array(b);for(let w=0;w<b;w++){const d=o[w],p=Number.isFinite(d)&&d!==0;g[w]=p?h[w]:u[w]}return{kind:"series",value:g}}case"nz":{if(t.length<1||t.length>2)throw new k("nz expects (series[, fallback])");const n=t[0],s=t[1]??{kind:"scalar",value:0};if(n.kind==="scalar"&&s.kind==="scalar")return{kind:"scalar",value:Number.isFinite(n.value)?n.value:s.value};const l=_(n,e),f=_(s,e),a=e.length,m=new Float32Array(a);for(let o=0;o<a;o++){const h=l[o];m[o]=Number.isFinite(h)?h:f[o]}return{kind:"series",value:m}}case"add":case"sub":case"mul":case"div":{if(t.length!==2)throw new k(`${r} expects 2 arguments`);const n=t[0],s=t[1];if(n.kind==="scalar"&&s.kind==="scalar"){const o=n.value,h=s.value;return r==="add"?{kind:"scalar",value:o+h}:r==="sub"?{kind:"scalar",value:o-h}:r==="mul"?{kind:"scalar",value:o*h}:{kind:"scalar",value:h===0?NaN:o/h}}const l=_(n,e),f=_(s,e),a=e.length,m=new Float32Array(a);for(let o=0;o<a;o++){const h=l[o],u=f[o];r==="add"?m[o]=h+u:r==="sub"?m[o]=h-u:r==="mul"?m[o]=h*u:m[o]=u===0?NaN:h/u}return{kind:"series",value:m}}case"pow":{if(t.length!==2)throw new k("pow expects 2 arguments");const n=t[0],s=t[1];if(n.kind==="scalar"&&s.kind==="scalar")return{kind:"scalar",value:Math.pow(n.value,s.value)};const l=_(n,e),f=_(s,e);return{kind:"series",value:ge(l,f,(a,m)=>Math.pow(a,m))}}case"sqrt":case"log":case"log10":case"exp":case"floor":case"ceil":case"round":case"sin":case"cos":case"tan":case"asin":case"acos":case"atan":case"sign":{if(t.length!==1)throw new k(`${r} expects 1 argument`);const n=r==="sqrt"?Math.sqrt:r==="log"?Math.log:r==="log10"?Math.log10:r==="exp"?Math.exp:r==="floor"?Math.floor:r==="ceil"?Math.ceil:r==="round"?Math.round:r==="sin"?Math.sin:r==="cos"?Math.cos:r==="tan"?Math.tan:r==="asin"?Math.asin:r==="acos"?Math.acos:r==="atan"?Math.atan:Math.sign,s=t[0];return s.kind==="scalar"?{kind:"scalar",value:n(s.value)}:{kind:"series",value:de(_(s,e),n)}}case"cum":case"cumsum":{if(t.length!==1)throw new k(`${r} expects 1 argument`);const n=_(t[0],e),s=e.length,l=new Float32Array(s);let f=0;for(let a=0;a<s;a++){const m=n[a];Number.isFinite(m)&&(f+=m),l[a]=f}return{kind:"series",value:l}}case"barssince":{if(t.length!==1)throw new k("barssince expects (condition)");const n=_(t[0],e),s=e.length,l=new Float32Array(s);let f=NaN;for(let a=0;a<s;a++){const m=n[a];Number.isFinite(m)&&m!==0?(f=0,l[a]=0):Number.isFinite(f)?(f+=1,l[a]=f):l[a]=NaN}return{kind:"series",value:l}}case"sma":{const[n,s]=i();return{kind:"series",value:be(n,s)}}case"wma":{const[n,s]=i();return{kind:"series",value:ke(n,s)}}case"ema":{const[n,s]=i();return{kind:"series",value:Ne(n,s)}}case"smma":{const[n,s]=i();return{kind:"series",value:te(n,s)}}case"rsi":{const[n,s]=i();return{kind:"series",value:ve(n,s)}}case"rma":{const[n,s]=i();return{kind:"series",value:te(n,s)}}case"tr":{if(t.length!==0&&t.length!==3)throw new k("tr expects () or (high, low, close)");const n=t.length===3?_(t[0],e):e.series.high,s=t.length===3?_(t[1],e):e.series.low,l=t.length===3?_(t[2],e):e.series.close;if(!n||!s||!l)throw new k("tr requires high/low/close series");const f=e.length,a=new Float32Array(f);let m=NaN;for(let o=0;o<f;o++){const h=n[o],u=s[o],b=l[o];let g=Math.max(0,h-u);Number.isFinite(m)&&(g=Math.max(g,Math.abs(h-m),Math.abs(u-m))),a[o]=g,m=b}return{kind:"series",value:a}}case"atr":{if(t.length!==4)throw new k("atr expects (high, low, close, period)");const n=_(t[0],e),s=_(t[1],e),l=_(t[2],e),f=Math.max(1,Math.floor(q(t[3]))),a=e.length,m=new Float32Array(a);let o=NaN;for(let b=0;b<a;b++){const g=n[b],w=s[b],d=l[b];let p=Math.max(0,g-w);Number.isFinite(o)&&(p=Math.max(p,Math.abs(g-o),Math.abs(w-o))),m[b]=p,o=d}const h=new Float32Array(a);let u=0;for(let b=0;b<a;b++)u+=m[b],b===f-1?h[b]=u/f:b>=f?h[b]=(h[b-1]*(f-1)+m[b])/f:h[b]=NaN;return{kind:"series",value:h}}case"stdev":{const[n,s]=i();return{kind:"series",value:ye(n,s)}}case"highest":{const[n,s]=i();return{kind:"series",value:Me(n,s)}}case"lowest":{const[n,s]=i();return{kind:"series",value:Fe(n,s)}}case"sum":{const[n,s]=i();return{kind:"series",value:me(n,s)}}case"lag":{const[n,s]=i();return{kind:"series",value:se(n,s)}}case"prev":{if(t.length<1||t.length>2)throw new k("prev expects (series[, n])");const n=_(t[0],e),s=Math.max(1,Math.floor(q(t[1]??{kind:"scalar",value:1})));return{kind:"series",value:se(n,s)}}case"change":{if(t.length<1||t.length>2)throw new k("change expects (series[, n])");const n=_(t[0],e),s=Math.max(1,Math.floor(q(t[1]??{kind:"scalar",value:1})));return{kind:"series",value:pe(n,s)}}case"crossover":case"crossunder":{if(t.length<2||t.length>3)throw new k(`${c.callee} expects (series, series[, tol])`);const n=_(t[0],e),s=t[1],l=s.kind==="series",f=_(s,e),a=t[2]?Math.max(0,q(t[2])):0,m=e.length,o=new Float32Array(m);o[0]=0;for(let h=1;h<m;h++){const u=n[h-1],b=n[h],g=l?f[h-1]:f[0],w=l?f[h]:f[0];if(![u,b,g,w].every(Number.isFinite)){o[h]=0;continue}r==="crossover"?o[h]=u<=g+a&&b>w+a?1:0:o[h]=u>=g-a&&b<w-a?1:0}return{kind:"series",value:o}}case"hl2":{if(t.length!==0)throw new k("hl2 expects no arguments");const n=e.series.high,s=e.series.low;if(!n||!s)throw new k("hl2 requires high/low series");const l=e.length,f=new Float32Array(l);for(let a=0;a<l;a++)f[a]=(n[a]+s[a])/2;return{kind:"series",value:f}}case"hlc3":{if(t.length!==0)throw new k("hlc3 expects no arguments");const n=e.series.high,s=e.series.low,l=e.series.close;if(!n||!s||!l)throw new k("hlc3 requires high/low/close series");const f=e.length,a=new Float32Array(f);for(let m=0;m<f;m++)a[m]=(n[m]+s[m]+l[m])/3;return{kind:"series",value:a}}case"ohlc4":{if(t.length!==0)throw new k("ohlc4 expects no arguments");const n=e.series.open,s=e.series.high,l=e.series.low,f=e.series.close;if(!n||!s||!l||!f)throw new k("ohlc4 requires open/high/low/close series");const a=e.length,m=new Float32Array(a);for(let o=0;o<a;o++)m[o]=(n[o]+s[o]+l[o]+f[o])/4;return{kind:"series",value:m}}case"vwap":{if(t.length!==2)throw new k("vwap expects (close, volume)");const n=_(t[0],e),s=_(t[1],e),l=e.length,f=new Float32Array(l);let a=0,m=0;for(let o=0;o<l;o++){const h=n[o],u=s[o];if(!Number.isFinite(h)||!Number.isFinite(u)){f[o]=NaN;continue}a+=h*u,m+=u,f[o]=m===0?NaN:a/m}return{kind:"series",value:f}}case"vwma":{if(t.length!==3)throw new k("vwma expects (close, volume, period)");const n=_(t[0],e),s=_(t[1],e),l=Math.max(1,Math.floor(q(t[2]))),f=e.length,a=new Float32Array(f);let m=0,o=0;for(let h=0;h<f;h++){const u=n[h],b=s[h];if(Number.isFinite(u)&&Number.isFinite(b)&&(m+=u*b,o+=b),h>=l){const g=n[h-l],w=s[h-l];Number.isFinite(g)&&Number.isFinite(w)&&(m-=g*w,o-=w)}a[h]=h>=l-1&&o!==0?m/o:NaN}return{kind:"series",value:a}}case"min":{if(t.length!==2)throw new k("min expects 2 arguments");const n=t[0],s=t[1];if(n.kind==="scalar"&&s.kind==="scalar")return{kind:"scalar",value:Math.min(n.value,s.value)};const l=_(n,e),f=_(s,e),a=e.length,m=new Float32Array(a);for(let o=0;o<a;o++)m[o]=Math.min(l[o],f[o]);return{kind:"series",value:m}}case"max":{if(t.length!==2)throw new k("max expects 2 arguments");const n=t[0],s=t[1];if(n.kind==="scalar"&&s.kind==="scalar")return{kind:"scalar",value:Math.max(n.value,s.value)};const l=_(n,e),f=_(s,e),a=e.length,m=new Float32Array(a);for(let o=0;o<a;o++)m[o]=Math.max(l[o],f[o]);return{kind:"series",value:m}}case"abs":{if(t.length!==1)throw new k("abs expects 1 argument");const n=t[0];if(n.kind==="scalar")return{kind:"scalar",value:Math.abs(n.value)};const s=n.value,l=e.length,f=new Float32Array(l);for(let a=0;a<l;a++)f[a]=Math.abs(s[a]);return{kind:"series",value:f}}default:throw new k(`Unknown function "${c.callee}"`)}}function T(c,e){var r;switch(c.kind){case"NumberLiteral":return{kind:"scalar",value:c.value};case"Identifier":{const t=c.name.replace(/\s+/g,"_").toLowerCase();if(t==="na"||t==="nan")return{kind:"scalar",value:NaN};const i=e.series[t];if(i)return{kind:"series",value:i};const n=(r=e.scalars)==null?void 0:r[t];if(typeof n=="number"&&Number.isFinite(n))return{kind:"scalar",value:n};throw e.seriesNames.has(t)?new k(`Series "${c.name}" is used before it is defined (circular or forward reference)`):new k(`Unknown identifier "${c.name}"`)}case"UnaryExpression":{const t=T(c.expr,e);if(c.operator==="not"){if(t.kind==="scalar"){const s=t.value;return{kind:"scalar",value:Number.isFinite(s)&&s!==0?0:1}}const i=t.value,n=new Float32Array(i.length);for(let s=0;s<i.length;s++){const l=i[s];n[s]=Number.isFinite(l)&&l!==0?0:1}return{kind:"series",value:n}}throw new k("Unsupported unary operator")}case"BinaryExpression":return we(c.operator,T(c.left,e),T(c.right,e),e);case"CallExpression":return Ae(c,e);default:throw new k("Unsupported expression node")}}function G(c,e,r){var d;const t=new Set;for(const p of c){const N=p.name.replace(/\s+/g,"_").toLowerCase();t.add(N)}const i=Object.entries(e),n=((d=i[0])==null?void 0:d[1].length)??0;for(const[,p]of i)if(p.length!==n)throw new k("All base series must have the same length");const s=c.map(p=>{try{const N=Q(p.expr);return{name:p.name.replace(/\s+/g,"_").toLowerCase(),expr:p.expr,ast:N}}catch(N){throw N instanceof B?new k(`Syntax error in series "${p.name}" at position ${N.position}: ${N.message}`):N}}),l={length:n,series:{...e},seriesNames:t,scalars:(()=>{if(!r||typeof r!="object")return;const p={};return Object.entries(r).forEach(([N,v])=>{const y=N.replace(/\s+/g,"_").toLowerCase();if(typeof v=="number"&&Number.isFinite(v)){p[y]=v;return}if(typeof v=="string"){const F=Number(v);Number.isFinite(F)&&(p[y]=F)}}),Object.keys(p).length?p:void 0})()},f={},a=p=>{const N=new Set,v=y=>{switch(y.kind){case"Identifier":{const F=y.name.replace(/\s+/g,"_").toLowerCase();N.add(F);break}case"BinaryExpression":v(y.left),v(y.right);break;case"UnaryExpression":v(y.expr);break;case"CallExpression":y.args.forEach(F=>v(F));break}};return v(p),N},m=new Set(s.map(p=>p.name)),o={},h={};s.forEach(p=>{o[p.name]=new Set,h[p.name]=new Set}),s.forEach(p=>{a(p.ast).forEach(v=>{m.has(v)&&v!==p.name&&(o[p.name].add(v),h[v].add(p.name))})});const u={};Object.keys(o).forEach(p=>{var N;u[p]=((N=o[p])==null?void 0:N.size)??0});const b=Object.keys(u).filter(p=>(u[p]||0)===0),g=[];for(;b.length;){const p=b.shift();g.push(p);for(const N of h[p]||[])u[N]=(u[N]||0)-1,u[N]===0&&b.push(N)}if(g.length!==s.length){const p=s.map(N=>N.name).filter(N=>!g.includes(N));throw new k(`Circular dependency detected among series: ${p.join(" -> ")}`)}const w={};s.forEach(p=>{w[p.name]=p});for(const p of g){const N=w[p];if(l.series[N.name])throw new k(`Series name "${N.name}" conflicts with an existing base series`);const v=T(N.ast,l),y=_(v,l);l.series[N.name]=y,f[N.name]=y}return f}function Se(c,e){var n;const r=c.replace(/\s+/g,"_").toLowerCase();if(r==="na"||r==="nan")return NaN;if(e.selfKey&&e.selfOut&&r===e.selfKey){if(e.selfMode==="current"){const l=e.selfOut[e.index];if(Number.isFinite(l))return l}const s=e.index-1;return s>=0?e.selfOut[s]:NaN}const t=e.series[r];if(t)return t[e.index]??NaN;const i=(n=e.scalars)==null?void 0:n[r];if(typeof i=="number"&&Number.isFinite(i))return i;throw new k(`Unknown identifier "${c}"`)}function C(c,e){switch(c.kind){case"NumberLiteral":return c.value;case"Identifier":return Se(c.name,e);case"UnaryExpression":{if(c.operator==="not"){const r=C(c.expr,e);return Number.isFinite(r)&&r!==0?0:1}return NaN}case"BinaryExpression":{const r=C(c.left,e),t=C(c.right,e);switch(c.operator){case"+":return r+t;case"-":return r-t;case"*":return r*t;case"/":return t===0?NaN:r/t;case"%":return t===0?NaN:r%t;case">":return Number.isFinite(r)&&Number.isFinite(t)&&r>t?1:0;case"<":return Number.isFinite(r)&&Number.isFinite(t)&&r<t?1:0;case">=":return Number.isFinite(r)&&Number.isFinite(t)&&r>=t?1:0;case"<=":return Number.isFinite(r)&&Number.isFinite(t)&&r<=t?1:0;case"==":return Number.isFinite(r)&&Number.isFinite(t)&&Math.abs(r-t)<1e-9?1:0;case"!=":return Number.isFinite(r)&&Number.isFinite(t)&&Math.abs(r-t)>=1e-9?1:0;case"and":return Number.isFinite(r)&&r!==0&&Number.isFinite(t)&&t!==0?1:0;case"or":return Number.isFinite(r)&&r!==0||Number.isFinite(t)&&t!==0?1:0;default:return NaN}}case"CallExpression":{const r=c.callee.toLowerCase(),t=c.args[0],i=c.args[1];if(r==="nz"){if(c.args.length<1||c.args.length>2)throw new k("nz expects (x[, fallback])");const n=C(t,e);return Number.isFinite(n)?n:c.args.length===2?C(i,e):0}if(r==="iff"||r==="iif"||r==="if"){if(c.args.length!==3)throw new k(`${c.callee} expects (cond, a, b)`);const n=C(t,e),s=Number.isFinite(n)&&n!==0,l=C(c.args[1],e),f=C(c.args[2],e);return s?l:f}if(r==="add"||r==="sub"||r==="mul"||r==="div"){if(c.args.length!==2)throw new k(`${c.callee} expects 2 arguments`);const n=C(t,e),s=C(i,e);return r==="add"?n+s:r==="sub"?n-s:r==="mul"?n*s:s===0?NaN:n/s}if(r==="min"||r==="max"){if(c.args.length!==2)throw new k(`${c.callee} expects 2 arguments`);const n=C(t,e),s=C(i,e);return r==="min"?Math.min(n,s):Math.max(n,s)}if(r==="abs"){if(c.args.length!==1)throw new k("abs expects 1 argument");return Math.abs(C(t,e))}if(r==="pow"){if(c.args.length!==2)throw new k("pow expects 2 arguments");const n=C(t,e),s=C(i,e);return Math.pow(n,s)}if(r==="sqrt"||r==="log"||r==="log10"||r==="exp"||r==="floor"||r==="ceil"||r==="round"||r==="sin"||r==="cos"||r==="tan"||r==="asin"||r==="acos"||r==="atan"||r==="sign"){if(c.args.length!==1)throw new k(`${c.callee} expects 1 argument`);const n=C(t,e);switch(r){case"sqrt":return Math.sqrt(n);case"log":return Math.log(n);case"log10":return Math.log10(n);case"exp":return Math.exp(n);case"floor":return Math.floor(n);case"ceil":return Math.ceil(n);case"round":return Math.round(n);case"sin":return Math.sin(n);case"cos":return Math.cos(n);case"tan":return Math.tan(n);case"asin":return Math.asin(n);case"acos":return Math.acos(n);case"atan":return Math.atan(n);default:return Math.sign(n)}}if(r==="cum"||r==="cumsum"){if(c.args.length!==1)throw new k(`${c.callee} expects 1 argument`);const n=t;if(n.kind!=="Identifier")throw new k(`${c.callee} expects a series identifier`);const s=n.name.replace(/\s+/g,"_").toLowerCase(),l=e.series[s];if(!l)throw new k(`Unknown identifier "${n.name}"`);let f=0;for(let a=0;a<=e.index;a++){const m=l[a];Number.isFinite(m)&&(f+=m)}return f}if(r==="barssince"){if(c.args.length!==1)throw new k("barssince expects (condition)");const n=t;if(n.kind!=="Identifier")throw new k("barssince expects a series identifier");const s=n.name.replace(/\s+/g,"_").toLowerCase(),l=e.series[s];if(!l)throw new k(`Unknown identifier "${n.name}"`);for(let f=e.index;f>=0;f--){const a=l[f];if(Number.isFinite(a)&&a!==0)return e.index-f}return NaN}if(r==="tr"){if(c.args.length!==0&&c.args.length!==3)throw new k("tr expects () or (high, low, close)");const n=(u,b)=>{if(!u){const d=e.series[b];if(!d)throw new k(`Unknown identifier "${b}"`);return d}if(u.kind!=="Identifier")throw new k("tr expects series identifiers");const g=u.name.replace(/\s+/g,"_").toLowerCase(),w=e.series[g];if(!w)throw new k(`Unknown identifier "${u.name}"`);return w},s=n(c.args[0],"high"),l=n(c.args[1],"low"),f=n(c.args[2],"close"),a=s[e.index],m=l[e.index],o=e.index>0?f[e.index-1]:NaN;let h=Math.max(0,a-m);return Number.isFinite(o)&&(h=Math.max(h,Math.abs(a-o),Math.abs(m-o))),h}if(r==="prev"||r==="lag"||r==="change"){if(c.args.length!==2)throw new k(`${c.callee} expects (series, n)`);const n=t;if(n.kind!=="Identifier")throw new k(`${c.callee} expects first argument to be a series identifier`);const s=n.name.replace(/\s+/g,"_").toLowerCase(),l=C(i,e),f=Math.max(1,Math.floor(l)),a=e.index-f,m=u=>{if(u<0)return NaN;if(e.selfKey&&e.selfOut&&s===e.selfKey)return e.selfOut[u]??NaN;const b=e.series[s];if(!b)throw new k(`Unknown identifier "${n.name}"`);return b[u]??NaN};if(r==="prev"||r==="lag")return m(a);const o=m(e.index),h=m(a);return Number.isFinite(o)&&Number.isFinite(h)?o-h:NaN}if(r==="crossover"||r==="crossunder"){if(c.args.length<2||c.args.length>3)throw new k(`${c.callee} expects (series, series[, tol])`);const n=t;if(n.kind!=="Identifier")throw new k(`${c.callee} expects first argument to be a series identifier`);const s=n.name.replace(/\s+/g,"_").toLowerCase(),l=e.series[s];if(!l)throw new k(`Unknown identifier "${n.name}"`);const f=c.args[1];let a=null,m=NaN;if(f.kind==="Identifier"){const w=f.name.replace(/\s+/g,"_").toLowerCase();if(a=e.series[w]||null,!a){const d=Number(f.name);m=Number.isFinite(d)?d:NaN}}else m=C(f,e);const o=c.args[2]?Math.max(0,C(c.args[2],e)):0;if(e.index<=0)return 0;const h=l[e.index-1],u=l[e.index],b=a?a[e.index-1]:m,g=a?a[e.index]:m;return[h,u,b,g].every(Number.isFinite)?r==="crossover"?h<=b+o&&u>g+o?1:0:h>=b-o&&u<g-o?1:0:0}throw new k(`Unknown function "${c.callee}"`)}default:return NaN}}function ne(c,e,r){var m;const t=Object.entries(e),i=((m=t[0])==null?void 0:m[1].length)??0;for(const[,o]of t)if(o.length!==i)throw new k("All base series must have the same length");const n=(()=>{if(!r||typeof r!="object")return;const o={};return Object.entries(r).forEach(([h,u])=>{const b=h.replace(/\s+/g,"_").toLowerCase();if(typeof u=="number"&&Number.isFinite(u)){o[b]=u;return}if(typeof u=="string"){const g=Number(u);Number.isFinite(g)&&(o[b]=g)}}),Object.keys(o).length?o:void 0})(),s=c.map(o=>{const h=o.name.replace(/\s+/g,"_").toLowerCase();try{const u=o.initExpr?Q(o.initExpr):null,b=Q(o.updateExpr);return{name:h,initAst:u,updateAst:b,initExpr:o.initExpr,updateExpr:o.updateExpr,selfMode:o.selfMode}}catch(u){throw u instanceof B?new k(`Syntax error in series "${o.name}" at position ${u.position}: ${u.message}`):u}}),l={},f={...e},a=new Set(Object.keys(e));for(const o of s){if(a.has(o.name))throw new k(`Series name "${o.name}" conflicts with an existing base series`);if(f[o.name])l[o.name]||(l[o.name]=f[o.name]);else{const h=new Float32Array(i);h.fill(NaN),f[o.name]=h,l[o.name]=h}}for(let o=0;o<i;o++)for(const h of s){const u=l[h.name],b={series:f,scalars:n,length:i,index:o,selfKey:h.name,selfOut:u,selfMode:h.selfMode},g=o===0&&h.initAst?h.initAst:h.updateAst,w=C(g,b);u[o]=w}return l}function se(c,e){const r=c.length,t=new Float32Array(r);for(let i=0;i<r;i++){const n=i-e;t[i]=n>=0?c[n]:NaN}return t}function X(c){return typeof c=="number"&&Number.isFinite(c)}function H(c,e,r){const t=c[r];if(X(t))return t;const i=e[r];return X(i)?i:NaN}function W(c,e,r){const t=c[r];if(X(t))return t;const i=e[r];return X(i)?i:NaN}function re(c,e,r,t){let i=-1,n=-1/0;for(let s=r;s<=t;s++){const l=H(c,e,s);Number.isFinite(l)&&l>n&&(n=l,i=s)}return i}function ie(c,e,r,t){let i=-1,n=1/0;for(let s=r;s<=t;s++){const l=W(c,e,s);Number.isFinite(l)&&l<n&&(n=l,i=s)}return i}function xe(c,e,r,t,i){const n=Math.min(c.length,e.length,r.length);if(n<=1)return null;const s=Math.min(n-1,Math.max(0,Math.trunc(t))),l=Math.max(2,Math.trunc(i.lookback||200)),f=Math.max(0,s-l+1),a=i.direction==="down"?"down":"up";if((i.method==="pivots"?"pivots":"extremes")==="pivots"){const g=Math.max(1,Math.floor(Number(i.pivotLeft??3))),w=Math.max(1,Math.floor(Number(i.pivotRight??3))),d=s;if(d<w)return null;const p=[],N=[],v=A=>{const S=H(c,r,A);if(!Number.isFinite(S))return null;const M=Math.max(0,A-g),L=Math.min(d,A+w);if(L<A+w)return null;for(let I=M;I<=L;I++){if(I===A)continue;const O=H(c,r,I);if(!Number.isFinite(O)||O>=S)return null}return S},y=A=>{const S=W(e,r,A);if(!Number.isFinite(S))return null;const M=Math.max(0,A-g),L=Math.min(d,A+w);if(L<A+w)return null;for(let I=M;I<=L;I++){if(I===A)continue;const O=W(e,r,I);if(!Number.isFinite(O)||O<=S)return null}return S},F=Math.max(f,0),E=Math.min(s-w,s);for(let A=F;A<=E;A++){const S=v(A);S!=null&&p.push({index:A,value:S});const M=y(A);M!=null&&N.push({index:A,value:M})}const x=p.length?p[p.length-1]:null,$=N.length?N[N.length-1]:null;if(!(!x||!$))if(a==="up"){let A=null;for(let S=N.length-1;S>=0;S--)if(N[S].index<x.index){A=N[S];break}if(A)return{fromIndex:A.index,toIndex:x.index,fromValue:A.value,toValue:x.value}}else{let A=null;for(let S=p.length-1;S>=0;S--)if(p[S].index<$.index){A=p[S];break}if(A)return{fromIndex:A.index,toIndex:$.index,fromValue:A.value,toValue:$.value}}}if(a==="up"){const g=re(c,r,f,s);if(g<0)return null;const w=ie(e,r,f,g);if(w<0)return null;const d=W(e,r,w),p=H(c,r,g);return[d,p].every(Number.isFinite)?{fromIndex:w,toIndex:g,fromValue:d,toValue:p}:null}const o=ie(e,r,f,s);if(o<0)return null;const h=re(c,r,f,o);if(h<0)return null;const u=W(e,r,o),b=H(c,r,h);return[u,b].every(Number.isFinite)?{fromIndex:h,toIndex:o,fromValue:b,toValue:u}:null}function _e(c,e,r,t){const i=Math.min(c.length,e.length,r.length),n=new Array(i),s=new Array(i),l=new Array(i),f=new Array(i),a=new Array(i),m=new Array(i),o=new Array(i);for(let h=0;h<i;h++){const u=xe(c,e,r,h,t);if(!u){n[h]=void 0,s[h]=void 0,l[h]=void 0,f[h]=void 0,a[h]=void 0,m[h]=void 0,o[h]=void 0;continue}n[h]=u.fromValue,s[h]=u.toValue,l[h]=u.fromIndex,f[h]=u.toIndex,a[h]=u.fromValue,o[h]=u.toValue,m[h]=u.fromValue+(u.toValue-u.fromValue)*.5}return{from:n,to:s,fromIndex:l,toIndex:f,lvl0:a,lvl50:m,lvl100:o}}function D(c,e){const r=[];let t=0;for(let i=0;i<c.length;i++){const n=c[i];t+=n??0,i>=e&&(t-=c[i-e]??0),r.push(i>=e-1?t/e:void 0)}return r}function $e(c,e){const r=[],t=e*(e+1)/2;for(let i=0;i<c.length;i++){if(i<e-1){r.push(void 0);continue}let n=0;for(let s=0;s<e;s++)n+=(c[i-s]??0)*(e-s);r.push(n/t)}return r}function Ee(c,e){const r=[];let t,i=0;for(let n=0;n<c.length;n++){const s=c[n];if(s==null){r.push(void 0);continue}if(t===void 0){if(i+=s,n<e-1){r.push(void 0);continue}t=i/e,r.push(t);continue}t=(t*(e-1)+s)/e,r.push(t)}return r}function K(c,e){const r=[],t=2/(e+1);let i;for(let n=0;n<c.length;n++){const s=c[n];if(s==null){r.push(void 0);continue}i=i===void 0?s:s*t+i*(1-t),r.push(i)}return r}function Ce(c,e){const r=[];let t,i=0,n=0,s=!1;const l=[],f=[];for(let a=0;a<c.length;a++){const m=c[a];if(m==null){r.push(void 0);continue}if(t===void 0){t=m,r.push(void 0);continue}const o=m-t;t=m;const h=o>0?o:0,u=o<0?-o:0;if(s)i=(i*(e-1)+h)/e,n=(n*(e-1)+u)/e;else{if(l.push(h),f.push(u),l.length<e){r.push(void 0);continue}i=l.reduce((b,g)=>b+g,0)/e,n=f.reduce((b,g)=>b+g,0)/e,s=!0}if(n===0)r.push(100);else{const b=i/n;r.push(100-100/(1+b))}}return r}function J(c,e,r,t){const i=r.length,n=new Array(i).fill(0);let s;for(let a=0;a<i;a++){const m=c[a]??r[a]??NaN,o=e[a]??r[a]??NaN,h=r[a]??NaN;let u=Math.max(0,m-o);s!==void 0&&(u=Math.max(u,Math.abs(m-s),Math.abs(o-s))),n[a]=u,s=h}const l=new Array(i);let f=0;for(let a=0;a<i;a++)f+=n[a],a===t-1?l[a]=f/t:a>=t?l[a]=(l[a-1]*(t-1)+n[a])/t:l[a]=void 0;return l}function Ie(c,e){const r=new Array(c.length);let t=0,i;for(let n=0;n<c.length;n++){const s=c[n],l=e[n]??0;if(i===void 0||s===void 0){r[n]=void 0,i=s;continue}s>i?t+=l:s<i&&(t-=l),r[n]=t,i=s}return r}function Le(c,e,r,t){const i=r.length,n=new Array(i);for(let f=0;f<i;f++)n[f]=((c[f]??r[f]??0)+(e[f]??r[f]??0)+(r[f]??0))/3;const s=D(n.map(f=>f),t).map(f=>f),l=new Array(i);for(let f=0;f<i;f++){if(f<t-1){l[f]=void 0;continue}let a=0;for(let o=f-t+1;o<=f;o++)a+=Math.abs(n[o]-s[f]);a=a/t;const m=.015*a;l[f]=m===0?void 0:(n[f]-s[f])/m}return l}function je(c,e,r,t,i){const n=r.length,s=new Array(n),l=new Array(n);for(let a=0;a<n;a++)l[a]=((c[a]??r[a]??0)+(e[a]??r[a]??0)+(r[a]??0))/3;const f=new Array(n);for(let a=0;a<n;a++)f[a]=l[a]*(t[a]??0);for(let a=0;a<n;a++){if(a<i){s[a]=void 0;continue}let m=0,o=0;for(let u=a-i+1;u<=a;u++)l[u]>=l[u-1]?m+=f[u]:o+=f[u];const h=o===0?1/0:m/o;s[a]=100-100/(1+h)}return s}function Ve(c,e){const r=c.map((s,l)=>((s??0)+(e[l]??0))/2),t=D(r,5),i=D(r,34),n=new Array(r.length);for(let s=0;s<r.length;s++){const l=t[s],f=i[s];n[s]=l===void 0||f===void 0?void 0:l-f}return n}function Oe(c,e){const r=K(c,e).map(s=>s??NaN),t=K(r,e).map(s=>s??NaN),i=K(t,e).map(s=>s??NaN),n=new Array(c.length);for(let s=1;s<c.length;s++){const l=i[s-1],f=i[s];n[s]=l===void 0||f===void 0||l===0?void 0:(f/l-1)*100}return n[0]=void 0,n}function oe(c,e){const r=new Array(c.length);let t=0,i=0;for(let n=0;n<c.length;n++){const s=c[n],l=e[n]??0;if(s===void 0){r[n]=void 0;continue}t+=s*l,i+=l,r[n]=i===0?void 0:t/i}return r}function Ke(c,e,r){const t=new Array(c.length);let i=0,n=0;for(let s=0;s<c.length;s++){const l=c[s],f=e[s]??0;if(l!==void 0&&(i+=l*f,n+=f),s>=r){const a=c[s-r],m=e[s-r]??0;a!==void 0&&(i-=a*m,n-=m)}t[s]=s>=r-1&&n!==0?i/n:void 0}return t}function ae(c,e,r){const t=c.map(f=>f??NaN),i=D(t,e),n=[];for(let f=0;f<t.length;f++){if(f<e-1){n.push(void 0);continue}let a=0;for(let h=f-e+1;h<=f;h++)a+=t[h];const m=a/e;let o=0;for(let h=f-e+1;h<=f;h++){const u=t[h]-m;o+=u*u}n.push(Math.sqrt(o/e))}const s=new Array(t.length),l=new Array(t.length);for(let f=0;f<t.length;f++){const a=i[f],m=n[f];s[f]=a===void 0||m===void 0?void 0:a+r*m,l[f]=a===void 0||m===void 0?void 0:a-r*m}return{mid:i,upper:s,lower:l}}function Pe(c,e,r,t,i){const n=r.length,s=J(c,e,r,t).map(u=>u??NaN),l=new Array(n),f=new Array(n);for(let u=0;u<n;u++){const b=((c[u]??r[u]??0)+(e[u]??r[u]??0))/2,g=s[u];l[u]=b+i*g,f[u]=b-i*g}const a=new Array(n);let m=NaN,o=NaN,h=!0;for(let u=0;u<n;u++){m=Number.isFinite(m)?Math.min(l[u],m):l[u],o=Number.isFinite(o)?Math.max(f[u],o):f[u];const b=r[u]??NaN;if(!Number.isFinite(b)){a[u]=void 0;continue}h?(b<o&&(h=!1,m=l[u]),a[u]=o):(b>m&&(h=!0,o=f[u]),a[u]=m)}return a}function ze(c,e,r,t,i){const n=K(r,t).map(m=>m??NaN),s=J(c,e,r,t).map(m=>m??NaN),l=r.length,f=new Array(l),a=new Array(l);for(let m=0;m<l;m++){const o=n[m],h=s[m];f[m]=Number.isFinite(o)&&Number.isFinite(h)?o+i*h:void 0,a[m]=Number.isFinite(o)&&Number.isFinite(h)?o-i*h:void 0}return{mid:n,upper:f,lower:a}}function Ue(c,e,r){const t=c.length,i=new Array(t),n=new Array(t),s=new Array(t);for(let l=0;l<t;l++){if(l<r-1){i[l]=void 0,n[l]=void 0,s[l]=void 0;continue}let f=-1/0,a=1/0;for(let m=l-r+1;m<=l;m++){const o=c[m]??e[m]??NaN,h=e[m]??c[m]??NaN;Number.isFinite(o)&&o>f&&(f=o),Number.isFinite(h)&&h<a&&(a=h)}i[l]=f,n[l]=a,s[l]=Number.isFinite(f)&&Number.isFinite(a)?(f+a)/2:void 0}return{upper:i,lower:n,mid:s}}function ce(c,e){const r=c.length,t=new Array(r);for(let i=0;i<r;i++){if(i<e-1){t[i]=void 0;continue}let n=0;for(let m=i-e+1;m<=i;m++)n+=c[m]??0;const s=n/e;let l=0;for(let m=i-e+1;m<=i;m++){const o=(c[m]??0)-s;l+=o*o}const f=Math.sqrt(l/e),a=c[i]??NaN;t[i]=Number.isFinite(f)&&f!==0?(a-s)/f:void 0}return t}function le(c,e){const r=c.length,t=new Array(r);let i=c[0];for(let n=0;n<r;n++){const s=c[n],l=e[n]??0;if(s==null){t[n]=void 0;continue}const f=s>=(i??s)?1:-1;t[n]=f*l,i=s}return t}function Be(c){const e=c.length,r=new Array(e);let t=0;for(let i=0;i<e;i++){const n=c[i];if(n==null){r[i]=void 0;continue}t+=n,r[i]=t}return r}function qe(c,e){const r=c.length,t=new Array(r),i=new Array(r),n=new Array(r);for(let s=0;s<r;s++){if(s<e-1){t[s]=void 0,i[s]=void 0,n[s]=void 0;continue}let l=0,f=0,a=0,m=0,o=0;for(let N=s-e+1;N<=s;N++){const v=N-(s-e+1),y=c[N]??NaN;Number.isFinite(y)&&(l+=v,f+=y,a+=v*v,m+=v*y,o++)}const h=o*a-l*l;if(h===0||o===0){t[s]=void 0,i[s]=void 0,n[s]=void 0;continue}const u=(o*m-l*f)/h,b=(f-u*l)/o,g=e-1,w=u*g+b;t[s]=w;const d=ce(c.slice(s-e+1,s+1).map(N=>N??NaN),e).pop(),p=Number(d)*(c[s]??0?1:0);i[s]=Number.isFinite(w)?w+Math.abs(p||0):void 0,n[s]=Number.isFinite(w)?w-Math.abs(p||0):void 0}return{mid:t,upper:i,lower:n}}function De(c,e,r){const t=c.length,i=new Array(t);let n=0;for(let s=0;s<t;s++){const l=c[s],f=e[s]??0;if(l==null){i[s]=void 0;continue}const a=f/Math.max(1,e[s-1]??f);n=(n*(r-1)+l*a)/r,i[s]=n}return i}function Re(c){const{seriesMap:e,calcDefs:r,len:t,params:i,lastPrevSource:n,resolveNum:s,onError:l}=c,f=i||{};for(const a of r){const m=a.name||a.type;if(!m)continue;const o=String(m).replace(/\s+/g,"_").toLowerCase(),h=String(a.type||"").toLowerCase();if(h!=="security"){if(h==="sma"){const u=a.source||"close";e[o]=D(e[u]||e.close,Math.max(1,s(a.period,`${o}_period`,14)))}else if(h==="smma"){const u=a.source||"close";e[o]=Ee(e[u]||e.close,Math.max(1,s(a.period,`${o}_period`,13)))}else if(h==="ema"){const u=a.source||"close";e[o]=K(e[u]||e.close,Math.max(1,s(a.period,`${o}_period`,14)))}else if(h==="wma"){const u=a.source||"close";e[o]=$e(e[u]||e.close,Math.max(1,s(a.period,`${o}_period`,14)))}else if(h==="rsi"){const u=a.source||"close";e[o]=Ce(e[u]||e.close,Math.max(1,s(a.period,`${o}_period`,14)))}else if(h==="bbands"||h==="bollinger"||h==="bollinger_bands"){const u=a.source||"close",b=Math.max(1,s(a.period,`${o}_period`,20)),g=Math.max(.1,s(a.std,`${o}_std`,s(a.deviation,`${o}_deviation`,2))),{mid:w,upper:d,lower:p}=ae(e[u]||e.close,b,g);e[o+"_mid"]=w,e[o+"_upper"]=d,e[o+"_lower"]=p}else if(h==="atr"){const u=Math.max(1,s(a.period,`${o}_period`,14));e[o]=J(e.high,e.low,e.close,u)}else if(h==="obv")e[o]=Ie(e.close,e.volume);else if(h==="cci"){const u=Math.max(1,s(a.period,`${o}_period`,20));e[o]=Le(e.high,e.low,e.close,u)}else if(h==="mfi"){const u=Math.max(1,s(a.period,`${o}_period`,14));e[o]=je(e.high,e.low,e.close,e.volume,u)}else if(h==="ao")e[o]=Ve(e.high,e.low);else if(h==="trix"){const u=Math.max(1,s(a.period,`${o}_period`,12));e[o]=Oe(e.close,u)}else if(h==="vwap")e[o]=oe(e.close,e.volume);else if(h==="vwma"){const u=Math.max(1,s(a.period,`${o}_period`,20));e[o]=Ke(e.close,e.volume,u)}else if(h==="macd"){const u=(a.source||"close").replace(/\s+/g,"_").toLowerCase(),b=Math.max(1,Number(a.fast)||12),g=Math.max(1,Number(a.slow)||26),w=Math.max(1,Number(a.signal)||9),d=e[u]||e.close,p=K(d,b),N=K(d,g),v=new Array(t);for(let x=0;x<t;x++)v[x]=p[x]===void 0||N[x]===void 0?void 0:p[x]-N[x];const y=K(v,w),F=new Array(t),E=new Array(t);for(let x=0;x<t;x++){const $=v[x],A=y[x];F[x]=typeof A=="number"&&Number.isFinite(A)?A:void 0,E[x]=$!==void 0&&A!==void 0?$-A:void 0}e.macd_line=v,e.macd_signal=F,e.macd_hist=E}else if(h==="supertrend"){const u=Math.max(1,Number(a.period)||10),b=Math.max(.1,Number(a.factor)||3);e[o]=Pe(e.high,e.low,e.close,u,b)}else if(h==="kc"||h==="keltner"){const u=Math.max(1,Number(a.period)||20),b=Math.max(.1,Number(a.mult)||2),g=ze(e.high,e.low,e.close,u,b);e[o+"_mid"]=g.mid,e[o+"_upper"]=g.upper,e[o+"_lower"]=g.lower}else if(h==="donchian"){const u=Math.max(1,Number(a.period)||20),b=Ue(e.high,e.low,u);e[o+"_mid"]=b.mid,e[o+"_upper"]=b.upper,e[o+"_lower"]=b.lower}else if(h==="atr_bands"){const u=Math.max(1,Number(a.period)||14),b=Math.max(.1,Number(a.mult)||2),g=J(e.high,e.low,e.close,u),w=new Array(t),d=new Array(t);for(let p=0;p<t;p++){const N=g[p],v=e.close[p];w[p]=N!=null&&v!=null?v+b*N:void 0,d[p]=N!=null&&v!=null?v-b*N:void 0}e[o+"_upper"]=w,e[o+"_lower"]=d}else if(h==="zscore"){const u=Math.max(1,Number(a.period)||20),b=a.source||"close";e[o]=ce(e[b]||e.close,u)}else if(h==="volume_delta")e[o]=le(e.close,e.volume);else if(h==="cum_delta"){const u=le(e.close,e.volume);e[o]=Be(u)}else if(h==="vwap_bands"){const u=Math.max(1,Number(a.period)||20),b=oe(e.close,e.volume),{upper:g,lower:w}=ae(Array.from(b).map(d=>d),u,Math.max(.1,Number(a.std)||2));e[o+"_mid"]=Array.from(b),e[o+"_upper"]=g,e[o+"_lower"]=w}else if(h==="linreg_channel"){const u=Math.max(1,Number(a.period)||20),b=a.source||"close",g=qe(e[b]||e.close,u);e[o+"_mid"]=g.mid,e[o+"_upper"]=g.upper,e[o+"_lower"]=g.lower}else if(h==="evwma"){const u=Math.max(1,Number(a.period)||20);e[o]=De(e.close,e.volume,u)}else if(h==="sar"){const u=Math.max(.001,Number(a.step)||.02),b=Math.max(u,Number(a.max)||.2),g=e.high,w=e.low,d=new Array(t);let p=u,N=g[0],v=w[0],y=!0;for(let F=1;F<t;F++){const E=g[F]??NaN,x=w[F]??NaN;if(!Number.isFinite(E)||!Number.isFinite(x)){d[F]=void 0;continue}let $=v;y?($=v+p*(N-v),E>N&&(N=E,p=Math.min(b,p+u)),$>x&&(y=!1,$=N,N=x,p=u)):($=v-p*(v-N),x<N&&(N=x,p=Math.min(b,p+u)),$<E&&(y=!0,$=N,N=E,p=u)),d[F]=$,v=$}d[0]=v,e.sar=d}else if(h==="stoch"){const u=Number(a.kPeriod)||14,b=Number(a.dPeriod)||3,g=[],w=[];for(let p=0;p<t;p++){const N=Math.max(0,p-u+1);let v=-1/0,y=1/0;for(let $=N;$<=p;$++){const A=e.high[$]??e.close[$]??NaN,S=e.low[$]??e.close[$]??NaN;A>v&&(v=A),S<y&&(y=S)}const F=e.close[p]??NaN,E=v-y,x=E===0?void 0:100*((F-y)/E);g.push(x)}const d=D(g.map(p=>p??NaN),b);for(let p=0;p<t;p++)w.push(isNaN(d[p])?void 0:d[p]);e[o+"_k"]=g,e[o+"_d"]=w}else if(h==="roc"){const u=a.source||"close",b=e[u]||e.close,g=Math.max(1,Number(a.period)||10),w=new Array(t);for(let d=0;d<t;d++){const p=b[d],N=b[d-g];p===void 0||N===void 0||N===0?w[d]=void 0:w[d]=(p/N-1)*100}e[o]=w}else if(h==="ichimoku"){const u=Math.max(1,Number(a.tenkan)||9),b=Math.max(1,Number(a.kijun)||26),g=Math.max(1,Number(a.senkouB)||52),w=b,d=new Array(t),p=new Array(t),N=new Array(t),v=new Array(t),y=new Array(t),F=new Array(t),E=new Array(t),x=e.high,$=e.low,A=e.close,S=(M,L)=>{let I=-1/0,O=1/0;const Ge=Math.max(0,M-L+1);for(let R=Ge;R<=M;R++){const ue=x[R]??A[R]??NaN,fe=$[R]??A[R]??NaN;ue>I&&(I=ue),fe<O&&(O=fe)}return{hi:I,lo:O}};for(let M=0;M<t;M++){if(M>=u-1){const{hi:L,lo:I}=S(M,u);d[M]=(L+I)/2}if(M>=b-1){const{hi:L,lo:I}=S(M,b);p[M]=(L+I)/2}if(d[M]!==void 0&&p[M]!==void 0&&(N[M]=(d[M]+p[M])/2),M>=g-1){const{hi:L,lo:I}=S(M,g);v[M]=(L+I)/2}E[M]=M+w<t?A[M+w]:void 0}for(let M=0;M<t;M++)y[M]=M>=w?N[M-w]:void 0,F[M]=M>=w?v[M-w]:void 0;e.tenkan=d,e.kijun=p,e.spana=y,e.spanb=F,e.chikou=E}else if(h==="pivot_high"){const u=Math.max(0,Number(a.left)||3),b=Math.max(0,Number(a.right)||3),g=new Array(t);for(let w=0;w<t;w++){const d=e.high[w]??e.close[w]??NaN;if(!Number.isFinite(d)){g[w]=void 0;continue}let p=!0;const N=Math.max(0,w-u),v=Math.min(t-1,w+b);for(let y=N;y<=v;y++){if(y===w)continue;const F=e.high[y]??e.close[y]??NaN;if(!Number.isFinite(F)){p=!1;break}if(F>=d){p=!1;break}}g[w]=p?d:void 0}e[o]=g}else if(h==="pivot_low"){const u=Math.max(0,Number(a.left)||3),b=Math.max(0,Number(a.right)||3),g=new Array(t);for(let w=0;w<t;w++){const d=e.low[w]??e.close[w]??NaN;if(!Number.isFinite(d)){g[w]=void 0;continue}let p=!0;const N=Math.max(0,w-u),v=Math.min(t-1,w+b);for(let y=N;y<=v;y++){if(y===w)continue;const F=e.low[y]??e.close[y]??NaN;if(!Number.isFinite(F)){p=!1;break}if(F<=d){p=!1;break}}g[w]=p?d:void 0}e[o]=g}else if(h==="auto_fib"||h==="autofib"){const u=Math.max(2,Math.floor(s(a.lookback,`${o}_lookback`,200))),g=String(a.direction||"up").trim().toLowerCase()==="down"?"down":"up",w=String(a.method||a.mode||"extremes").trim().toLowerCase(),d=w==="pivots"||w==="pivot"||w==="swing"?"pivots":"extremes",p=Math.max(1,Math.floor(Number(a.pivotLeft??a.left??3))),N=Math.max(1,Math.floor(Number(a.pivotRight??a.right??3))),v=_e(e.high,e.low,e.close,{lookback:u,direction:g,method:d,pivotLeft:p,pivotRight:N});e[`${o}_from`]=v.from,e[`${o}_to`]=v.to,e[`${o}_from_idx`]=v.fromIndex,e[`${o}_to_idx`]=v.toIndex,e[`${o}_0`]=v.lvl0,e[`${o}_50`]=v.lvl50,e[`${o}_100`]=v.lvl100}else if(h==="last_value"){const u=String(a.source||"close").replace(/\s+/g,"_").toLowerCase(),b=e[u]||e.close,g=new Array(t);let w;for(let d=0;d<t;d++){const p=b[d];p!=null&&Number.isFinite(p)&&(w=p),g[d]=w}e[o]=g,n[o]=u}else if(h==="prev_value"){const u=String(a.source||"close").replace(/\s+/g,"_").toLowerCase(),b=e[u]||e.close,g=new Array(t);let w,d;for(let p=0;p<t;p++){const N=b[p];if(N!=null&&Number.isFinite(N)){const v=N;(w===void 0||v!==w)&&(d=w,w=v)}g[p]=d}e[o]=g,n[o]=u}else if(h==="line_value"){const u=String(a.startValue||"").replace(/\s+/g,"_").toLowerCase(),b=String(a.endValue||"").replace(/\s+/g,"_").toLowerCase();let w=n[u]||n[b]||"";w||(/pl|low/i.test(u)||/pl|low/i.test(b)?w="pl":(/ph|high/i.test(u)||/ph|high/i.test(b))&&(w="ph"));const d=e[w],p=new Array(t);if(d){const N=[];for(let v=t-1;v>=0&&N.length<2;v--){const y=d[v];y!=null&&Number.isFinite(y)&&N.push(v)}if(N.reverse(),N.length===2){const v=N[0],y=N[1],F=d[v],E=d[y];if(Number.isFinite(F)&&Number.isFinite(E)&&y!==v){const x=(E-F)/(y-v),$=F-x*v,A=Math.max(1,Number(a.lookback)||t),S=Math.max(0,y-A);for(let M=0;M<t;M++)p[M]=M>=S?x*M+$:void 0}}}e[o]=p}else if(h==="compare"){const u=String(a.left??"").trim(),b=String(a.right??"").trim(),g=String(a.op||">"),w=/^[-+]?\d+(?:\.\d+)?$/.test(u),d=/^[-+]?\d+(?:\.\d+)?$/.test(b),p=u.replace(/\s+/g,"_").toLowerCase(),N=b.replace(/\s+/g,"_").toLowerCase(),v=w?null:e[p]||e.close,y=d?null:e[N]||e.close,F=w?Number(u):NaN,E=d?Number(b):NaN,x=new Array(t);for(let $=0;$<t;$++){const A=w?F:(v==null?void 0:v[$])??NaN,S=d?E:(y==null?void 0:y[$])??NaN;if(!Number.isFinite(A)||!Number.isFinite(S)){x[$]=0;continue}let M=!1;switch(g){case">":M=A>S;break;case"<":M=A<S;break;case">=":M=A>=S;break;case"<=":M=A<=S;break;case"==":M=Math.abs(A-S)<1e-9;break;default:M=A>S;break}x[$]=M?1:0}e[o]=x}else if(typeof a.expr=="string"&&String(a.expr).trim().length)try{const u={};Object.entries(e).forEach(([d,p])=>{const N=new Float32Array(t);for(let v=0;v<t;v++)N[v]=p[v]??NaN;u[d.replace(/\s+/g,"_").toLowerCase()]=N});const b=G([{name:o,expr:String(a.expr).replace(/\$\{([^}]+)\}/g,(d,p)=>String(f[p]??d))}],u,f),g=new Array(t),w=b[o];for(let d=0;d<t;d++){const p=w==null?void 0:w[d];g[d]=Number.isFinite(p)?p:void 0}e[o]=g}catch(u){if(l){const b=(u==null?void 0:u.message)!=null?String(u.message):String(u);l(`Expression error: ${b}`,u)}}}}}function Te(c){const e=String(c||"");let r="",t=null,i=0;const n=l=>/[A-Za-z_$]/.test(l),s=l=>/[A-Za-z0-9_$]/.test(l);for(;i<e.length;){const l=e[i];if(t){r+=l,l===t&&e[i-1]!=="\\"&&(t=null),i+=1;continue}if(l==="'"||l==='"'){t=l,r+=l,i+=1;continue}if(n(l)){let f=i+1;for(;f<e.length&&s(e[f]);)f+=1;const a=e.slice(i,f);let m=f;for(;m<e.length&&/\s/.test(e[m]);)m+=1;if(e[m]==="["){let o=m+1;for(;o<e.length&&/\s/.test(e[o]);)o+=1;let h=1;e[o]==="-"&&(h=-1,o+=1);let u=o;for(;u<e.length&&/[0-9]/.test(e[u]);)u+=1;const b=e.slice(o,u);for(;u<e.length&&/\s/.test(e[u]);)u+=1;if(b&&e[u]==="]"){const g=h*Number(b);if(Number.isFinite(g)&&g>=1){r+=`prev(${a}, ${Math.floor(g)})`,i=u+1;continue}if(Number.isFinite(g)&&g===0){r+=a,i=u+1;continue}}}r+=a,i=f;continue}r+=l,i+=1}return r}function He(c){if(!c)return 0;let e=2166136261;for(let t=0;t<c.length;t++)e^=c.charCodeAt(t),e=Math.imul(e,16777619);const r=e>>>0;return r===0?1:r}function We(c){const e=String(c||"");let r="",t=0;for(;t<e.length;){const i=e[t];if(i==='"'||i==="'"){const n=i;t+=1;let s="",l=!1;for(;t<e.length;){const f=e[t];if(l){s+=f,l=!1,t+=1;continue}if(f==="\\"){l=!0,t+=1;continue}if(f===n){t+=1;break}s+=f,t+=1}r+=String(He(s));continue}r+=i,t+=1}return r}function P(c){let e=String(c||"").replace(/\bta\./g,"").replace(/\bmath\./g,"").replace(/\b(barstate|timeframe|syminfo|strategy)\.([A-Za-z0-9_]+)/gi,(r,t,i)=>`${String(t).toLowerCase()}_${i}`);return e=We(e),Te(e)}function z(c,e){const r=new Array(e);if(!c)return r.fill(void 0);for(let t=0;t<e;t++)r[t]=c[t];return r}function Y(c,e){const r={};return Object.entries(c).forEach(([t,i])=>{const n=t.replace(/\s+/g,"_").toLowerCase(),s=new Float32Array(e);for(let l=0;l<e;l++)s[l]=i[l]??NaN;r[n]=s}),r}function Z(c,e){const r=new Array(e);if(!c)return r;for(let t=0;t<e;t++){const i=c[t];r[t]=Number.isFinite(i)?i:void 0}return r}function Ze(c,e,r,t){if(typeof e=="number"&&Number.isFinite(e))return e;if(typeof e=="string"){const i=Number(e);if(Number.isFinite(i))return i;const n=e.match(/^\$\{([^}]+)\}$/),s=n?n[1]:e,l=c[s],f=typeof l=="number"?l:Number(l);if(Number.isFinite(f))return f}if(r&&c[r]!=null){const i=c[r],n=typeof i=="number"?i:Number(i);if(Number.isFinite(n))return n}return t??0}self.onmessage=c=>{var t;const e=c.data,r=(e==null?void 0:e.id)||"unknown";try{if(!(e!=null&&e.base)||!(e!=null&&e.calc)||!(e!=null&&e.series)||!(e!=null&&e.stateSeries)){const g={id:r,seriesMap:{},error:"Invalid request"};self.postMessage(g);return}const i=((t=e.base.close)==null?void 0:t.length)??0,n={};n.open=z(e.base.open,i),n.high=z(e.base.high,i),n.low=z(e.base.low,i),n.close=z(e.base.close,i),n.volume=z(e.base.volume,i),n.time=z(e.base.time,i);const s=new Array(i);for(let g=0;g<i;g++)s[g]=g;n.bar_index=s,e.extraSeries&&Object.entries(e.extraSeries).forEach(([g,w])=>{n[g.replace(/\s+/g,"_").toLowerCase()]=z(w,i)});const l=e.stage||"full",f=g=>{const w=[],d=[];return g.forEach(p=>{const N=String((p==null?void 0:p.expr)??"");/\b__arr_/i.test(N)?d.push(p):w.push(p)}),{primary:w,arrayDependent:d}},{primary:a,arrayDependent:m}=f(e.series||[]),o=(e.stateSeries||[]).filter(g=>/^__arr_/i.test(String((g==null?void 0:g.name)||""))),h=(e.stateSeries||[]).filter(g=>!/^__arr_/i.test(String((g==null?void 0:g.name)||"")));if(a.length&&i>0){const g=Y(n,i),w=G(a.map((d,p)=>({name:String(d.name||`series_${p}`),expr:P(String(d.expr||"").replace(/\$\{([^}]+)\}/g,(N,v)=>{var y;return String(((y=e.params)==null?void 0:y[v])??N)}))})),g,e.params);Object.entries(w).forEach(([d,p])=>{const N=d.replace(/\s+/g,"_").toLowerCase();n[N]=Z(p,i)})}const u={};if(Re({seriesMap:n,calcDefs:e.calc,len:i,params:e.params,lastPrevSource:u,resolveNum:(g,w,d)=>Ze(e.params||{},g,w,d)}),l!=="calc_only"&&a.length&&i>0){const g=new Set(a.map((p,N)=>String(p.name||`series_${N}`)).map(p=>p.replace(/\s+/g,"_").toLowerCase()).filter(Boolean)),w={};Object.entries(n).forEach(([p,N])=>{const v=String(p||"").replace(/\s+/g,"_").toLowerCase();if(g.has(v))return;const y=new Float32Array(i);for(let F=0;F<i;F++)y[F]=N[F]??NaN;w[v]=y});const d=G(a.map((p,N)=>({name:String(p.name||`series_${N}`),expr:P(String(p.expr||"").replace(/\$\{([^}]+)\}/g,(v,y)=>{var F;return String(((F=e.params)==null?void 0:F[y])??v)}))})),w,e.params);Object.entries(d).forEach(([p,N])=>{const v=p.replace(/\s+/g,"_").toLowerCase();n[v]=Z(N,i)})}if(l!=="calc_only"&&o.length&&i>0){const g=Y(n,i),w=ne(o.map((d,p)=>({name:String((d==null?void 0:d.name)||`state_${p}`),initExpr:(d==null?void 0:d.initExpr)!=null?P(String(d.initExpr).replace(/\$\{([^}]+)\}/g,(N,v)=>{var y;return String(((y=e.params)==null?void 0:y[v])??N)})):void 0,updateExpr:P(String((d==null?void 0:d.updateExpr)??(d==null?void 0:d.expr)??"").replace(/\$\{([^}]+)\}/g,(N,v)=>{var y;return String(((y=e.params)==null?void 0:y[v])??N)})),selfMode:d==null?void 0:d.selfMode})),g,e.params);Object.entries(w).forEach(([d,p])=>{const N=d.replace(/\s+/g,"_").toLowerCase();n[N]=Z(p,i)})}if(l!=="calc_only"&&m.length&&i>0){const g=new Set(m.map((p,N)=>String(p.name||`series_${N}`)).map(p=>p.replace(/\s+/g,"_").toLowerCase()).filter(Boolean)),w={};Object.entries(n).forEach(([p,N])=>{const v=String(p||"").replace(/\s+/g,"_").toLowerCase();if(g.has(v))return;const y=new Float32Array(i);for(let F=0;F<i;F++)y[F]=N[F]??NaN;w[v]=y});const d=G(m.map((p,N)=>({name:String(p.name||`series_${N}`),expr:P(String(p.expr||"").replace(/\$\{([^}]+)\}/g,(v,y)=>{var F;return String(((F=e.params)==null?void 0:F[y])??v)}))})),w,e.params);Object.entries(d).forEach(([p,N])=>{const v=p.replace(/\s+/g,"_").toLowerCase();n[v]=Z(N,i)})}if(l!=="calc_only"&&h.length&&i>0){const g=Y(n,i),w=ne(h.map((d,p)=>({name:String((d==null?void 0:d.name)||`state_${p}`),initExpr:(d==null?void 0:d.initExpr)!=null?P(String(d.initExpr).replace(/\$\{([^}]+)\}/g,(N,v)=>{var y;return String(((y=e.params)==null?void 0:y[v])??N)})):void 0,updateExpr:P(String((d==null?void 0:d.updateExpr)??(d==null?void 0:d.expr)??"").replace(/\$\{([^}]+)\}/g,(N,v)=>{var y;return String(((y=e.params)==null?void 0:y[v])??N)})),selfMode:d==null?void 0:d.selfMode})),g,e.params);Object.entries(w).forEach(([d,p])=>{const N=d.replace(/\s+/g,"_").toLowerCase();n[N]=Z(p,i)})}const b={id:r,seriesMap:n,lastPrevSource:u};self.postMessage(b)}catch(i){const n={id:r,seriesMap:{},error:String((i==null?void 0:i.message)||i)};self.postMessage(n)}}})();
